--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960085-OpenWRT-644-bridge_optimize_netfilter_hooks.patch.patch	2024-12-13 18:14:14.978309589 +0800
@@ -0,0 +1,198 @@
+From c9e8cfc5a7e5d2ded5e9934272af7b9b453183f1 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Mon, 8 May 2017 11:49:21 -0700
+Subject: [PATCH 171/500] OpenWRT: 644-bridge_optimize_netfilter_hooks.patch
+
+This patch applies the following upstreamed
+openwrt patch from 3.14 kernel.
+
+commit 76b37c24252b (OpenWrt: apply 644-bridge_optimize_netfilter_hooks.patch)
+
+Change-Id: I4dde201c34717321115c9c067dc10d0b38d6eee6
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+(cherry picked from commit a647c9cf03fd82ce5e090891e5ffa68e22dcf88d)
+---
+ net/bridge/br_forward.c         |  4 ++--
+ net/bridge/br_input.c           |  6 +++---
+ net/bridge/br_multicast.c       |  2 +-
+ net/bridge/br_netfilter_hooks.c | 17 +++++++++++++++++
+ net/bridge/br_private.h         | 14 ++++++++++++++
+ net/bridge/br_stp_bpdu.c        |  2 +-
+ 6 files changed, 38 insertions(+), 7 deletions(-)
+
+diff --git a/net/bridge/br_forward.c b/net/bridge/br_forward.c
+index d485af1454f5..30a1eda608e2 100644
+--- a/net/bridge/br_forward.c
++++ b/net/bridge/br_forward.c
+@@ -63,7 +63,7 @@ EXPORT_SYMBOL_GPL(br_dev_queue_push_xmit);
+ int br_forward_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
+ {
+ 	skb_clear_tstamp(skb);
+-	return NF_HOOK(NFPROTO_BRIDGE, NF_BR_POST_ROUTING,
++	return BR_HOOK(NFPROTO_BRIDGE, NF_BR_POST_ROUTING,
+ 		       net, sk, skb, NULL, skb->dev,
+ 		       br_dev_queue_push_xmit);
+ 
+@@ -112,7 +112,7 @@ static void __br_forward(const struct net_bridge_port *to,
+ 		indev = NULL;
+ 	}
+ 
+-	NF_HOOK(NFPROTO_BRIDGE, br_hook,
++	BR_HOOK(NFPROTO_BRIDGE, br_hook,
+ 		net, NULL, skb, indev, skb->dev,
+ 		br_forward_finish);
+ }
+diff --git a/net/bridge/br_input.c b/net/bridge/br_input.c
+index e0626fd6c690..2ff896f6cf39 100644
+--- a/net/bridge/br_input.c
++++ b/net/bridge/br_input.c
+@@ -65,7 +65,7 @@ static int br_pass_frame_up(struct sk_buff *skb)
+ 	br_multicast_count(br, NULL, skb, br_multicast_igmp_type(skb),
+ 			   BR_MCAST_DIR_TX);
+ 
+-	return NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN,
++	return BR_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN,
+ 		       dev_net(indev), NULL, skb, indev, NULL,
+ 		       br_netif_receive_skb);
+ }
+@@ -396,7 +396,7 @@ static rx_handler_result_t br_handle_frame(struct sk_buff **pskb)
+ 		 *   - returns = 0 (stolen/nf_queue)
+ 		 * Thus return 1 from the okfn() to signal the skb is ok to pass
+ 		 */
+-		if (NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN,
++		if (BR_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN,
+ 			    dev_net(skb->dev), NULL, skb, skb->dev, NULL,
+ 			    br_handle_local_finish) == 1) {
+ 			return RX_HANDLER_PASS;
+@@ -417,7 +417,7 @@ static rx_handler_result_t br_handle_frame(struct sk_buff **pskb)
+ 		if (ether_addr_equal(p->br->dev->dev_addr, dest))
+ 			skb->pkt_type = PACKET_HOST;
+ 
+-		if (NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING,
++		if (BR_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING,
+ 			dev_net(skb->dev), NULL, skb, skb->dev, NULL,
+ 			br_handle_local_finish) == 1) {
+ 			return RX_HANDLER_PASS;
+diff --git a/net/bridge/br_multicast.c b/net/bridge/br_multicast.c
+index 96d1fc78dd39..86e80c67a4ee 100644
+--- a/net/bridge/br_multicast.c
++++ b/net/bridge/br_multicast.c
+@@ -1801,7 +1801,7 @@ static void __br_multicast_send_query(struct net_bridge_mcast *brmctx,
+ 		skb->dev = pmctx->port->dev;
+ 		br_multicast_count(brmctx->br, pmctx->port, skb, igmp_type,
+ 				   BR_MCAST_DIR_TX);
+-		NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT,
++		BR_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT,
+ 			dev_net(pmctx->port->dev), NULL, skb, NULL, skb->dev,
+ 			br_dev_queue_push_xmit);
+ 
+diff --git a/net/bridge/br_netfilter_hooks.c b/net/bridge/br_netfilter_hooks.c
+index 033034d68f1f..ff606944d82f 100644
+--- a/net/bridge/br_netfilter_hooks.c
++++ b/net/bridge/br_netfilter_hooks.c
+@@ -56,6 +56,7 @@ struct brnf_net {
+ 	int call_iptables;
+ 	int call_ip6tables;
+ 	int call_arptables;
++	int call_ebtables;
+ 
+ 	/* default value is 0 */
+ 	int filter_vlan_tagged;
+@@ -72,6 +73,14 @@ struct brnf_net {
+ #define IS_ARP(skb) \
+ 	(!skb_vlan_tag_present(skb) && skb->protocol == htons(ETH_P_ARP))
+ 
++bool br_netfilter_run_hooks(struct net *net)
++{
++	struct brnf_net *brnf = net_generic(net, brnf_net_id);
++
++	return brnf->call_iptables | brnf->call_ip6tables | brnf->call_arptables |
++		brnf->call_ebtables;
++}
++
+ static inline __be16 vlan_proto(const struct sk_buff *skb)
+ {
+ 	if (skb_vlan_tag_present(skb))
+@@ -1101,6 +1110,12 @@ static struct ctl_table brnf_table[] = {
+ 		.mode		= 0644,
+ 		.proc_handler	= brnf_sysctl_call_tables,
+ 	},
++	{
++		.procname       = "bridge-nf-call-ebtables",
++		.maxlen         = sizeof(int),
++		.mode           = 0644,
++		.proc_handler   = brnf_sysctl_call_tables,
++	},
+ 	{ }
+ };
+ 
+@@ -1109,6 +1124,7 @@ static inline void br_netfilter_sysctl_default(struct brnf_net *brnf)
+ 	brnf->call_iptables = 1;
+ 	brnf->call_ip6tables = 1;
+ 	brnf->call_arptables = 1;
++	brnf->call_ebtables = 1;
+ 	brnf->filter_vlan_tagged = 0;
+ 	brnf->filter_pppoe_tagged = 0;
+ 	brnf->pass_vlan_indev = 0;
+@@ -1132,6 +1148,7 @@ static int br_netfilter_sysctl_init_net(struct net *net)
+ 	table[3].data = &brnet->filter_vlan_tagged;
+ 	table[4].data = &brnet->filter_pppoe_tagged;
+ 	table[5].data = &brnet->pass_vlan_indev;
++	table[6].data = &brnet->call_ebtables;
+ 
+ 	br_netfilter_sysctl_default(brnet);
+ 
+diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
+index a1f4acfa6994..6e1f4cfc64b0 100644
+--- a/net/bridge/br_private.h
++++ b/net/bridge/br_private.h
+@@ -19,6 +19,7 @@
+ #include <linux/if_vlan.h>
+ #include <linux/rhashtable.h>
+ #include <linux/refcount.h>
++#include <linux/netfilter.h>
+ 
+ #define BR_HASH_BITS 8
+ #define BR_HASH_SIZE (1 << BR_HASH_BITS)
+@@ -1930,12 +1931,25 @@ extern const struct nf_br_ops __rcu *nf_br_ops;
+ int br_nf_core_init(void);
+ void br_nf_core_fini(void);
+ void br_netfilter_rtable_init(struct net_bridge *);
++bool br_netfilter_run_hooks(struct net *net);
+ #else
+ static inline int br_nf_core_init(void) { return 0; }
+ static inline void br_nf_core_fini(void) {}
+ #define br_netfilter_rtable_init(x)
++static inline bool br_netfilter_run_hooks(struct net *net) { return false; }
+ #endif
+ 
++static inline int
++BR_HOOK(uint8_t pf, unsigned int hook, struct net *net, struct sock *sk,
++	struct sk_buff *skb, struct net_device *in, struct net_device *out,
++	int (*okfn)(struct net *, struct sock *, struct sk_buff *))
++{
++	if (!br_netfilter_run_hooks(net))
++		return okfn(net, sk, skb);
++
++	return NF_HOOK(pf, hook, net, sk, skb, in, out, okfn);
++}
++
+ /* br_stp.c */
+ void br_set_state(struct net_bridge_port *p, unsigned int state);
+ struct net_bridge_port *br_get_port(struct net_bridge *br, u16 port_no);
+diff --git a/net/bridge/br_stp_bpdu.c b/net/bridge/br_stp_bpdu.c
+index 9d2a235260eb..8d954196ff8e 100644
+--- a/net/bridge/br_stp_bpdu.c
++++ b/net/bridge/br_stp_bpdu.c
+@@ -56,7 +56,7 @@ static void br_send_bpdu(struct net_bridge_port *p,
+ 
+ 	skb_reset_mac_header(skb);
+ 
+-	NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT,
++	BR_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT,
+ 		dev_net(p->dev), NULL, skb, NULL, skb->dev,
+ 		br_send_bpdu_finish);
+ }
+-- 
+2.34.1
+
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960095-OpenWrt-680-NET-skip-GRO-for-foreign-MAC-addresses.p.patch	2024-12-13 18:14:14.978309589 +0800
@@ -0,0 +1,175 @@
+From 7fb90307afc58636063eb9a57cb900bbb09d7a46 Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Thu, 16 Mar 2023 17:35:20 +0530
+Subject: [PATCH 065/500] OpenWrt:
+ 680-NET-skip-GRO-for-foreign-MAC-addresses.patch
+
+net: replace GRO optimization patch with a new one that supports VLANs/bridges with different MAC addresses
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+
+Change-Id: If09dff78ce0e2628b45bed0d40e194dba2f89f86
+Signed-off-by: Ram Chandra Jangir <quic_rjangir@quicinc.com>
+(cherry picked from commit 13dc0caca570d2ce5a36151f5ec72c2390723dba)
+---
+ include/linux/netdevice.h |  2 ++
+ include/linux/skbuff.h    |  2 +-
+ net/core/dev.c            | 45 +++++++++++++++++++++++++++++++++++++++
+ net/core/gro.c            |  3 +++
+ net/ethernet/eth.c        | 16 ++++++++++++++
+ 5 files changed, 67 insertions(+), 1 deletion(-)
+
+diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
+index b646609f09c0..a3b25cecebde 100644
+--- a/include/linux/netdevice.h
++++ b/include/linux/netdevice.h
+@@ -2175,6 +2175,8 @@ struct net_device {
+ 	struct netdev_hw_addr_list	mc;
+ 	struct netdev_hw_addr_list	dev_addrs;
+ 
++	unsigned char           local_addr_mask[MAX_ADDR_LEN];
++
+ #ifdef CONFIG_SYSFS
+ 	struct kset		*queues_kset;
+ #endif
+diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
+index d209a02b415d..5f681e154b23 100644
+--- a/include/linux/skbuff.h
++++ b/include/linux/skbuff.h
+@@ -964,7 +964,7 @@ struct sk_buff {
+ #ifdef CONFIG_IPV6_NDISC_NODETYPE
+ 	__u8			ndisc_nodetype:2;
+ #endif
+-
++	__u8			gro_skip:1;
+ #if IS_ENABLED(CONFIG_IP_VS)
+ 	__u8			ipvs_property:1;
+ #endif
+diff --git a/net/core/dev.c b/net/core/dev.c
+index 9f3f8930c691..4f8c9cf5ed3e 100644
+--- a/net/core/dev.c
++++ b/net/core/dev.c
+@@ -7683,6 +7683,48 @@ static void __netdev_adjacent_dev_unlink_neighbour(struct net_device *dev,
+ 					   &upper_dev->adj_list.lower);
+ }
+ 
++static void __netdev_addr_mask(unsigned char *mask, const unsigned char *addr,
++			      struct net_device *dev)
++{
++	int i;
++
++	for (i = 0; i < dev->addr_len; i++)
++		mask[i] |= addr[i] ^ dev->dev_addr[i];
++}
++
++static void __netdev_upper_mask(unsigned char *mask, struct net_device *dev,
++			       struct net_device *lower)
++{
++	struct net_device *cur;
++	struct list_head *iter;
++
++	netdev_for_each_upper_dev_rcu(dev, cur, iter) {
++		__netdev_addr_mask(mask, cur->dev_addr, lower);
++		__netdev_upper_mask(mask, cur, lower);
++	}
++}
++
++static void __netdev_update_addr_mask(struct net_device *dev)
++{
++	unsigned char mask[MAX_ADDR_LEN];
++	struct net_device *cur;
++	struct list_head *iter;
++
++	memset(mask, 0, sizeof(mask));
++	__netdev_upper_mask(mask, dev, dev);
++	memcpy(dev->local_addr_mask, mask, dev->addr_len);
++
++	netdev_for_each_lower_dev(dev, cur, iter)
++		__netdev_update_addr_mask(cur);
++}
++
++static void netdev_update_addr_mask(struct net_device *dev)
++{
++	rcu_read_lock();
++	__netdev_update_addr_mask(dev);
++	rcu_read_unlock();
++}
++
+ static int __netdev_upper_dev_link(struct net_device *dev,
+ 				   struct net_device *upper_dev, bool master,
+ 				   void *upper_priv, void *upper_info,
+@@ -7734,6 +7776,7 @@ static int __netdev_upper_dev_link(struct net_device *dev,
+ 	if (ret)
+ 		return ret;
+ 
++	netdev_update_addr_mask(dev);
+ 	ret = call_netdevice_notifiers_info(NETDEV_CHANGEUPPER,
+ 					    &changeupper_info.info);
+ 	ret = notifier_to_errno(ret);
+@@ -7830,6 +7873,7 @@ static void __netdev_upper_dev_unlink(struct net_device *dev,
+ 
+ 	__netdev_adjacent_dev_unlink_neighbour(dev, upper_dev);
+ 
++	netdev_update_addr_mask(dev);
+ 	call_netdevice_notifiers_info(NETDEV_CHANGEUPPER,
+ 				      &changeupper_info.info);
+ 
+@@ -8886,6 +8930,7 @@ int dev_set_mac_address(struct net_device *dev, struct sockaddr *sa,
+ 			return err;
+ 	}
+ 	dev->addr_assign_type = NET_ADDR_SET;
++	netdev_update_addr_mask(dev);
+ 	call_netdevice_notifiers(NETDEV_CHANGEADDR, dev);
+ 	add_device_randomness(dev->dev_addr, dev->addr_len);
+ 	return 0;
+diff --git a/net/core/gro.c b/net/core/gro.c
+index 0759277dc14e..55ac10e4babf 100644
+--- a/net/core/gro.c
++++ b/net/core/gro.c
+@@ -445,6 +445,9 @@ static enum gro_result dev_gro_receive(struct napi_struct *napi, struct sk_buff
+ 	enum gro_result ret;
+ 	int same_flow;
+ 
++	if (skb->gro_skip)
++		goto normal;
++
+ 	if (netif_elide_gro(skb->dev))
+ 		goto normal;
+ 
+diff --git a/net/ethernet/eth.c b/net/ethernet/eth.c
+index 2edc8b796a4e..153d2b0db8e5 100644
+--- a/net/ethernet/eth.c
++++ b/net/ethernet/eth.c
+@@ -143,6 +143,18 @@ u32 eth_get_headlen(const struct net_device *dev, const void *data, u32 len)
+ }
+ EXPORT_SYMBOL(eth_get_headlen);
+ 
++static inline bool
++eth_check_local_mask(const void *addr1, const void *addr2, const void *mask)
++{
++	const u16 *a1 = addr1;
++	const u16 *a2 = addr2;
++	const u16 *m = mask;
++
++	return (((a1[0] ^ a2[0]) & ~m[0]) |
++		((a1[1] ^ a2[1]) & ~m[1]) |
++		((a1[2] ^ a2[2]) & ~m[2]));
++}
++
+ /**
+  * eth_type_trans - determine the packet's protocol ID.
+  * @skb: received socket data
+@@ -174,6 +186,10 @@ __be16 eth_type_trans(struct sk_buff *skb, struct net_device *dev)
+ 		} else {
+ 			skb->pkt_type = PACKET_OTHERHOST;
+ 		}
++
++		if (eth_check_local_mask(eth->h_dest, dev->dev_addr,
++					 dev->local_addr_mask))
++			skb->gro_skip = 1;
+ 	}
+ 
+ 	/*
+-- 
+2.34.1
+
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960179-bridge-Add-new-bridge-APIs-needed-for-network-HW-acc.patch	2024-12-13 18:14:14.978309589 +0800
@@ -0,0 +1,161 @@
+From 6447fffde1be8235684aaa6b94e016e9c18f7776 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <quic_msezgin@quicinc.com>
+Date: Wed, 10 May 2023 13:15:19 -0700
+Subject: [PATCH 212/500] bridge: Add new bridge APIs needed for network HW
+ acceleration
+
+Bridge acceleration hardware needs to perform certain operations,
+ currently unsupported by the existing bridge code:
+ *given a certain bridge device and a MAC@, figure out on
+  which underlying slave port this MAC@ is located
+ *trigger an FDB entry refresh from outside the bridge code: packets will
+  not be seen anymore in the host, once a flow has been accelerated.
+  So the hardware accelerator driver needs to keep track of the accelerated
+  flows and refresh the MACs accordingly.
+ *update bridge interface statistics from outside the bridge code:
+  once acceleration is enabled on a connection, packets will not flow
+  through the host CPU, so we need the hardware accelerator driver to
+  maintain the statistics on the host and update them and add whatever
+  flows through the hardware.
+ These change adds the corresponding functions, and make it available
+ to other through EXPORT_SYMBOLS().
+
+Change-Id: I67afb325796004053897d9916e2df91827b65139
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+
+net: bridge: Rework APIs added for network HW acceleration
+
+This change is to rework the bridge APIs based on the feedback from the
+chromium community
+
+Change-Id: I92a65f1eb26c6700d871f9deb40bccf302cf18eb
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+Signed-off-by: Murat Sezgin <quic_msezgin@quicinc.com>
+---
+ include/linux/if_bridge.h |  8 ++++++
+ net/bridge/br_fdb.c       | 38 ++++++++++++++++++++++++++++
+ net/bridge/br_if.c        | 52 +++++++++++++++++++++++++++++++++++++++
+ 3 files changed, 98 insertions(+)
+
+--- a/include/linux/if_bridge.h
++++ b/include/linux/if_bridge.h
+@@ -71,6 +71,14 @@ void brioctl_set(int (*hook)(struct net
+ 			     void __user *uarg));
+ int br_ioctl_call(struct net *net, struct net_bridge *br, unsigned int cmd,
+ 		  struct ifreq *ifr, void __user *uarg);
++extern struct net_device *br_port_dev_get(struct net_device *dev,
++					  unsigned char *addr);
++extern void br_refresh_fdb_entry(struct net_device *dev, const char *addr);
++extern void br_dev_update_stats(struct net_device *dev,
++				struct rtnl_link_stats64 *nlstats);
++extern struct net_bridge_fdb_entry *br_fdb_has_entry(struct net_device *dev,
++						     const char *addr,
++						     __u16 vid);
+ 
+ #if IS_ENABLED(CONFIG_BRIDGE) && IS_ENABLED(CONFIG_BRIDGE_IGMP_SNOOPING)
+ int br_multicast_list_adjacent(struct net_device *dev,
+--- a/net/bridge/br_fdb.c
++++ b/net/bridge/br_fdb.c
+@@ -914,6 +914,44 @@ void br_fdb_update(struct net_bridge *br
+ 	}
+ }
+ 
++/* Refresh FDB entries for bridge packets being forwarded by offload engines */
++void br_refresh_fdb_entry(struct net_device *dev, const char *addr)
++{
++	struct net_bridge_port *p = br_port_get_rcu(dev);
++
++	if (!p || p->state == BR_STATE_DISABLED)
++		return;
++
++	if (!is_valid_ether_addr(addr)) {
++		pr_info("bridge: Attempt to refresh with invalid ether address %pM\n",
++			addr);
++		return;
++	}
++
++	rcu_read_lock();
++	br_fdb_update(p->br, p, addr, 0, true);
++	rcu_read_unlock();
++}
++EXPORT_SYMBOL_GPL(br_refresh_fdb_entry);
++
++/* Look up the MAC address in the device's bridge fdb table */
++struct net_bridge_fdb_entry *br_fdb_has_entry(struct net_device *dev,
++					      const char *addr, __u16 vid)
++{
++	struct net_bridge_port *p = br_port_get_rcu(dev);
++	struct net_bridge_fdb_entry *fdb;
++
++	if (!p || p->state == BR_STATE_DISABLED)
++		return NULL;
++
++	rcu_read_lock();
++	fdb = fdb_find_rcu(&p->br->fdb_hash_tbl, addr, vid);
++	rcu_read_unlock();
++
++	return fdb;
++}
++EXPORT_SYMBOL_GPL(br_fdb_has_entry);
++
+ /* Dump information about entries, in response to GETNEIGH */
+ int br_fdb_dump(struct sk_buff *skb,
+ 		struct netlink_callback *cb,
+--- a/net/bridge/br_if.c
++++ b/net/bridge/br_if.c
+@@ -778,3 +778,55 @@ bool br_port_flag_is_set(const struct ne
+ 	return p->flags & flag;
+ }
+ EXPORT_SYMBOL_GPL(br_port_flag_is_set);
++
++/* br_port_dev_get()
++ *      Using the given addr, identify the port to which it is reachable,
++ *      returing a reference to the net device associated with that port.
++ *
++ * NOTE: Return NULL if given dev is not a bridge or the mac has no
++ * associated port.
++ */
++struct net_device *br_port_dev_get(struct net_device *dev, unsigned char *addr)
++{
++	struct net_bridge_fdb_entry *fdbe;
++	struct net_bridge *br;
++	struct net_device *netdev = NULL;
++
++	/* Is this a bridge? */
++	if (!(dev->priv_flags & IFF_EBRIDGE))
++		return NULL;
++
++	br = netdev_priv(dev);
++
++	/* Lookup the fdb entry and get reference to the port dev */
++	rcu_read_lock();
++	fdbe = br_fdb_find_rcu(br, addr, 0);
++	if (fdbe && fdbe->dst) {
++		netdev = fdbe->dst->dev; /* port device */
++		dev_hold(netdev);
++	}
++	rcu_read_unlock();
++	return netdev;
++}
++EXPORT_SYMBOL_GPL(br_port_dev_get);
++
++/* Update bridge statistics for bridge packets processed by offload engines */
++void br_dev_update_stats(struct net_device *dev,
++			 struct rtnl_link_stats64 *nlstats)
++{
++	struct pcpu_sw_netstats *stats;
++
++	/* Is this a bridge? */
++	if (!(dev->priv_flags & IFF_EBRIDGE))
++		return;
++
++	stats = per_cpu_ptr(dev->tstats, 0);
++
++	u64_stats_update_begin(&stats->syncp);
++	u64_stats_add(&stats->rx_packets, nlstats->rx_packets);
++	u64_stats_add(&stats->rx_bytes, nlstats->rx_bytes);
++	u64_stats_add(&stats->tx_packets, nlstats->tx_packets);
++	u64_stats_add(&stats->tx_bytes, nlstats->tx_bytes);
++	u64_stats_update_end(&stats->syncp);
++}
++EXPORT_SYMBOL_GPL(br_dev_update_stats);
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960181-neighbour-Add-a-new-neigh-mac-update-notifier.patch	2024-12-13 18:14:14.978309589 +0800
@@ -0,0 +1,109 @@
+From 4d24f7603ac3c0a8c4fe4983ae31fcb4476b1724 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Thu, 5 May 2016 14:01:51 -0700
+Subject: [PATCH 092/500] neighbour: Add a new neigh mac update notifier
+
+With this new notifier, neighbour subsystem will
+provide a neighbour mac address update notification
+with both the old and new mac adress. This helps the
+other subsystems to do whatever they want with the old
+mac address, if they used it in their own purpose.
+
+Change-Id: I86f6f7107b4c840d05bce167594fdd43d7bb0ff3
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ include/net/neighbour.h |  8 ++++++++
+ net/core/neighbour.c    | 28 +++++++++++++++++++++++++++-
+ 2 files changed, 35 insertions(+), 1 deletion(-)
+
+--- a/include/net/neighbour.h
++++ b/include/net/neighbour.h
+@@ -249,6 +249,11 @@ static inline int neigh_parms_family(str
+ 	return p->tbl->family;
+ }
+ 
++struct neigh_mac_update {
++	unsigned char old_mac[ALIGN(MAX_ADDR_LEN, sizeof(unsigned long))];
++	unsigned char update_mac[ALIGN(MAX_ADDR_LEN, sizeof(unsigned long))];
++};
++
+ #define NEIGH_PRIV_ALIGN	sizeof(long long)
+ #define NEIGH_ENTRY_SIZE(size)	ALIGN((size), NEIGH_PRIV_ALIGN)
+ 
+@@ -395,6 +400,9 @@ void __neigh_for_each_release(struct nei
+ 			      int (*cb)(struct neighbour *));
+ int neigh_xmit(int fam, struct net_device *, const void *, struct sk_buff *);
+ 
++extern void neigh_mac_update_register_notify(struct notifier_block *nb);
++extern void neigh_mac_update_unregister_notify(struct notifier_block *nb);
++
+ struct neigh_seq_state {
+ 	struct seq_net_private p;
+ 	struct neigh_table *tbl;
+--- a/net/core/neighbour.c
++++ b/net/core/neighbour.c
+@@ -1275,6 +1275,20 @@ static void neigh_update_hhs(struct neig
+ 	}
+ }
+ 
++ATOMIC_NOTIFIER_HEAD(neigh_mac_update_notifier_list);
++
++void neigh_mac_update_register_notify(struct notifier_block *nb)
++{
++	atomic_notifier_chain_register(&neigh_mac_update_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(neigh_mac_update_register_notify);
++
++void neigh_mac_update_unregister_notify(struct notifier_block *nb)
++{
++	atomic_notifier_chain_unregister(&neigh_mac_update_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(neigh_mac_update_unregister_notify);
++
+ /* Generic update routine.
+    -- lladdr is new lladdr or NULL, if it is not supplied.
+    -- new    is new state.
+@@ -1303,6 +1317,7 @@ static int __neigh_update(struct neighbo
+ 	struct net_device *dev;
+ 	int err, notify = 0;
+ 	u8 old;
++	struct neigh_mac_update nmu;
+ 
+ 	trace_neigh_update(neigh, lladdr, new, flags, nlmsg_pid);
+ 
+@@ -1312,6 +1327,8 @@ static int __neigh_update(struct neighbo
+ 	old    = neigh->nud_state;
+ 	err    = -EPERM;
+ 
++	memset(&nmu, 0, sizeof(struct neigh_mac_update));
++
+ 	if (neigh->dead) {
+ 		NL_SET_ERR_MSG(extack, "Neighbor entry is now dead");
+ 		new = old;
+@@ -1353,7 +1370,11 @@ static int __neigh_update(struct neighbo
+ 		   and a new address is proposed:
+ 		   - compare new & old
+ 		   - if they are different, check override flag
++		   - copy old and new addresses for neigh update notification
+ 		 */
++		memcpy(nmu.old_mac, neigh->ha, dev->addr_len);
++		memcpy(nmu.update_mac, lladdr, dev->addr_len);
++
+ 		if ((old & NUD_VALID) &&
+ 		    !memcmp(lladdr, neigh->ha, dev->addr_len))
+ 			lladdr = neigh->ha;
+@@ -1476,8 +1497,13 @@ out:
+ 		neigh_update_gc_list(neigh);
+ 	if (managed_update)
+ 		neigh_update_managed_list(neigh);
+-	if (notify)
++
++	if (notify) {
+ 		neigh_update_notify(neigh, nlmsg_pid);
++		atomic_notifier_call_chain(&neigh_mac_update_notifier_list, 0,
++					   (struct neigh_mac_update *)&nmu);
++	}
++
+ 	trace_neigh_update_done(neigh, err);
+ 	return err;
+ }
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960182-net-ipv6-Fix-IPv6-user-route-change-event-calls.patch	2024-12-13 18:14:14.978309589 +0800
@@ -0,0 +1,66 @@
+From 1667939d350f5b0db4d82df3efcef249fa5404db Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Wed, 5 Aug 2020 13:21:27 -0700
+Subject: [PATCH 146/500] net:ipv6: Fix IPv6 user route change event calls
+
+These events should be called only when the route table is
+changed by the userspace. So, we should call them in the
+ioctl and the netlink message handler function.
+
+Change-Id: If7ec615014cfc79d5fa72878e49eaf99c2560c32
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ net/ipv6/route.c | 24 ++++++++++++++++++++----
+ 1 file changed, 20 insertions(+), 4 deletions(-)
+
+--- a/net/ipv6/route.c
++++ b/net/ipv6/route.c
+@@ -4497,6 +4497,10 @@ int ipv6_route_ioctl(struct net *net, un
+ 		break;
+ 	}
+ 	rtnl_unlock();
++	if (!err)
++		atomic_notifier_call_chain(&ip6route_chain,
++					   (cmd == SIOCADDRT) ? RTM_NEWROUTE : RTM_DELROUTE, &cfg);
++
+ 	return err;
+ }
+ 
+@@ -5515,11 +5519,17 @@ static int inet6_rtm_delroute(struct sk_
+ 	}
+ 
+ 	if (cfg.fc_mp)
+-		return ip6_route_multipath_del(&cfg, extack);
++		err = ip6_route_multipath_del(&cfg, extack);
+ 	else {
+ 		cfg.fc_delete_all_nh = 1;
+-		return ip6_route_del(&cfg, extack);
++		err = ip6_route_del(&cfg, extack);
+ 	}
++
++	if (!err)
++		atomic_notifier_call_chain(&ip6route_chain,
++					   RTM_DELROUTE, &cfg);
++
++	return err;
+ }
+ 
+ static int inet6_rtm_newroute(struct sk_buff *skb, struct nlmsghdr *nlh,
+@@ -5536,9 +5546,15 @@ static int inet6_rtm_newroute(struct sk_
+ 		cfg.fc_metric = IP6_RT_PRIO_USER;
+ 
+ 	if (cfg.fc_mp)
+-		return ip6_route_multipath_add(&cfg, extack);
++		err = ip6_route_multipath_add(&cfg, extack);
+ 	else
+-		return ip6_route_add(&cfg, GFP_KERNEL, extack);
++		err = ip6_route_add(&cfg, GFP_KERNEL, extack);
++
++	if (!err)
++		atomic_notifier_call_chain(&ip6route_chain,
++					   RTM_NEWROUTE, &cfg);
++
++	return err;
+ }
+ 
+ /* add the overhead of this fib6_nh to nexthop_len */
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960183-linux-change-the-port-selection-algorithm-in-ftp-alg.patch	2024-12-13 18:14:14.978309589 +0800
@@ -0,0 +1,73 @@
+From 27352c80fcef6ebeb1ea1bfb7d519e33e98128f4 Mon Sep 17 00:00:00 2001
+From: Ken Zhu <guigenz@codeaurora.org>
+Date: Mon, 8 Oct 2018 16:45:07 -0700
+Subject: [PATCH 151/500] linux: change the port selection algorithm in ftp alg
+
+In the case of MAP feature, the ports are limited to number with same PSID,
+the port should be in this format |offset|psid|pad|, the offset usually is
+6 bits, the psid varies in 0~8 and pad length of the rest bits after offset
+and psid.
+
+the new port use same first ten bits of port after SNAT and the last 6 bits
+of original port and varies the last 6 bits only.
+
+this makes sure that new port and the port after snat share the same PSID
+
+Change-Id: I5e5a3c20fa0ec4e31273c5e23c6e6aa86ebb97f6
+Signed-off-by: Ken Zhu <guigenz@codeaurora.org>
+---
+ net/netfilter/nf_nat_ftp.c | 36 ++++++++++++++++++++++++++++++++++--
+ 1 file changed, 34 insertions(+), 2 deletions(-)
+
+--- a/net/netfilter/nf_nat_ftp.c
++++ b/net/netfilter/nf_nat_ftp.c
+@@ -69,7 +69,7 @@ static unsigned int nf_nat_ftp(struct sk
+ 			       struct nf_conntrack_expect *exp)
+ {
+ 	union nf_inet_addr newaddr;
+-	u_int16_t port;
++	u16 port;
+ 	int dir = CTINFO2DIR(ctinfo);
+ 	struct nf_conn *ct = exp->master;
+ 	char buffer[sizeof("|1||65535|") + INET6_ADDRSTRLEN];
+@@ -86,7 +86,39 @@ static unsigned int nf_nat_ftp(struct sk
+ 	 * this one. */
+ 	exp->expectfn = nf_nat_follow_master;
+ 
+-	port = nf_nat_exp_find_port(exp, ntohs(exp->saved_proto.tcp.port));
++	/* In the case of MAP-E, the FTP ALG source port number must use its own
++	 * PSID. Otherwise the returned packets from ftp server will use other
++	 * than its own IPv6 address. The port number of MAP-E has the format
++	 * like offset | psid | pad. The offset length is usually 6 bits long.
++	 * So this change reuses the least  10 bits which include the valid PSID
++	 * and tries different offset value with a step size of 1024 till a
++	 * free port number is available. */
++	port = (ntohs(exp->saved_proto.tcp.port) & ~((1 << 10) - 1)) +
++		(ntohs(ct->tuplehash[!dir].tuple.dst.u.tcp.port) & ((1 << 10) - 1));
++	static const unsigned int max_attempts = 128;
++	int range, attempts_left;
++	u16 min = port;
++
++	range = USHRT_MAX - port;
++	attempts_left = range;
++
++	if (attempts_left > max_attempts)
++		attempts_left = max_attempts;
++
++	for (; ;) {
++		int ret;
++
++
++		exp->tuple.dst.u.tcp.port = htons(port);
++		ret = nf_ct_expect_related(exp, 0);
++		if (ret == 0)
++			break;
++		else if (ret != -EBUSY || (--attempts_left < 0)) {
++			port = 0;
++			break;
++		}
++	}
++
+ 	if (port == 0) {
+ 		nf_ct_helper_log(skb, exp->master, "all ports in use");
+ 		return NF_DROP;
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960188-netfilter-iptable-Fix-IPv4-default-checks.patch	2024-12-13 18:14:14.978309589 +0800
@@ -0,0 +1,70 @@
+From 6b9e06c4d45f9bd567df8a7c249274835eb52d12 Mon Sep 17 00:00:00 2001
+From: Ram Chandra Jangir <rjangir@codeaurora.org>
+Date: Sat, 30 Jul 2016 19:31:53 +0530
+Subject: [PATCH 148/500] netfilter: iptable: Fix IPv4 default checks
+
+OpenWRT: 610-netfilter_match_bypass_default_checks.patch
+This change fixes up the above patch that had some code get dropped
+when FFW linux v4.4.6 to v4.4.14
+
+Change-Id: Ic2172192f23b9ccaa7a9d56139d1f09952636396
+Signed-off-by: Ram Chandra Jangir <rjangir@codeaurora.org>
+---
+ net/ipv4/netfilter/ip_tables.c | 32 +++++++++++++++++++++++++++++---
+ 1 file changed, 29 insertions(+), 3 deletions(-)
+
+--- a/net/ipv4/netfilter/ip_tables.c
++++ b/net/ipv4/netfilter/ip_tables.c
+@@ -524,6 +524,28 @@ static void cleanup_match(struct xt_entr
+ }
+ 
+ static int
++check_entry(struct ipt_entry *e)
++{
++	const struct xt_entry_target *t;
++
++	if (!ip_checkentry(&e->ip))
++		return -EINVAL;
++
++	ip_checkdefault(&e->ip);
++
++	if (e->target_offset + sizeof(struct xt_entry_target) >
++		e->next_offset)
++		return -EINVAL;
++
++	t = ipt_get_target_c(e);
++
++	if (e->target_offset + t->u.target_size > e->next_offset)
++		return -EINVAL;
++
++	return 0;
++}
++
++static int
+ check_match(struct xt_entry_match *m, struct xt_mtchk_param *par)
+ {
+ 	const struct ipt_ip *ip = par->entryinfo;
+@@ -586,7 +608,9 @@ find_check_entry(struct ipt_entry *e, st
+ 	struct xt_mtchk_param mtpar;
+ 	struct xt_entry_match *ematch;
+ 
+-	ip_checkdefault(&e->ip);
++	ret = check_entry(e);
++	if (ret)
++		return ret;
+ 
+ 	if (!xt_percpu_counter_alloc(alloc_state, &e->counters))
+ 		return -ENOMEM;
+@@ -1382,8 +1406,10 @@ check_compat_entry_size_and_hooks(struct
+ 			     sizeof(struct compat_xt_entry_target))
+ 		return -EINVAL;
+ 
+-	if (!ip_checkentry(&e->ip))
+-		return -EINVAL;
++	/* For purposes of check_entry casting the compat entry is fine */
++	ret = check_entry((struct ipt_entry *)e);
++	if (ret)
++		return ret;
+ 
+ 	ret = xt_compat_check_entry_offsets(e, e->elems,
+ 					    e->target_offset, e->next_offset);
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960189-netfilter-fix-source-nat-issue-by-removing-the-confi.patch	2024-12-13 18:14:14.978309589 +0800
@@ -0,0 +1,32 @@
+From e8740184d0e59ce2c047c9098c4ca73b1748e943 Mon Sep 17 00:00:00 2001
+From: Ken Zhu <guigenz@codeaurora.org>
+Date: Fri, 5 Mar 2021 10:34:53 -0800
+Subject: [PATCH 150/500] netfilter: fix source nat issue by removing the
+ confirm check on nat setup
+
+When a multicast flow lands in LAN side bridge, if bridge nf call iptables
+is enabled, the flow could be sent to both WAN and some of the bridge slave
+interfaces in some cases. This could lead to no source nat action because
+the flow is already in a confirmed state which was just set by the multicast
+packet taking bridging path.
+This change removes the conntrack confirm check on nat setup.
+
+Change-Id: I38d61a403e9484e36e2e28bf6830538921556c55
+Signed-off-by: Ken Zhu <guigenz@codeaurora.org>
+---
+ net/netfilter/nf_nat_core.c | 4 ----
+ 1 file changed, 4 deletions(-)
+
+--- a/net/netfilter/nf_nat_core.c
++++ b/net/netfilter/nf_nat_core.c
+@@ -784,10 +784,6 @@ nf_nat_setup_info(struct nf_conn *ct,
+ 	struct net *net = nf_ct_net(ct);
+ 	struct nf_conntrack_tuple curr_tuple, new_tuple;
+ 
+-	/* Can't setup nat info for confirmed ct. */
+-	if (nf_ct_is_confirmed(ct))
+-		return NF_ACCEPT;
+-
+ 	WARN_ON(maniptype != NF_NAT_MANIP_SRC &&
+ 		maniptype != NF_NAT_MANIP_DST);
+ 
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960191-linux-clean-the-cb-before-icmp_send.patch	2024-12-13 18:14:14.978309589 +0800
@@ -0,0 +1,28 @@
+From 2fb3a3257bab4d3b540b503fe0a60b1c644bb4c3 Mon Sep 17 00:00:00 2001
+From: Ken Zhu <guigenz@codeaurora.org>
+Date: Tue, 20 Mar 2018 12:18:01 -0700
+Subject: [PATCH 142/500] linux: clean the cb before icmp_send
+
+In the icmp_send function, skb->cb is used as ip_option, but it may be used
+by other sub-systems before ipv4_link_failure.
+
+So clean the skb->cb before entering icmp_send.
+
+Change-Id: I985b363e7f1b00314843bcda1fa8b78bbc1bd7d8
+Signed-off-by: Ken Zhu <guigenz@codeaurora.org>
+---
+ net/ipv4/route.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+--- a/net/ipv4/route.c
++++ b/net/ipv4/route.c
+@@ -1240,6 +1240,9 @@ static void ipv4_link_failure(struct sk_
+ {
+ 	struct rtable *rt;
+ 
++	/* Forwarding packets, do not have IPCB() initialized, do so
++	 */
++	memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));
+ 	ipv4_send_dest_unreach(skb);
+ 
+ 	rt = skb_rtable(skb);
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960192-ipv6-Export-ndisc_send_ns-function-for-public-use.patch	2024-12-13 18:14:14.978309589 +0800
@@ -0,0 +1,24 @@
+From 58a9e8c4c441c739821255d88b7c08330b392303 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Tue, 27 Jan 2015 11:10:26 -0800
+Subject: [PATCH 143/500] ipv6: Export ndisc_send_ns() function for public use.
+
+This API is needed to implement a connection
+manager for hardware accelaration.
+
+Change-Id: Idcf5fa1d3d3151fa2a5e0c48c6b6cdd10fc335bf
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ net/ipv6/ndisc.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/net/ipv6/ndisc.c
++++ b/net/ipv6/ndisc.c
+@@ -668,6 +668,7 @@ void ndisc_send_ns(struct net_device *de
+ 	if (skb)
+ 		ndisc_send_skb(skb, daddr, saddr);
+ }
++EXPORT_SYMBOL(ndisc_send_ns);
+ 
+ void ndisc_send_rs(struct net_device *dev, const struct in6_addr *saddr,
+ 		   const struct in6_addr *daddr)
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960193-netfiter-remove-warning-of-confirmed-checking.patch	2024-12-13 18:14:14.978309589 +0800
@@ -0,0 +1,29 @@
+From 1e2220e132745a4d0e27c647056c93848b189ddb Mon Sep 17 00:00:00 2001
+From: Ken Zhu <guigenz@codeaurora.org>
+Date: Wed, 28 Apr 2021 09:11:11 -0700
+Subject: [PATCH 149/500] netfiter: remove warning of confirmed checking
+
+When bridge-nf-call-iptables is enabled, a multicast
+packet could go through both bridging and routing
+forwarding process in some cases.
+It gets confirmed in bridging forwarding first and then
+it run into the warning when reaching nat_setup_info..
+
+Change-Id: Id4b49b81d9748033cc61acea9e4ed96aa2e50c8c
+Signed-off-by: Ken Zhu <guigenz@codeaurora.org>
+---
+ net/netfilter/nf_conntrack_core.c | 3 ---
+ 1 file changed, 3 deletions(-)
+
+--- a/net/netfilter/nf_conntrack_core.c
++++ b/net/netfilter/nf_conntrack_core.c
+@@ -2049,9 +2049,6 @@ void nf_conntrack_alter_reply(struct nf_
+ {
+ 	struct nf_conn_help *help = nfct_help(ct);
+ 
+-	/* Should be unconfirmed, so not in hash table yet */
+-	WARN_ON(nf_ct_is_confirmed(ct));
+-
+ 	nf_ct_dump_tuple(newreply);
+ 
+ 	ct->tuplehash[IP_CT_DIR_REPLY].tuple = *newreply;
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960195-netfilter-export-udp_get_timeouts-function.patch	2024-12-13 18:14:14.978309589 +0800
@@ -0,0 +1,38 @@
+From f6505b020f13fc9f0181758eb8ea436dcc39feb3 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Mon, 6 Apr 2020 11:08:09 -0700
+Subject: [PATCH 147/500] netfilter: export udp_get_timeouts function
+
+This function is required for acceleration support.
+
+Change-Id: Ibca4f402735764e7e6fb3ce2678e670753c6ef9c
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ include/net/netfilter/nf_conntrack_timeout.h | 1 +
+ net/netfilter/nf_conntrack_proto_udp.c       | 3 ++-
+ 2 files changed, 3 insertions(+), 1 deletion(-)
+
+--- a/include/net/netfilter/nf_conntrack_timeout.h
++++ b/include/net/netfilter/nf_conntrack_timeout.h
+@@ -107,5 +107,6 @@ struct nf_ct_timeout_hooks {
+ 
+ extern const struct nf_ct_timeout_hooks __rcu *nf_ct_timeout_hook;
+ #endif
++extern unsigned int *udp_get_timeouts(struct net *net);
+ 
+ #endif /* _NF_CONNTRACK_TIMEOUT_H */
+--- a/net/netfilter/nf_conntrack_proto_udp.c
++++ b/net/netfilter/nf_conntrack_proto_udp.c
+@@ -29,10 +29,11 @@ static const unsigned int udp_timeouts[U
+ 	[UDP_CT_REPLIED]	= 120*HZ,
+ };
+ 
+-static unsigned int *udp_get_timeouts(struct net *net)
++unsigned int *udp_get_timeouts(struct net *net)
+ {
+ 	return nf_udp_pernet(net)->timeouts;
+ }
++EXPORT_SYMBOL(udp_get_timeouts);
+ 
+ static void udp_error_log(const struct sk_buff *skb,
+ 			  const struct nf_hook_state *state,
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960196-Add-support-for-first-IP-fragment-dissection.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,30 @@
+From 12b82d279f9dfdf0c88ce9b2758cebe4b3044f47 Mon Sep 17 00:00:00 2001
+From: Abhishek Chaudhary <quic_ach@quicinc.com>
+Date: Mon, 8 Aug 2022 18:18:55 +0530
+Subject: [PATCH 089/500] Add support for first IP fragment dissection
+
+Add support for dissecting ports from first fragment of the
+IP packet. This is needed for PPE to find the 5-tuple/flow
+to flush the rule based on exception due to fragmented
+IP packets.
+
+Change-Id: Ibb372e60381ed232dbaecd5d63a7d2fa6ae2dd9a
+Signed-off-by: Abhishek Chaudhary <quic_ach@quicinc.com>
+---
+ net/core/flow_dissector.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/net/core/flow_dissector.c
++++ b/net/core/flow_dissector.c
+@@ -1627,9 +1627,10 @@ ip_proto_again:
+ 		break;
+ 	}
+ 
+-	if (!(key_control->flags & FLOW_DIS_IS_FRAGMENT))
++	if (!(key_control->flags & FLOW_DIS_IS_FRAGMENT) || (key_control->flags & FLOW_DIS_FIRST_FRAG)) {
+ 		__skb_flow_dissect_ports(skb, flow_dissector, target_container,
+ 					 data, nhoff, ip_proto, hlen);
++	}
+ 
+ 	/* Process result of IP proto processing */
+ 	switch (fdret) {
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960197-net-ipv4-ipv6-Added-route-table-update-notify-chain.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,150 @@
+From 665f257e04d6534e2001e3db73c0922a2968b48b Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Wed, 10 Feb 2016 15:38:12 -0800
+Subject: [PATCH 145/500] net: ipv4/ipv6: Added route table update notify chain
+
+Registered modules are notified for the changes in the
+route table.
+
+NOTE: This patch is originally suggested by "Jozsef Kadlecsik"
+in the following email chain but never merged to any of the
+kernel versions.
+http://www.spinics.net/lists/netfilter-devel/msg24239.html
+
+Cc: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+Patch-mainline: netfilter-devel@vger.kernel.org
+
+Change-Id: I402710474be0978867dfbbbb8d1a7f8c8f3dab06
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ include/net/ip6_route.h |  3 +++
+ include/net/route.h     |  3 +++
+ net/ipv4/fib_trie.c     | 19 +++++++++++++++++++
+ net/ipv6/route.c        | 22 +++++++++++++++++++++-
+ 4 files changed, 46 insertions(+), 1 deletion(-)
+
+--- a/include/net/ip6_route.h
++++ b/include/net/ip6_route.h
+@@ -215,6 +215,9 @@ void rt6_multipath_rebalance(struct fib6
+ void rt6_uncached_list_add(struct rt6_info *rt);
+ void rt6_uncached_list_del(struct rt6_info *rt);
+ 
++int rt6_register_notifier(struct notifier_block *nb);
++int rt6_unregister_notifier(struct notifier_block *nb);
++
+ static inline const struct rt6_info *skb_rt6_info(const struct sk_buff *skb)
+ {
+ 	const struct dst_entry *dst = skb_dst(skb);
+--- a/include/net/route.h
++++ b/include/net/route.h
+@@ -237,6 +237,9 @@ struct rtable *rt_dst_alloc(struct net_d
+ 			    unsigned int flags, u16 type, bool noxfrm);
+ struct rtable *rt_dst_clone(struct net_device *dev, struct rtable *rt);
+ 
++int ip_rt_register_notifier(struct notifier_block *nb);
++int ip_rt_unregister_notifier(struct notifier_block *nb);
++
+ struct in_ifaddr;
+ void fib_add_ifaddr(struct in_ifaddr *);
+ void fib_del_ifaddr(struct in_ifaddr *, struct in_ifaddr *);
+--- a/net/ipv4/fib_trie.c
++++ b/net/ipv4/fib_trie.c
+@@ -1211,6 +1211,9 @@ static bool fib_valid_key_len(u32 key, u
+ static void fib_remove_alias(struct trie *t, struct key_vector *tp,
+ 			     struct key_vector *l, struct fib_alias *old);
+ 
++/* Define route change notification chain. */
++static BLOCKING_NOTIFIER_HEAD(iproute_chain);
++
+ /* Caller must hold RTNL. */
+ int fib_table_insert(struct net *net, struct fib_table *tb,
+ 		     struct fib_config *cfg, struct netlink_ext_ack *extack)
+@@ -1404,6 +1407,8 @@ int fib_table_insert(struct net *net, st
+ 	rtmsg_fib(RTM_NEWROUTE, htonl(key), new_fa, plen, new_fa->tb_id,
+ 		  &cfg->fc_nlinfo, nlflags);
+ succeeded:
++	blocking_notifier_call_chain(&iproute_chain,
++				     RTM_NEWROUTE, fi);
+ 	return 0;
+ 
+ out_remove_new_fa:
+@@ -1776,6 +1781,8 @@ int fib_table_delete(struct net *net, st
+ 	if (fa_to_delete->fa_state & FA_S_ACCESSED)
+ 		rt_cache_flush(cfg->fc_nlinfo.nl_net);
+ 
++	blocking_notifier_call_chain(&iproute_chain,
++				     RTM_DELROUTE, fa_to_delete->fa_info);
+ 	fib_release_info(fa_to_delete->fa_info);
+ 	alias_free_mem_rcu(fa_to_delete);
+ 	return 0;
+@@ -2408,6 +2415,18 @@ void __init fib_trie_init(void)
+ 					   0, SLAB_PANIC | SLAB_ACCOUNT, NULL);
+ }
+ 
++int ip_rt_register_notifier(struct notifier_block *nb)
++{
++	return blocking_notifier_chain_register(&iproute_chain, nb);
++}
++EXPORT_SYMBOL(ip_rt_register_notifier);
++
++int ip_rt_unregister_notifier(struct notifier_block *nb)
++{
++	return blocking_notifier_chain_unregister(&iproute_chain, nb);
++}
++EXPORT_SYMBOL(ip_rt_unregister_notifier);
++
+ struct fib_table *fib_trie_table(u32 id, struct fib_table *alias)
+ {
+ 	struct fib_table *tb;
+--- a/net/ipv6/route.c
++++ b/net/ipv6/route.c
+@@ -198,6 +198,9 @@ static void rt6_uncached_list_flush_dev(
+ 	}
+ }
+ 
++/* Define route change notification chain. */
++ATOMIC_NOTIFIER_HEAD(ip6route_chain);
++
+ static inline const void *choose_neigh_daddr(const struct in6_addr *p,
+ 					     struct sk_buff *skb,
+ 					     const void *daddr)
+@@ -3868,6 +3871,9 @@ int ip6_route_add(struct fib6_config *cf
+ 		return PTR_ERR(rt);
+ 
+ 	err = __ip6_ins_rt(rt, &cfg->fc_nlinfo, extack);
++	if (!err)
++		atomic_notifier_call_chain(&ip6route_chain,
++					   RTM_NEWROUTE, rt);
+ 	fib6_info_release(rt);
+ 
+ 	return err;
+@@ -3888,7 +3894,9 @@ static int __ip6_del_rt(struct fib6_info
+ 	spin_lock_bh(&table->tb6_lock);
+ 	err = fib6_del(rt, info);
+ 	spin_unlock_bh(&table->tb6_lock);
+-
++	if (!err)
++		atomic_notifier_call_chain(&ip6route_chain,
++					   RTM_DELROUTE, rt);
+ out:
+ 	fib6_info_release(rt);
+ 	return err;
+@@ -6352,6 +6360,18 @@ static int ip6_route_dev_notify(struct n
+ 	return NOTIFY_OK;
+ }
+ 
++int rt6_register_notifier(struct notifier_block *nb)
++{
++	return atomic_notifier_chain_register(&ip6route_chain, nb);
++}
++EXPORT_SYMBOL(rt6_register_notifier);
++
++int rt6_unregister_notifier(struct notifier_block *nb)
++{
++	return atomic_notifier_chain_unregister(&ip6route_chain, nb);
++}
++EXPORT_SYMBOL(rt6_unregister_notifier);
++
+ /*
+  *	/proc
+  */
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960198-netfilter-add-an-oif-parameter-in-IPv6-route-lookup-.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,74 @@
+From 757aed7fcf50687fc02fb75a3b3f2cead72f3515 Mon Sep 17 00:00:00 2001
+From: Ken Zhu <guigenz@codeaurora.org>
+Date: Tue, 17 Dec 2019 13:10:06 -0800
+Subject: [PATCH 144/500] netfilter: add an oif parameter in IPv6 route lookup
+ of TCP RST packet.
+
+TCP RST packet might get a different output device on the route lookup
+than the incoming device. Passing an oif parameter could help the route
+lookup more precisely in routing case.
+Reserve LL_MAX_HEADER space in the skb data in case the bridge device
+has different length of  mac header on transmitting later.
+Call trace:
+	[<ffffffc000591aac>] skb_panic+0x64/0x68
+	[<ffffffc000591b10>] skb_push+0x60/0x70
+	[<ffffffc0005c8ff8>] eth_header+0x40/0xd0
+	[<ffffffbffc8ed5a0>] nf_send_reset6+0x260/0x2c8 [nf_reject_ipv6]
+	[<ffffffbffc8f4108>] 0xffffffbffc8f4108
+	[<ffffffbffc8bb48c>] ip6t_do_table+0x304/0x560 [ip6_tables]
+	[<ffffffbffc8c5030>] 0xffffffbffc8c5030
+	[<ffffffc0005da65c>] nf_iterate+0x68/0x90
+	[<ffffffc0005da6cc>] nf_hook_slow+0x48/0xc8
+	[<ffffffc00064541c>] ip6_forward+0x710/0x7dc
+	[<ffffffc000646dcc>] ip6_rcv_finish+0x94/0xac
+	[<ffffffc00064765c>] ipv6_rcv+0x42c/0x4bc
+	[<ffffffc0005a341c>] __netif_receive_skb_core+0x5f0/0x8bc
+	[<ffffffc0005a3e54>] __netif_receive_skb+0x38/0x84
+	[<ffffffc0005a3f04>] netif_receive_skb_internal+0x64/0xb0
+	[<ffffffc0005a3fe0>] netif_receive_skb+0x90/0xc4
+	[<ffffffc000687dd0>] br_netif_receive_skb+0x40/0x4c
+	[<ffffffc000687e64>] br_pass_frame_up+0x88/0xe0
+	[<ffffffc000688410>] br_handle_frame_finish+0x4f4/0x520
+	[<ffffffc000695df8>] br_nf_pre_routing_finish_ipv6+0x21c/0x278
+	[<ffffffc000696248>] br_nf_pre_routing_ipv6+0xec/0x144
+	[<ffffffc000695a0c>] br_nf_pre_routing+0x150/0x320
+	[<ffffffc0005da65c>] nf_iterate+0x68/0x90
+	[<ffffffc0005da6cc>] nf_hook_slow+0x48/0xc8
+	[<ffffffc000688784>] br_handle_frame+0x348/0x37c
+	[<ffffffc0005a32a4>] __netif_receive_skb_core+0x478/0x8bc
+	[<ffffffc0005a3e54>] __netif_receive_skb+0x38/0x84
+	[<ffffffc0005a3f04>] netif_receive_skb_internal+0x64/0xb0
+	[<ffffffc0005a48f4>] napi_gro_receive+0xcc/0x178
+	[<ffffffbffc6443f8>] nss_dp_receive+0x78/0x98 [qca_nss_dp]
+	[<ffffffbffc6fce38>] nss_core_send_buffer+0x2294/0x25ac [qca_nss_drv]
+	[<ffffffbffc6fd180>] nss_core_handle_napi_queue+0x30/0x64 [qca_nss_drv]
+	[<ffffffc0005a4edc>] net_rx_action+0x10c/0x334
+	[<ffffffc00009ecc8>] __do_softirq+0x1c8/0x3bc
+	[<ffffffc00009f188>] irq_exit+0x8c/0xe4
+	[<ffffffc0000dea4c>] __handle_domain_irq+0x98/0xbc
+
+Change-Id: I1fa55ca59edf72b1d170e1757275d7dc86d27d6a
+Signed-off-by: Ken Zhu <guigenz@codeaurora.org>
+---
+ net/ipv6/netfilter/nf_reject_ipv6.c | 17 ++++++++++++-----
+ 1 file changed, 12 insertions(+), 5 deletions(-)
+
+--- a/net/ipv6/netfilter/nf_reject_ipv6.c
++++ b/net/ipv6/netfilter/nf_reject_ipv6.c
+@@ -300,7 +300,15 @@ void nf_send_reset6(struct net *net, str
+ 		skb_dst_set(oldskb, dst);
+ 	}
+ 
+-	fl6.flowi6_oif = l3mdev_master_ifindex(skb_dst(oldskb)->dev);
++	/* For forwarding packet, the skb->skb_iif is the incoming device's
++	 * ifindex, but it is 0 for local out skb, use dst->dev's ifindex
++	 * instead.
++	 */
++	if (oldskb->skb_iif != 0)
++		fl6.flowi6_oif = oldskb->skb_iif;
++	else
++		fl6.flowi6_oif = l3mdev_master_ifindex(skb_dst(oldskb)->dev);
++
+ 	fl6.flowi6_mark = IP6_REPLY_MARK(net, oldskb->mark);
+ 	security_skb_classify_flow(oldskb, flowi6_to_flowi_common(&fl6));
+ 	dst = ip6_route_output(net, NULL, &fl6);
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960199-net-bridge-Added-bridge-fdb-update-notify-chain.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,105 @@
+From 3d811fe6ee3a874861faadb64e44650ed466a808 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <quic_msezgin@quicinc.com>
+Date: Thu, 18 May 2023 21:11:09 -0700
+Subject: [PATCH 213/500] net: bridge: Added bridge fdb update notify chain
+
+Registered modules are notified based on two events:
+1. Dst port changes for any existing bridge fdb entry
+2. Bridge fdb entry ages out/deleted
+
+Change-Id: Iaba8fba6859bcc8e638df4f2e9900c131b1a6d34
+Signed-off-by: ratheesh kannoth <rkannoth@codeaurora.org>
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+
+net: bridge : delete fdb entry before callbacks
+
+Ageing timer expires and deletes corresponding fdb entry. Registered
+callbacks for br_fdb_update_notifier chains are called one by one.
+Since callback invocation is before the deletion of fdb entry,
+it may lead to race condition. Fix is to reorder it.
+
+Change-Id: Idefce6d879bfa6104cadc495aa61d164db214c97
+Signed-off-by: ratheesh kannoth <rkannoth@codeaurora.org>
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+Signed-off-by: Murat Sezgin <quic_msezgin@quicinc.com>
+---
+ include/linux/if_bridge.h |  2 ++
+ net/bridge/br_fdb.c       | 28 ++++++++++++++++++++++++++--
+ 2 files changed, 28 insertions(+), 2 deletions(-)
+
+--- a/include/linux/if_bridge.h
++++ b/include/linux/if_bridge.h
+@@ -79,6 +79,8 @@ extern void br_dev_update_stats(struct n
+ extern struct net_bridge_fdb_entry *br_fdb_has_entry(struct net_device *dev,
+ 						     const char *addr,
+ 						     __u16 vid);
++extern void br_fdb_update_register_notify(struct notifier_block *nb);
++extern void br_fdb_update_unregister_notify(struct notifier_block *nb);
+ 
+ #if IS_ENABLED(CONFIG_BRIDGE) && IS_ENABLED(CONFIG_BRIDGE_IGMP_SNOOPING)
+ int br_multicast_list_adjacent(struct net_device *dev,
+--- a/net/bridge/br_fdb.c
++++ b/net/bridge/br_fdb.c
+@@ -519,6 +519,20 @@ out:
+ 	spin_unlock_bh(&br->hash_lock);
+ }
+ 
++ATOMIC_NOTIFIER_HEAD(br_fdb_update_notifier_list);
++
++void br_fdb_update_register_notify(struct notifier_block *nb)
++{
++	atomic_notifier_chain_register(&br_fdb_update_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(br_fdb_update_register_notify);
++
++void br_fdb_update_unregister_notify(struct notifier_block *nb)
++{
++	atomic_notifier_chain_unregister(&br_fdb_update_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(br_fdb_update_unregister_notify);
++
+ void br_fdb_cleanup(struct work_struct *work)
+ {
+ 	struct net_bridge *br = container_of(work, struct net_bridge,
+@@ -527,6 +541,7 @@ void br_fdb_cleanup(struct work_struct *
+ 	unsigned long delay = hold_time(br);
+ 	unsigned long work_delay = delay;
+ 	unsigned long now = jiffies;
++	u8 mac_addr[6];
+ 
+ 	/* this part is tricky, in order to avoid blocking learning and
+ 	 * consequently forwarding, we rely on rcu to delete objects with
+@@ -553,8 +568,12 @@ void br_fdb_cleanup(struct work_struct *
+ 			work_delay = min(work_delay, this_timer - now);
+ 		} else {
+ 			spin_lock_bh(&br->hash_lock);
+-			if (!hlist_unhashed(&f->fdb_node))
+-				fdb_delete(br, f, true);
++			if (!hlist_unhashed(&f->fdb_node)) {
++			    ether_addr_copy(mac_addr, f->key.addr.addr);
++			    fdb_delete(br, f, true);
++			    atomic_notifier_call_chain(&br_fdb_update_notifier_list, 0,
++						       (void *)mac_addr);
++			}
+ 			spin_unlock_bh(&br->hash_lock);
+ 		}
+ 	}
+@@ -881,6 +900,7 @@ void br_fdb_update(struct net_bridge *br
+ 				br_switchdev_fdb_notify(br, fdb, RTM_DELNEIGH);
+ 				WRITE_ONCE(fdb->dst, source);
+ 				fdb_modified = true;
++
+ 				/* Take over HW learned entry */
+ 				if (unlikely(test_bit(BR_FDB_ADDED_BY_EXT_LEARN,
+ 						      &fdb->flags)))
+@@ -891,6 +911,10 @@ void br_fdb_update(struct net_bridge *br
+ 				 */
+ 				if (unlikely(test_bit(BR_FDB_LOCKED, &fdb->flags)))
+ 					clear_bit(BR_FDB_LOCKED, &fdb->flags);
++
++				atomic_notifier_call_chain(
++					&br_fdb_update_notifier_list,
++					0, (void *)addr);
+ 			}
+ 
+ 			if (unlikely(test_bit(BR_FDB_ADDED_BY_USER, &flags)))
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960200-Updated-the-br_port_dev_get-function-to-take-an-skb.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,112 @@
+From c1cf7f080f65c7da040280ce72edf3aec80d6e5f Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Wed, 11 Mar 2020 11:20:40 -0700
+Subject: [PATCH 214/500] Updated the br_port_dev_get function to take an skb
+
+- If the skb is non-NULL, call the br_port_dev_get_hook (if it exists),
+  to try and fetch the port.
+- If there is no skb or no hook, or the hook returns NULL, lookup in FDB
+
+Change-Id: I60df83dfa7a07b39cd30833cba0d4397859711f4
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ include/linux/if_bridge.h |  9 ++++++++-
+ net/bridge/br_if.c        | 38 ++++++++++++++++++++++++++++++++++----
+ 2 files changed, 42 insertions(+), 5 deletions(-)
+
+--- a/include/linux/if_bridge.h
++++ b/include/linux/if_bridge.h
+@@ -72,7 +72,8 @@ void brioctl_set(int (*hook)(struct net
+ int br_ioctl_call(struct net *net, struct net_bridge *br, unsigned int cmd,
+ 		  struct ifreq *ifr, void __user *uarg);
+ extern struct net_device *br_port_dev_get(struct net_device *dev,
+-					  unsigned char *addr);
++					  unsigned char *addr,
++					  struct sk_buff *skb);
+ extern void br_refresh_fdb_entry(struct net_device *dev, const char *addr);
+ extern void br_dev_update_stats(struct net_device *dev,
+ 				struct rtnl_link_stats64 *nlstats);
+@@ -223,4 +224,10 @@ static inline clock_t br_get_ageing_time
+ }
+ #endif
+ 
++typedef struct net_bridge_port *br_port_dev_get_hook_t(struct net_device *dev,
++		struct sk_buff *skb);
++extern br_port_dev_get_hook_t __rcu *br_port_dev_get_hook;
++
++typedef void (br_notify_hook_t)(int group, int event, const void *ptr);
++extern br_notify_hook_t __rcu *br_notify_hook;
+ #endif
+--- a/net/bridge/br_if.c
++++ b/net/bridge/br_if.c
+@@ -26,6 +26,10 @@
+ 
+ #include "br_private.h"
+ 
++/* Hook for external forwarding logic */
++br_port_dev_get_hook_t __rcu *br_port_dev_get_hook __read_mostly;
++EXPORT_SYMBOL_GPL(br_port_dev_get_hook);
++
+ /*
+  * Determine initial path cost based on speed.
+  * using recommendations from 802.1d standard
+@@ -780,13 +784,17 @@ bool br_port_flag_is_set(const struct ne
+ EXPORT_SYMBOL_GPL(br_port_flag_is_set);
+ 
+ /* br_port_dev_get()
+- *      Using the given addr, identify the port to which it is reachable,
+- *      returing a reference to the net device associated with that port.
++ *      If a skb is provided, and the br_port_dev_get_hook_t hook exists,
++ *      use that to try and determine the egress port for that skb.
++ *      If not, or no egress port could be determined, use the given addr
++ *      to identify the port to which it is reachable,
++ *	returing a reference to the net device associated with that port.
+  *
+  * NOTE: Return NULL if given dev is not a bridge or the mac has no
+  * associated port.
+  */
+-struct net_device *br_port_dev_get(struct net_device *dev, unsigned char *addr)
++struct net_device *br_port_dev_get(struct net_device *dev, unsigned char *addr,
++				   struct sk_buff *skb)
+ {
+ 	struct net_bridge_fdb_entry *fdbe;
+ 	struct net_bridge *br;
+@@ -796,15 +804,37 @@ struct net_device *br_port_dev_get(struc
+ 	if (!(dev->priv_flags & IFF_EBRIDGE))
+ 		return NULL;
+ 
++	rcu_read_lock();
++
++	/* If the hook exists and the skb isn't NULL, try and get the port */
++	if (skb) {
++		br_port_dev_get_hook_t *port_dev_get_hook;
++
++		port_dev_get_hook = rcu_dereference(br_port_dev_get_hook);
++		if (port_dev_get_hook) {
++			struct net_bridge_port *pdst =
++				__br_get(port_dev_get_hook, NULL, dev, skb);
++			if (pdst) {
++				dev_hold(pdst->dev);
++				netdev = pdst->dev;
++				goto out;
++			}
++		}
++	}
++
++	/* Either there is no hook, or can't
++	 * determine the port to use - fall back to using FDB
++	 */
++
+ 	br = netdev_priv(dev);
+ 
+ 	/* Lookup the fdb entry and get reference to the port dev */
+-	rcu_read_lock();
+ 	fdbe = br_fdb_find_rcu(br, addr, 0);
+ 	if (fdbe && fdbe->dst) {
+ 		netdev = fdbe->dst->dev; /* port device */
+ 		dev_hold(netdev);
+ 	}
++out:
+ 	rcu_read_unlock();
+ 	return netdev;
+ }
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960201-linux-bridge-add-patch-for-IGMP-MLD-snooping.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,135 @@
+From 6cba133cfc3cf66fcff35b7579336f7027b8b9af Mon Sep 17 00:00:00 2001
+From: Zhi Chen <zhichen@codeaurora.org>
+Date: Mon, 13 Apr 2015 16:39:06 -0700
+Subject: [PATCH 215/500] linux: bridge: add patch for IGMP/MLD snooping
+
+Kernel patch for the IGMP/MLD snooping module, which is a replacement
+and enhancement of Linux bridge multicast snooping. With the IGMP/MLD
+snooping module, we can support IGMPv3/MLDv2 on Linux bridge.
+Furthermore, with additional plugins, we can support switch port-based
+snooping and WiFi conversion from multicast to unicast.
+This patch exported a couple of bridge APIs and added two packet hooks
+on the input/output path.
+
+Change-Id: I3507f2b793155856b4dac8ad5937a9fc6d28551d
+Signed-off-by: Zhi Chen <zhichen@codeaurora.org>
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ include/linux/if_bridge.h |  6 ++++++
+ net/bridge/br_device.c    |  5 +++++
+ net/bridge/br_input.c     | 12 +++++++++++-
+ net/bridge/br_private.h   |  5 +++++
+ 4 files changed, 27 insertions(+), 1 deletion(-)
+
+diff --git a/include/linux/if_bridge.h b/include/linux/if_bridge.h
+index a29cbc16d08c..f352ec4191cb 100644
+--- a/include/linux/if_bridge.h
++++ b/include/linux/if_bridge.h
+@@ -66,11 +66,13 @@ struct br_ip_list {
+ #define BR_DEFAULT_AGEING_TIME	(300 * HZ)
+ 
+ struct net_bridge;
++struct net_bridge_port;
+ void brioctl_set(int (*hook)(struct net *net, struct net_bridge *br,
+ 			     unsigned int cmd, struct ifreq *ifr,
+ 			     void __user *uarg));
+ int br_ioctl_call(struct net *net, struct net_bridge *br, unsigned int cmd,
+ 		  struct ifreq *ifr, void __user *uarg);
++
+ extern struct net_device *br_port_dev_get(struct net_device *dev,
+ 					  unsigned char *addr,
+ 					  struct sk_buff *skb);
+@@ -230,4 +232,8 @@ extern br_port_dev_get_hook_t __rcu *br_port_dev_get_hook;
+ 
+ typedef void (br_notify_hook_t)(int group, int event, const void *ptr);
+ extern br_notify_hook_t __rcu *br_notify_hook;
++typedef int (br_multicast_handle_hook_t)(const struct net_bridge_port *src,
++		struct sk_buff *skb);
++extern br_multicast_handle_hook_t __rcu *br_multicast_handle_hook;
++
+ #endif
+diff --git a/net/bridge/br_device.c b/net/bridge/br_device.c
+index 9a5ea06236bd..4262a2ae0220 100644
+--- a/net/bridge/br_device.c
++++ b/net/bridge/br_device.c
+@@ -83,6 +83,11 @@ netdev_tx_t br_dev_xmit(struct sk_buff *skb, struct net_device *dev)
+ 	if (is_broadcast_ether_addr(dest)) {
+ 		br_flood(br, skb, BR_PKT_BROADCAST, false, true, vid);
+ 	} else if (is_multicast_ether_addr(dest)) {
++		br_multicast_handle_hook_t *multicast_handle_hook =
++			rcu_dereference(br_multicast_handle_hook);
++		if (!__br_get(multicast_handle_hook, true, NULL, skb))
++			goto out;
++
+ 		if (unlikely(netpoll_tx_running(dev))) {
+ 			br_flood(br, skb, BR_PKT_MULTICAST, false, true, vid);
+ 			goto out;
+diff --git a/net/bridge/br_input.c b/net/bridge/br_input.c
+index 2ff896f6cf39..348a6092a291 100644
+--- a/net/bridge/br_input.c
++++ b/net/bridge/br_input.c
+@@ -30,7 +30,11 @@ br_netif_receive_skb(struct net *net, struct sock *sk, struct sk_buff *skb)
+ 	return netif_receive_skb(skb);
+ }
+ 
+-static int br_pass_frame_up(struct sk_buff *skb, bool promisc)
++/* Hook for external Multicast handler */
++br_multicast_handle_hook_t __rcu *br_multicast_handle_hook __read_mostly;
++EXPORT_SYMBOL_GPL(br_multicast_handle_hook);
++
++int br_pass_frame_up(struct sk_buff *skb)
+ {
+ 	struct net_device *indev, *brdev = BR_INPUT_SKB_CB(skb)->brdev;
+ 	struct net_bridge *br = netdev_priv(brdev);
+@@ -71,6 +75,7 @@ static int br_pass_frame_up(struct sk_buff *skb)
+ 		       dev_net(indev), NULL, skb, indev, NULL,
+ 		       br_netif_receive_skb);
+ }
++EXPORT_SYMBOL_GPL(br_pass_frame_up);
+ 
+ /* note: already called with rcu_read_lock */
+ int br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
+@@ -84,7 +89,7 @@ int br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb
+ 	struct net_bridge_mcast *brmctx;
+ 	struct net_bridge_vlan *vlan;
+ 	struct net_bridge *br;
+-	bool promisc;
++	br_multicast_handle_hook_t *multicast_handle_hook;
+ 	u16 vid = 0;
+ 	u8 state;
+ 
+@@ -180,6 +185,10 @@ int br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb
+ 
+ 	switch (pkt_type) {
+ 	case BR_PKT_MULTICAST:
++		multicast_handle_hook = rcu_dereference(br_multicast_handle_hook);
++		if (!__br_get(multicast_handle_hook, true, p, skb))
++			goto out;
++
+ 		mdst = br_mdb_get(brmctx, skb, vid);
+ 		if ((mdst || BR_INPUT_SKB_CB_MROUTERS_ONLY(skb)) &&
+ 		    br_multicast_querier_exists(brmctx, eth_hdr(skb), mdst)) {
+diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
+index 6e1f4cfc64b0..a760f6ab4c56 100644
+--- a/net/bridge/br_private.h
++++ b/net/bridge/br_private.h
+@@ -907,6 +907,7 @@ void br_manage_promisc(struct net_bridge *br);
+ int nbp_backup_change(struct net_bridge_port *p, struct net_device *backup_dev);
+ 
+ /* br_input.c */
++int br_pass_frame_up(struct sk_buff *skb);
+ int br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb);
+ rx_handler_func_t *br_get_rx_handler(const struct net_device *dev);
+ 
+@@ -2280,4 +2281,8 @@ void br_do_suppress_nd(struct sk_buff *skb, struct net_bridge *br,
+ 		       u16 vid, struct net_bridge_port *p, struct nd_msg *msg);
+ struct nd_msg *br_is_nd_neigh_msg(struct sk_buff *skb, struct nd_msg *m);
+ bool br_is_neigh_suppress_enabled(const struct net_bridge_port *p, u16 vid);
++
++#define __br_get(__hook, __default, __args ...) \
++		(__hook ? (__hook(__args)) : (__default))
++
+ #endif
+-- 
+2.34.1
+
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960202-bridge-add-fdb-events-in-linux-bridge.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,82 @@
+From 05f608faa62c7f5ecd930908d3fdfbc24d92050b Mon Sep 17 00:00:00 2001
+From: Zhi Chen <zhichen@codeaurora.org>
+Date: Thu, 27 Aug 2015 16:37:09 -0700
+Subject: [PATCH 216/500] bridge: add fdb events in linux bridge
+
+Notify fdb changing events to those modules which are interested in
+hosts joining/leaving or bridge port changing. This is required by
+RFS feature.
+
+Change-Id: I7b592ba09109e1785a5834b56987a19bc35886fe
+Signed-off-by: Zhi Chen <zhichen@codeaurora.org>
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ include/linux/if_bridge.h | 11 +++++++++++
+ net/bridge/br_fdb.c       | 31 +++++++++++++++++++++++++++++++
+ 2 files changed, 42 insertions(+)
+
+--- a/include/linux/if_bridge.h
++++ b/include/linux/if_bridge.h
+@@ -236,4 +236,15 @@ typedef int (br_multicast_handle_hook_t)
+ 		struct sk_buff *skb);
+ extern br_multicast_handle_hook_t __rcu *br_multicast_handle_hook;
+ 
++#define BR_FDB_EVENT_ADD     0x01
++#define BR_FDB_EVENT_DEL     0x02
++
++struct br_fdb_event {
++	struct net_device *dev;
++	unsigned char      addr[6];
++	unsigned char      is_local;
++};
++
++extern void br_fdb_register_notify(struct notifier_block *nb);
++extern void br_fdb_unregister_notify(struct notifier_block *nb);
+ #endif
+--- a/net/bridge/br_fdb.c
++++ b/net/bridge/br_fdb.c
+@@ -33,6 +33,20 @@ static const struct rhashtable_params br
+ 
+ static struct kmem_cache *br_fdb_cache __read_mostly;
+ 
++ATOMIC_NOTIFIER_HEAD(br_fdb_notifier_list);
++
++void br_fdb_register_notify(struct notifier_block *nb)
++{
++	atomic_notifier_chain_register(&br_fdb_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(br_fdb_register_notify);
++
++void br_fdb_unregister_notify(struct notifier_block *nb)
++{
++	atomic_notifier_chain_unregister(&br_fdb_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(br_fdb_unregister_notify);
++
+ int __init br_fdb_init(void)
+ {
+ 	br_fdb_cache = kmem_cache_create("bridge_fdb_cache",
+@@ -195,6 +209,23 @@ static void fdb_notify(struct net_bridge
+ 	if (swdev_notify)
+ 		br_switchdev_fdb_notify(br, fdb, type);
+ 
++	if (fdb->dst) {
++		int event;
++		struct br_fdb_event fdb_event;
++
++		if (type == RTM_NEWNEIGH)
++			event = BR_FDB_EVENT_ADD;
++		else
++			event = BR_FDB_EVENT_DEL;
++
++		fdb_event.dev = fdb->dst->dev;
++		ether_addr_copy(fdb_event.addr, fdb->key.addr.addr);
++		fdb_event.is_local = test_bit(BR_FDB_LOCAL, &fdb->flags);
++		atomic_notifier_call_chain(&br_fdb_notifier_list,
++					   event,
++					   (void *)&fdb_event);
++	}
++
+ 	skb = nlmsg_new(fdb_nlmsg_size(), GFP_ATOMIC);
+ 	if (skb == NULL)
+ 		goto errout;
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960203-net-Add-netdevice-notification-for-bridge-activity.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,79 @@
+From a05aa24a03675158abf450788bb29bedfdf74b34 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Wed, 11 Mar 2020 12:44:01 -0700
+Subject: [PATCH 217/500] net: Add netdevice notification for bridge activity
+
+This modification allows programs to get notified whenever a
+device is added to or removed from a bridge. This will be used
+by NSS Qdisc for updating bridge shaper configuration.
+
+Change-Id: I97aa6951c98ba83cd0d176cd60a9e9fd910f7ad4
+Signed-off-by: Shashank Balashankar <sbalasha@codeaurora.org>
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ include/linux/netdevice.h | 2 ++
+ net/bridge/br_if.c        | 3 +++
+ net/core/dev.c            | 1 +
+ 3 files changed, 6 insertions(+)
+
+diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
+index ee1fbe676dba..dc8a96008259 100644
+--- a/include/linux/netdevice.h
++++ b/include/linux/netdevice.h
+@@ -2888,6 +2888,8 @@ enum netdev_cmd {
+ 	NETDEV_OFFLOAD_XSTATS_REPORT_USED,
+ 	NETDEV_OFFLOAD_XSTATS_REPORT_DELTA,
+ 	NETDEV_XDP_FEAT_CHANGE,
++	NETDEV_BR_JOIN,
++	NETDEV_BR_LEAVE,
+ };
+ const char *netdev_cmd_to_name(enum netdev_cmd cmd);
+ 
+diff --git a/net/bridge/br_if.c b/net/bridge/br_if.c
+index 001c291ed539..6e82384ff737 100644
+--- a/net/bridge/br_if.c
++++ b/net/bridge/br_if.c
+@@ -700,6 +700,7 @@ int br_add_if(struct net_bridge *br, struct net_device *dev,
+ 	br_set_gso_limits(br);
+ 
+ 	kobject_uevent(&p->kobj, KOBJ_ADD);
++	call_netdevice_notifiers(NETDEV_BR_JOIN, dev);
+ 
+ 	return 0;
+ 
+@@ -736,6 +737,8 @@ int br_del_if(struct net_bridge *br, struct net_device *dev)
+ 	if (!p || p->br != br)
+ 		return -EINVAL;
+ 
++	call_netdevice_notifiers(NETDEV_BR_LEAVE, dev);
++
+ 	/* Since more than one interface can be attached to a bridge,
+ 	 * there still maybe an alternate path for netconsole to use;
+ 	 * therefore there is no reason for a NETDEV_RELEASE event.
+diff --git a/net/core/dev.c b/net/core/dev.c
+index faa5c5b5c330..b14c30b72f6b 100644
+--- a/net/core/dev.c
++++ b/net/core/dev.c
+@@ -1673,6 +1673,7 @@ const char *netdev_cmd_to_name(enum netdev_cmd cmd)
+ 	N(PRE_CHANGEADDR) N(OFFLOAD_XSTATS_ENABLE) N(OFFLOAD_XSTATS_DISABLE)
+ 	N(OFFLOAD_XSTATS_REPORT_USED) N(OFFLOAD_XSTATS_REPORT_DELTA)
+ 	N(XDP_FEAT_CHANGE)
++	N(BR_JOIN) N(BR_LEAVE)
+ 	}
+ #undef N
+ 	return "UNKNOWN_NETDEV_EVENT";
+-- 
+2.34.1
+--- a/net/bridge/br_if.c
++++ b/net/bridge/br_if.c
+@@ -739,6 +739,8 @@ int br_del_if(struct net_bridge *br, str
+ 
+ 	call_netdevice_notifiers(NETDEV_BR_LEAVE, dev);
+ 
++	call_netdevice_notifiers(NETDEV_BR_LEAVE, dev);
++
+ 	/* Since more than one interface can be attached to a bridge,
+ 	 * there still maybe an alternate path for netconsole to use;
+ 	 * therefore there is no reason for a NETDEV_RELEASE event.
+ 
+
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960204-bridge-Port-Hy-Fi-bridging-hooks.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,233 @@
+From e9c45fea02f4636bda0b5175029802c2f15652ff Mon Sep 17 00:00:00 2001
+From: Amitesh Anand <quic_amitesh@quicinc.com>
+Date: Thu, 18 May 2023 21:11:39 -0700
+Subject: [PATCH 218/500] bridge: Port Hy-Fi bridging hooks
+
+Introduce two new netfilter hooks. The first allows the Hy-Fi bridging
+logic to indicate a different egress port (thereby overriding the FDB).
+The other is used for FDB update notifications and port changes.
+
+Change-Id: I21549968c56e6b60d7d08e19ec4a297b937264bf
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+
+Pass MAC address to Hy-Fi bridge
+
+- This may be a skb on the forward or reverse direction of the
+  connection
+- Need to pass the dest address as well as the skb to determine if we
+  need to calculate the forward or reverse hash
+
+Change-Id: I245855910ac91f73a9e9e6bd3403f01bc662a93a
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+
+Pass serial number to Linux bridge port lookup
+
+- This allows the same ECM lookup function to be used in interface
+  hierarchy generation and when updating stats (so no difference in
+  lookup even if the priority field changes)
+- If the priority field changes, will update the H-Active entry and
+  generate a debug log
+
+Change-Id: I392bbc82fab30c345b14e7927b6b0fa119d19a57
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+Signed-off-by: Murat Sezgin <quic_msezgin@quicinc.com>
+Signed-off-by: Amitesh Anand <quic_amitesh@quicinc.com>
+---
+ include/linux/if_bridge.h | 15 +++++++++++++--
+ net/bridge/br.c           |  4 ++++
+ net/bridge/br_fdb.c       |  2 ++
+ net/bridge/br_if.c        |  6 ++++--
+ net/bridge/br_input.c     | 20 +++++++++++++++++++-
+ net/bridge/br_netlink.c   |  2 ++
+ net/bridge/br_private.h   |  9 +++++++++
+ 7 files changed, 53 insertions(+), 5 deletions(-)
+
+diff --git a/include/linux/if_bridge.h b/include/linux/if_bridge.h
+index caa532e8290f..df9c7f7700c3 100644
+--- a/include/linux/if_bridge.h
++++ b/include/linux/if_bridge.h
+@@ -75,7 +75,8 @@ int br_ioctl_call(struct net *net, struct net_bridge *br, unsigned int cmd,
+ 
+ extern struct net_device *br_port_dev_get(struct net_device *dev,
+ 					  unsigned char *addr,
+-					  struct sk_buff *skb);
++					  struct sk_buff *skb,
++					  unsigned int cookie);
+ extern void br_refresh_fdb_entry(struct net_device *dev, const char *addr);
+ extern void br_dev_update_stats(struct net_device *dev,
+ 				struct rtnl_link_stats64 *nlstats);
+@@ -227,7 +228,9 @@ static inline clock_t br_get_ageing_time(const struct net_device *br_dev)
+ #endif
+ 
+ typedef struct net_bridge_port *br_port_dev_get_hook_t(struct net_device *dev,
+-		struct sk_buff *skb);
++						       struct sk_buff *skb,
++						       unsigned char *addr,
++						       unsigned int cookie);
+ extern br_port_dev_get_hook_t __rcu *br_port_dev_get_hook;
+ 
+ typedef void (br_notify_hook_t)(int group, int event, const void *ptr);
+@@ -247,4 +250,12 @@ struct br_fdb_event {
+ 
+ extern void br_fdb_register_notify(struct notifier_block *nb);
+ extern void br_fdb_unregister_notify(struct notifier_block *nb);
++
++typedef struct net_bridge_port *br_get_dst_hook_t(
++		const struct net_bridge_port *src,
++		struct sk_buff **skb);
++extern br_get_dst_hook_t __rcu *br_get_dst_hook;
++
++typedef void (br_notify_hook_t)(int group, int event, const void *ptr);
++extern br_notify_hook_t __rcu *br_notify_hook;
+ #endif
+diff --git a/net/bridge/br.c b/net/bridge/br.c
+index a6e94ceb7c9a..0120a36aafcf 100644
+--- a/net/bridge/br.c
++++ b/net/bridge/br.c
+@@ -472,6 +472,10 @@ static void __exit br_deinit(void)
+ 	br_fdb_fini();
+ }
+ 
++/* Hook for bridge event notifications */
++br_notify_hook_t __rcu *br_notify_hook __read_mostly;
++EXPORT_SYMBOL_GPL(br_notify_hook);
++
+ module_init(br_init)
+ module_exit(br_deinit)
+ MODULE_LICENSE("GPL");
+diff --git a/net/bridge/br_fdb.c b/net/bridge/br_fdb.c
+index 8c2fb401c545..fc3e7010d088 100644
+--- a/net/bridge/br_fdb.c
++++ b/net/bridge/br_fdb.c
+@@ -237,6 +237,8 @@ static void fdb_notify(struct net_bridge *br,
+ 		kfree_skb(skb);
+ 		goto errout;
+ 	}
++
++	__br_notify(RTNLGRP_NEIGH, type, fdb);
+ 	rtnl_notify(skb, net, 0, RTNLGRP_NEIGH, NULL, GFP_ATOMIC);
+ 	return;
+ errout:
+diff --git a/net/bridge/br_if.c b/net/bridge/br_if.c
+index 6e82384ff737..502b04712e91 100644
+--- a/net/bridge/br_if.c
++++ b/net/bridge/br_if.c
+@@ -794,7 +794,8 @@ EXPORT_SYMBOL_GPL(br_port_flag_is_set);
+  * associated port.
+  */
+ struct net_device *br_port_dev_get(struct net_device *dev, unsigned char *addr,
+-				   struct sk_buff *skb)
++				   struct sk_buff *skb,
++				   unsigned int cookie)
+ {
+ 	struct net_bridge_fdb_entry *fdbe;
+ 	struct net_bridge *br;
+@@ -813,7 +814,8 @@ struct net_device *br_port_dev_get(struct net_device *dev, unsigned char *addr,
+ 		port_dev_get_hook = rcu_dereference(br_port_dev_get_hook);
+ 		if (port_dev_get_hook) {
+ 			struct net_bridge_port *pdst =
+-				__br_get(port_dev_get_hook, NULL, dev, skb);
++				__br_get(port_dev_get_hook, NULL, dev, skb,
++					 addr, cookie);
+ 			if (pdst) {
+ 				dev_hold(pdst->dev);
+ 				netdev = pdst->dev;
+diff --git a/net/bridge/br_input.c b/net/bridge/br_input.c
+index 348a6092a291..9a5339060056 100644
+--- a/net/bridge/br_input.c
++++ b/net/bridge/br_input.c
+@@ -34,6 +34,10 @@ br_netif_receive_skb(struct net *net, struct sock *sk, struct sk_buff *skb)
+ br_multicast_handle_hook_t __rcu *br_multicast_handle_hook __read_mostly;
+ EXPORT_SYMBOL_GPL(br_multicast_handle_hook);
+ 
++/* Hook for external forwarding logic */
++br_get_dst_hook_t __rcu *br_get_dst_hook __read_mostly;
++EXPORT_SYMBOL_GPL(br_get_dst_hook);
++
+ int br_pass_frame_up(struct sk_buff *skb)
+ {
+ 	struct net_device *indev, *brdev = BR_INPUT_SKB_CB(skb)->brdev;
+@@ -88,6 +92,8 @@ int br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb
+ 	struct net_bridge_vlan *vlan;
+ 	struct net_bridge *br;
+ 	br_multicast_handle_hook_t *multicast_handle_hook;
++	struct net_bridge_port *pdst = NULL;
++	br_get_dst_hook_t *get_dst_hook = rcu_dereference(br_get_dst_hook);
+ 	u16 vid = 0;
+ 	u8 state;
+ 
+@@ -200,7 +206,13 @@ int br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb
+ 		}
+ 		break;
+ 	case BR_PKT_UNICAST:
+-		dst = br_fdb_find_rcu(br, eth_hdr(skb)->h_dest, vid);
++		pdst = __br_get(get_dst_hook, NULL, p, &skb);
++		if (pdst) {
++			if (!skb)
++				goto out;
++		} else {
++			dst = br_fdb_find_rcu(br, eth_hdr(skb)->h_dest, vid);
++		}
+ 		break;
+ 	default:
+ 		break;
+@@ -216,12 +228,18 @@ int br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb
+ 			dst->used = now;
+ 		br_forward(dst->dst, skb, local_rcv, false);
+ 	} else {
++		if (pdst) {
++			br_forward(pdst, skb, local_rcv, false);
++			goto out1;
++		}
++
+ 		if (!mcast_hit)
+ 			br_flood(br, skb, pkt_type, local_rcv, false, vid);
+ 		else
+ 			br_multicast_flood(mdst, skb, brmctx, local_rcv, false);
+ 	}
+ 
++out1:
+ 	if (local_rcv)
+ 		return br_pass_frame_up(skb);
+ 
+diff --git a/net/bridge/br_netlink.c b/net/bridge/br_netlink.c
+index 8b2a1cdde9d5..36ea6c9be045 100644
+--- a/net/bridge/br_netlink.c
++++ b/net/bridge/br_netlink.c
+@@ -656,6 +656,8 @@ void br_info_notify(int event, const struct net_bridge *br,
+ 		kfree_skb(skb);
+ 		goto errout;
+ 	}
++
++	__br_notify(RTNLGRP_LINK, event, port);
+ 	rtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, GFP_ATOMIC);
+ 	return;
+ errout:
+diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
+index a760f6ab4c56..19e08c13d111 100644
+--- a/net/bridge/br_private.h
++++ b/net/bridge/br_private.h
+@@ -20,6 +20,7 @@
+ #include <linux/rhashtable.h>
+ #include <linux/refcount.h>
+ #include <linux/netfilter.h>
++#include <linux/export.h>
+ 
+ #define BR_HASH_BITS 8
+ #define BR_HASH_SIZE (1 << BR_HASH_BITS)
+@@ -2285,4 +2286,12 @@ bool br_is_neigh_suppress_enabled(const struct net_bridge_port *p, u16 vid);
+ #define __br_get(__hook, __default, __args ...) \
+ 		(__hook ? (__hook(__args)) : (__default))
+ 
++static inline void __br_notify(int group, int type, const void *data)
++{
++	br_notify_hook_t *notify_hook = rcu_dereference(br_notify_hook);
++
++	if (notify_hook)
++		notify_hook(group, type, data);
++}
++
+ #endif
+-- 
+2.34.1
+
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960205-bridge-Add-flag-to-force-netfilter-hook-evaluation.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,71 @@
+From e3247be9648ac47c6901ebba781ec641481363ec Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Fri, 2 Jun 2017 10:22:27 -0700
+Subject: [PATCH 219/500] bridge: Add flag to force netfilter hook evaluation
+
+Add a sysctl (similar to the ones for iptables/ip6tables) to allow user
+space to force evaluation of Netfilter hooks registered with the bridge.
+This allows custom module's hooks to be invoked without the
+iptables/ip6tables/arptables special processing being enabled.
+Without this, any such modules will never have their hooks invoked
+unless one of the other flags is set via sysctl.
+
+Change-Id: I2875c77525c96c8f69774ab41d5d77e240d88dbb
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ net/bridge/br_netfilter_hooks.c | 11 ++++++++++-
+ 1 file changed, 10 insertions(+), 1 deletion(-)
+
+diff --git a/net/bridge/br_netfilter_hooks.c b/net/bridge/br_netfilter_hooks.c
+index ff606944d82f..630f7c45277a 100644
+--- a/net/bridge/br_netfilter_hooks.c
++++ b/net/bridge/br_netfilter_hooks.c
+@@ -57,6 +57,7 @@ struct brnf_net {
+ 	int call_ip6tables;
+ 	int call_arptables;
+ 	int call_ebtables;
++	int call_custom;
+ 
+ 	/* default value is 0 */
+ 	int filter_vlan_tagged;
+@@ -78,7 +79,7 @@ bool br_netfilter_run_hooks(struct net *net)
+ 	struct brnf_net *brnf = net_generic(net, brnf_net_id);
+ 
+ 	return brnf->call_iptables | brnf->call_ip6tables | brnf->call_arptables |
+-		brnf->call_ebtables;
++		brnf->call_ebtables | brnf->call_custom;
+ }
+ 
+ static inline __be16 vlan_proto(const struct sk_buff *skb)
+@@ -1116,6 +1117,12 @@ static struct ctl_table brnf_table[] = {
+ 		.mode           = 0644,
+ 		.proc_handler   = brnf_sysctl_call_tables,
+ 	},
++	{
++		.procname	= "bridge-nf-call-custom",
++		.maxlen		= sizeof(int),
++		.mode		= 0644,
++		.proc_handler	= brnf_sysctl_call_tables,
++	},
+ 	{ }
+ };
+ 
+@@ -1125,6 +1132,7 @@ static inline void br_netfilter_sysctl_default(struct brnf_net *brnf)
+ 	brnf->call_ip6tables = 1;
+ 	brnf->call_arptables = 1;
+ 	brnf->call_ebtables = 1;
++	brnf->call_custom = 1;
+ 	brnf->filter_vlan_tagged = 0;
+ 	brnf->filter_pppoe_tagged = 0;
+ 	brnf->pass_vlan_indev = 0;
+@@ -1149,6 +1157,7 @@ static int br_netfilter_sysctl_init_net(struct net *net)
+ 	table[4].data = &brnet->filter_pppoe_tagged;
+ 	table[5].data = &brnet->pass_vlan_indev;
+ 	table[6].data = &brnet->call_ebtables;
++	table[7].data = &brnet->call_custom;
+ 
+ 	br_netfilter_sysctl_default(brnet);
+ 
+-- 
+2.34.1
+
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960206-net-bridge-don-t-loopback-multicast-when-hairpin-ena.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,39 @@
+From 9e0457cba1c3d3ccf31a60ebc3fcde18d546ded2 Mon Sep 17 00:00:00 2001
+From: Zhu Ken <guigenz@codeaurora.org>
+Date: Tue, 27 Oct 2015 13:40:51 -0700
+Subject: [PATCH 220/500] net: bridge: don't loopback multicast when hairpin
+ enabled
+
+some virtual service test cases need to enable bridge hairpin.
+But hairpin will break the DHCP procedure on lan side as follows :
+Because the first DHCP discovery packet is a broadcast packet, so this
+packet will be loopbacked to switch port 6 which was connected to bridge
+member eth1, this will result in a switch fdb entry whose out port is
+switch port 6. Then the DHCP ack packet from our board DHCP server will
+be dropped by switch because its destination mac hit above switch fdb.
+The out port given by the fdb equals to the income port of DHCP ack
+packet, so this packet was dropped by switch.
+
+Here forbade multicast to be loopbacked when hairpin enabled.
+
+resolved some confliction and changed the author to resolve the invalid
+email
+
+Change-Id: I4b5b4e71b8034588fc2c32b21a55dfe4cca32987
+Signed-off-by: Zhu Ken <guigenz@codeaurora.org>
+---
+ net/bridge/br_forward.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/net/bridge/br_forward.c
++++ b/net/bridge/br_forward.c
+@@ -24,7 +24,8 @@ static inline int should_deliver(const s
+ 	struct net_bridge_vlan_group *vg;
+ 
+ 	vg = nbp_vlan_group_rcu(p);
+-	return ((p->flags & BR_HAIRPIN_MODE) || skb->dev != p->dev) &&
++	return (((p->flags & BR_HAIRPIN_MODE) && !is_multicast_ether_addr(eth_hdr(skb)->h_dest)) 
++		|| skb->dev != p->dev) &&
+ 		(br_mst_is_enabled(p->br) || p->state == BR_STATE_FORWARDING) &&
+ 		br_allowed_egress(vg, skb) && nbp_switchdev_allowed_egress(p, skb) &&
+ 		!br_skb_isolated(p, skb);
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960207-Fixed-the-br_dev_xmit-function-to-call-Hy-Fi-hooks.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,63 @@
+From ba6be6488f6b3fcaed5f72f445cf04edfdeaa49d Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Tue, 9 Feb 2016 18:00:05 -0800
+Subject: [PATCH 221/500] Fixed the br_dev_xmit function to call Hy-Fi hooks
+
+- Previously this wasn't calling the Hy-Fi hooks (meaning that all
+  locally generated traffic was sent on a FDB selected port, and hence
+  in a Hy-Fi environment, could be spread across all backhauls)
+- Fixed to be the same as the banana kernel, and call the
+  br_get_dst_hook_t
+
+Change-Id: If5e964f385614beb5ebe9e1083ca947464165b9e
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+Signed-off-by: Mughilan Ramajayam <mughilan@codeaurora.org>
+---
+ net/bridge/br_device.c | 20 +++++++++++++++++---
+ 1 file changed, 17 insertions(+), 3 deletions(-)
+
+--- a/net/bridge/br_device.c
++++ b/net/bridge/br_device.c
+@@ -38,6 +38,8 @@ netdev_tx_t br_dev_xmit(struct sk_buff *
+ 	struct net_bridge_vlan *vlan;
+ 	const unsigned char *dest;
+ 	u16 vid = 0;
++	struct net_bridge_port *pdst;
++	br_get_dst_hook_t *get_dst_hook;
+ 
+ 	if (unlikely(reason != SKB_NOT_DROPPED_YET)) {
+ 		kfree_skb_reason(skb, reason);
+@@ -85,6 +87,8 @@ netdev_tx_t br_dev_xmit(struct sk_buff *
+ 				br_do_suppress_nd(skb, br, vid, NULL, msg);
+ 	}
+ 
++	get_dst_hook = rcu_dereference(br_get_dst_hook);
++
+ 	dest = eth_hdr(skb)->h_dest;
+ 	if (is_broadcast_ether_addr(dest)) {
+ 		br_flood(br, skb, BR_PKT_BROADCAST, false, true, vid);
+@@ -109,11 +113,21 @@ netdev_tx_t br_dev_xmit(struct sk_buff *
+ 			br_multicast_flood(mdst, skb, brmctx, false, true);
+ 		else
+ 			br_flood(br, skb, BR_PKT_MULTICAST, false, true, vid);
+-	} else if ((dst = br_fdb_find_rcu(br, dest, vid)) != NULL) {
+-		br_forward(dst->dst, skb, false, true);
+ 	} else {
+-		br_flood(br, skb, BR_PKT_UNICAST, false, true, vid);
++		pdst = __br_get(get_dst_hook, NULL, NULL, &skb);
++		if (pdst) {
++			if (!skb)
++				goto out;
++			br_forward(pdst, skb, false, true);
++		} else {
++			dst = br_fdb_find_rcu(br, dest, vid);
++			if (dst)
++				br_forward(dst->dst, skb, false, true);
++			else
++				br_flood(br, skb, BR_PKT_UNICAST, false, true, vid);
++		}
+ 	}
++
+ out:
+ 	rcu_read_unlock();
+ 	return NETDEV_TX_OK;
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960208-bridge-Extend-struct-br_fdb_event.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,101 @@
+From 44dd3e7f5c8a6adddce555e12c98c912a96e33c2 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Thu, 12 Mar 2020 17:25:42 -0700
+Subject: [PATCH 222/500] bridge: Extend struct br_fdb_event
+
+Send an FDB update event with device information
+
+Change-Id: I67df950c35af944543e31eef2f447494cea8bde1
+Signed-off-by: Casey Chen <kexinc@codeaurora.org>
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ include/linux/if_bridge.h |  7 +++++--
+ net/bridge/br_fdb.c       | 22 ++++++++++++++++++----
+ 2 files changed, 23 insertions(+), 6 deletions(-)
+
+--- a/include/linux/if_bridge.h
++++ b/include/linux/if_bridge.h
+@@ -243,13 +243,16 @@ extern br_multicast_handle_hook_t __rcu
+ #define BR_FDB_EVENT_DEL     0x02
+ 
+ struct br_fdb_event {
++	unsigned char addr[6];
++	unsigned char is_local;
+ 	struct net_device *dev;
+-	unsigned char      addr[6];
+-	unsigned char      is_local;
++	struct net_bridge *br;
++	struct net_device *orig_dev;
+ };
+ 
+ extern void br_fdb_register_notify(struct notifier_block *nb);
+ extern void br_fdb_unregister_notify(struct notifier_block *nb);
++extern struct net_device *br_fdb_bridge_dev_get_and_hold(struct net_bridge *br);
+ 
+ typedef struct net_bridge_port *br_get_dst_hook_t(
+ 		const struct net_bridge_port *src,
+--- a/net/bridge/br_fdb.c
++++ b/net/bridge/br_fdb.c
+@@ -574,7 +574,7 @@ void br_fdb_cleanup(struct work_struct *
+ 	unsigned long delay = hold_time(br);
+ 	unsigned long work_delay = delay;
+ 	unsigned long now = jiffies;
+-	u8 mac_addr[6];
++	struct br_fdb_event fdb_event;
+ 
+ 	/* this part is tricky, in order to avoid blocking learning and
+ 	 * consequently forwarding, we rely on rcu to delete objects with
+@@ -602,10 +602,11 @@ void br_fdb_cleanup(struct work_struct *
+ 		} else {
+ 			spin_lock_bh(&br->hash_lock);
+ 			if (!hlist_unhashed(&f->fdb_node)) {
+-			    ether_addr_copy(mac_addr, f->key.addr.addr);
++			    memset(&fdb_event, 0, sizeof(fdb_event));
++			    ether_addr_copy(fdb_event.addr, f->key.addr.addr);
+ 			    fdb_delete(br, f, true);
+ 			    atomic_notifier_call_chain(&br_fdb_update_notifier_list, 0,
+-						       (void *)mac_addr);
++						       (void *)&fdb_event);
+ 			}
+ 			spin_unlock_bh(&br->hash_lock);
+ 		}
+@@ -902,10 +903,19 @@ static bool __fdb_mark_active(struct net
+ 		  test_and_clear_bit(BR_FDB_NOTIFY_INACTIVE, &fdb->flags));
+ }
+ 
++/* Get the bridge device */
++struct net_device *br_fdb_bridge_dev_get_and_hold(struct net_bridge *br)
++{
++	dev_hold(br->dev);
++	return br->dev;
++}
++EXPORT_SYMBOL_GPL(br_fdb_bridge_dev_get_and_hold);
++
+ void br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,
+ 		   const unsigned char *addr, u16 vid, unsigned long flags)
+ {
+ 	struct net_bridge_fdb_entry *fdb;
++	struct br_fdb_event fdb_event;
+ 
+ 	/* some users want to always flood. */
+ 	if (hold_time(br) == 0)
+@@ -931,6 +941,10 @@ void br_fdb_update(struct net_bridge *br
+ 			if (unlikely(source != READ_ONCE(fdb->dst) &&
+ 				     !test_bit(BR_FDB_STICKY, &fdb->flags))) {
+ 				br_switchdev_fdb_notify(br, fdb, RTM_DELNEIGH);
++				ether_addr_copy(fdb_event.addr, addr);
++				fdb_event.br = br;
++				fdb_event.orig_dev = fdb->dst->dev;
++				fdb_event.dev = source->dev;
+ 				WRITE_ONCE(fdb->dst, source);
+ 				fdb_modified = true;
+ 
+@@ -947,7 +961,7 @@ void br_fdb_update(struct net_bridge *br
+ 
+ 				atomic_notifier_call_chain(
+ 					&br_fdb_update_notifier_list,
+-					0, (void *)addr);
++					0, (void *)&fdb_event);
+ 			}
+ 
+ 			if (unlikely(test_bit(BR_FDB_ADDED_BY_USER, &flags)))
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960209-bridge-fix-eapol-packet-dropping-issue.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,38 @@
+From 7e591cce95cbb06256e278c3617ea4cb7b01b6ef Mon Sep 17 00:00:00 2001
+From: Zhu Ken <guigenz@codeaurora.org>
+Date: Wed, 14 Jun 2017 11:45:28 -0700
+Subject: [PATCH 223/500] bridge: fix eapol packet dropping issue
+
+wpa_supplicant would receive EAPOL packet to start 802.1x session even if
+its wireless STA interface enslaved in a bridge is disabled.
+
+Change-Id: I4e3f786049a19c5bc7aacdc0528b0099744e8674
+Signed-off-by: Zhu Ken <guigenz@codeaurora.org>
+---
+ net/bridge/br_input.c | 14 ++++++++------
+ 1 file changed, 8 insertions(+), 6 deletions(-)
+
+--- a/net/bridge/br_input.c
++++ b/net/bridge/br_input.c
+@@ -449,13 +449,15 @@ forward:
+ 
+ 	switch (p->state) {
+ 	case BR_STATE_DISABLED:
+-		if (ether_addr_equal(p->br->dev->dev_addr, dest))
+-			skb->pkt_type = PACKET_HOST;
++		if (skb->protocol == htons(ETH_P_PAE)) {
++			if (ether_addr_equal(p->br->dev->dev_addr, dest))
++				skb->pkt_type = PACKET_HOST;
+ 
+-		if (BR_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING,
+-			dev_net(skb->dev), NULL, skb, skb->dev, NULL,
+-			br_handle_local_finish) == 1) {
+-			return RX_HANDLER_PASS;
++			if (NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING,
++				dev_net(skb->dev), NULL, skb, skb->dev, NULL,
++				br_handle_local_finish) == 1) {
++				return RX_HANDLER_PASS;
++			}
+ 		}
+ 		break;
+ 
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960210-bridge-Get-hairpin-enabled-information-from-bridge.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,41 @@
+From a22553300ace19831f0e7189bc2d43dc4cfd41b5 Mon Sep 17 00:00:00 2001
+From: Varsha Mishra <varsham@codeaurora.org>
+Date: Thu, 11 Jun 2020 18:45:40 +0530
+Subject: [PATCH 224/500] bridge: Get hairpin enabled information from bridge.
+
+Add API to let other modules find out if bridge has
+hairpin enabled or not.
+Change-Id: I04c76345111bf8297dbe41230e1254df33556d52
+Signed-off-by: Varsha Mishra <varsham@codeaurora.org>
+---
+ include/linux/if_bridge.h |  1 +
+ net/bridge/br_if.c        | 11 +++++++++++
+ 2 files changed, 12 insertions(+)
+
+--- a/include/linux/if_bridge.h
++++ b/include/linux/if_bridge.h
+@@ -85,6 +85,7 @@ extern struct net_bridge_fdb_entry *br_f
+ 						     __u16 vid);
+ extern void br_fdb_update_register_notify(struct notifier_block *nb);
+ extern void br_fdb_update_unregister_notify(struct notifier_block *nb);
++extern bool br_is_hairpin_enabled(struct net_device *dev);
+ 
+ #if IS_ENABLED(CONFIG_BRIDGE) && IS_ENABLED(CONFIG_BRIDGE_IGMP_SNOOPING)
+ int br_multicast_list_adjacent(struct net_device *dev,
+--- a/net/bridge/br_if.c
++++ b/net/bridge/br_if.c
+@@ -864,3 +864,14 @@ void br_dev_update_stats(struct net_devi
+ 	u64_stats_update_end(&stats->syncp);
+ }
+ EXPORT_SYMBOL_GPL(br_dev_update_stats);
++
++/* API to know if hairpin feature is enabled/disabled on this bridge port */
++bool br_is_hairpin_enabled(struct net_device *dev)
++{
++	struct net_bridge_port *port = br_port_get_check_rcu(dev);
++
++	if (likely(port))
++		return port->flags & BR_HAIRPIN_MODE;
++	return false;
++}
++EXPORT_SYMBOL_GPL(br_is_hairpin_enabled);
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960211-net_bridge-Export-br_fdb_find_rcu-symbol.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,24 @@
+From 67ba6859810f6699481f9a70434a437fc0a112be Mon Sep 17 00:00:00 2001
+From: Tian Yang <tiany@codeaurora.org>
+Date: Wed, 9 Sep 2020 15:11:58 -0700
+Subject: [PATCH 225/500] net_bridge: Export br_fdb_find_rcu symbol
+
+Export br_fdb_find_rcu symbol to be used for other module
+to find fdb entry.
+
+Change-Id: I3df88b35ddfad2d295cdd45303002c5db015ff8c
+Signed-off-by: Tian Yang <tiany@codeaurora.org>
+---
+ net/bridge/br_fdb.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/net/bridge/br_fdb.c
++++ b/net/bridge/br_fdb.c
+@@ -305,6 +305,7 @@ struct net_bridge_fdb_entry *br_fdb_find
+ {
+ 	return fdb_find_rcu(&br->fdb_hash_tbl, addr, vid);
+ }
++EXPORT_SYMBOL_GPL(br_fdb_find_rcu);
+ 
+ /* When a static FDB entry is added, the mac address from the entry is
+  * added to the bridge private HW address list and all required ports
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960212-bridge-fix-bridge-vlan-filter-toggle-issue.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,33 @@
+From b1d5d5d9430d915a4650efed5684d8166907bf51 Mon Sep 17 00:00:00 2001
+From: Ken Zhu <quic_guigenz@quicinc.com>
+Date: Tue, 2 May 2023 21:39:54 -0700
+Subject: [PATCH 226/500] bridge: fix bridge vlan filter toggle issue
+
+when vlan filter is disabled, it could cause new bridge
+creation failed if vlan filter setting existing in the
+netlink creation message
+
+Change-Id: I02f010e746e94623fda544846d05908a83d14fa2
+Signed-off-by: Ken Zhu <quic_guigenz@quicinc.com>
+---
+ net/bridge/br_netlink.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/net/bridge/br_netlink.c
++++ b/net/bridge/br_netlink.c
+@@ -1322,6 +1322,7 @@ static int br_changelink(struct net_devi
+ 		br_stp_set_bridge_priority(br, priority);
+ 	}
+ 
++#ifdef CONFIG_BRIDGE_VLAN_FILTERING
+ 	if (data[IFLA_BR_VLAN_FILTERING]) {
+ 		u8 vlan_filter = nla_get_u8(data[IFLA_BR_VLAN_FILTERING]);
+ 
+@@ -1330,7 +1331,6 @@ static int br_changelink(struct net_devi
+ 			return err;
+ 	}
+ 
+-#ifdef CONFIG_BRIDGE_VLAN_FILTERING
+ 	if (data[IFLA_BR_VLAN_PROTOCOL]) {
+ 		__be16 vlan_proto = nla_get_be16(data[IFLA_BR_VLAN_PROTOCOL]);
+ 
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960213-bridge-Fixes-for-Bridge-VLAN-Filtering.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,358 @@
+From a7ca7e5aa383c26d9f0983113b3dae1108452ec1 Mon Sep 17 00:00:00 2001
+From: Vishnu Vardhan Bantanahal <quic_vishvard@quicinc.com>
+Date: Mon, 15 May 2023 17:56:04 +0530
+Subject: [PATCH 227/500] bridge: Fixes for Bridge VLAN Filtering
+
+1. Fix function to check for bridge master status while checking
+for Bridge VLAN filter feature is enabled on bridge slave ports.
+2. Disable default PVID for bridges during device registration in
+the system.
+Change-Id: Ibea6559c1b0700a2300b60e20d57b7818e23a8a8
+Signed-off-by: Vishnu Vardhan Bantanahal <quic_vishvard@quicinc.com>
+
+bridge: Fix Bridge VLAN stats update
+This patch fixes Bridge VLAN stats update for both bridge master
+and bridge slave.
+Change-Id: Ia26f4c71e83e27dd83336815cda5c05c8c3f24ff
+Signed-off-by: Vishnu Vardhan Bantanahal <quic_vishvard@quicinc.com>
+
+bridge: Add bridge VLAN filter APIs for offload for 6.1 Kernel
+
+Change-Id: I54e44c26664f86ae024f54605a032713a9a3eee5
+Signed-off-by: Vishnu Vardhan Bantanahal <quic_vishvard@quicinc.com>
+---
+ include/linux/if_bridge.h |  29 +++++-
+ include/linux/netdevice.h |   2 +-
+ net/bridge/br.c           |   4 +
+ net/bridge/br_if.c        |  11 ++-
+ net/bridge/br_private.h   |   1 +
+ net/bridge/br_vlan.c      | 186 +++++++++++++++++++++++++++++++++++++-
+ net/core/dev.c            |   2 +-
+ 7 files changed, 227 insertions(+), 8 deletions(-)
+
+--- a/include/linux/if_bridge.h
++++ b/include/linux/if_bridge.h
+@@ -140,6 +140,12 @@ int br_vlan_get_info_rcu(const struct ne
+ bool br_mst_enabled(const struct net_device *dev);
+ int br_mst_get_info(const struct net_device *dev, u16 msti, unsigned long *vids);
+ int br_mst_get_state(const struct net_device *dev, u16 msti, u8 *state);
++
++extern struct net_device *br_fdb_find_vid_by_mac(struct net_device *dev, u8 *mac, u16 *vid);
++extern int br_vlan_get_tag_skb(const struct sk_buff *skb, u16 *vid);
++extern int br_dev_is_vlan_filter_enabled(const struct net_device *dev);
++extern int br_vlan_update_stats(struct net_device* dev, u32 vid, u64 rx_bytes, u64 rx_packets, u64 tx_bytes, u64 tx_packets);
++extern int br_vlan_get_info_rcu(const struct net_device *dev, u16 vid, struct bridge_vlan_info *p_vinfo);
+ #else
+ static inline bool br_vlan_enabled(const struct net_device *dev)
+ {
+@@ -161,8 +167,27 @@ static inline int br_vlan_get_pvid_rcu(c
+ 	return -EINVAL;
+ }
+ 
+-static inline int br_vlan_get_info(const struct net_device *dev, u16 vid,
+-				   struct bridge_vlan_info *p_vinfo)
++static inline int br_vlan_get_info(const struct net_device *dev, u16 vid, struct bridge_vlan_info *p_vinfo)
++{
++	return -EINVAL;
++}
++
++static inline struct net_device *br_fdb_find_vid_by_mac(struct net_device *dev, u8 *mac, u16 *vid)
++{
++	return NULL;
++}
++
++static inline int br_vlan_get_tag_skb(const struct sk_buff *skb, u16 *vid)
++{
++	return -EINVAL;
++}
++
++static inline int br_dev_is_vlan_filter_enabled(const struct net_device *dev)
++{
++	return -EINVAL;
++}
++
++static inline int br_vlan_update_stats(struct net_device* dev, u32 vid, u64 rx_bytes, u64 rx_packets, u64 tx_bytes, u64 tx_packets)
+ {
+ 	return -EINVAL;
+ }
+--- a/include/linux/netdevice.h
++++ b/include/linux/netdevice.h
+@@ -4852,7 +4852,7 @@ int netdev_walk_all_lower_dev_rcu(struct
+ void *netdev_adjacent_get_private(struct list_head *adj_list);
+ void *netdev_lower_get_first_private_rcu(struct net_device *dev);
+ struct net_device *netdev_master_upper_dev_get(struct net_device *dev);
+-struct net_device *netdev_master_upper_dev_get_rcu(struct net_device *dev);
++struct net_device *netdev_master_upper_dev_get_rcu(const struct net_device *dev);
+ int netdev_upper_dev_link(struct net_device *dev, struct net_device *upper_dev,
+ 			  struct netlink_ext_ack *extack);
+ int netdev_master_upper_dev_link(struct net_device *dev,
+--- a/net/bridge/br.c
++++ b/net/bridge/br.c
+@@ -42,6 +42,10 @@ static int br_device_event(struct notifi
+ 			return notifier_from_errno(err);
+ 
+ 		if (event == NETDEV_REGISTER) {
++#if IS_ENABLED(CONFIG_BRIDGE_VLAN_FILTERING)
++			br_vlan_disable_default_pvid(netdev_priv(dev));
++#endif
++
+ 			/* register of bridge completed, add sysfs entries */
+ 			err = br_sysfs_addbr(dev);
+ 			if (err)
+--- a/net/bridge/br_if.c
++++ b/net/bridge/br_if.c
+@@ -802,6 +802,7 @@ struct net_device *br_port_dev_get(struc
+ 	struct net_bridge_fdb_entry *fdbe;
+ 	struct net_bridge *br;
+ 	struct net_device *netdev = NULL;
++	u16 __maybe_unused vid;
+ 
+ 	/* Is this a bridge? */
+ 	if (!(dev->priv_flags & IFF_EBRIDGE))
+@@ -830,14 +831,20 @@ struct net_device *br_port_dev_get(struc
+ 	 * determine the port to use - fall back to using FDB
+ 	 */
+ 
++#if IS_ENABLED(CONFIG_BRIDGE_VLAN_FILTERING)
++	/* Lookup the fdb entry and get reference to the port dev.
++	 * dev_hold() is done as part of br_fdb_find_vid_by_mac()
++	 */
++	netdev = br_fdb_find_vid_by_mac(dev, addr, &vid);
++#else
+ 	br = netdev_priv(dev);
+-
+-	/* Lookup the fdb entry and get reference to the port dev */
+ 	fdbe = br_fdb_find_rcu(br, addr, 0);
+ 	if (fdbe && fdbe->dst) {
+ 		netdev = fdbe->dst->dev; /* port device */
+ 		dev_hold(netdev);
+ 	}
++#endif
++
+ out:
+ 	rcu_read_unlock();
+ 	return netdev;
+--- a/net/bridge/br_private.h
++++ b/net/bridge/br_private.h
+@@ -1564,6 +1564,7 @@ void br_vlan_fill_forward_path_pvid(stru
+ int br_vlan_fill_forward_path_mode(struct net_bridge *br,
+ 				   struct net_bridge_port *dst,
+ 				   struct net_device_path *path);
++void br_vlan_disable_default_pvid(struct net_bridge *br);
+ 
+ static inline struct net_bridge_vlan_group *br_vlan_group(
+ 					const struct net_bridge *br)
+--- a/net/bridge/br_vlan.c
++++ b/net/bridge/br_vlan.c
+@@ -933,8 +933,190 @@ int br_vlan_get_proto(const struct net_d
+ }
+ EXPORT_SYMBOL_GPL(br_vlan_get_proto);
+ 
++/*
++ * br_vlan_get_tag_skb()
++ * 	Returns VLAN tag is its found valid in skb.
++ */
++int br_vlan_get_tag_skb(const struct sk_buff *skb, u16 *vid)
++{
++	return br_vlan_get_tag(skb, vid);
++
++}
++EXPORT_SYMBOL_GPL(br_vlan_get_tag_skb);
++
++/*
++ * br_dev_is_vlan_filter_enabled()
++ * 	Caller should ensure to hold rcu_lock()
++ * 	Returns 0, when device(port or bridge device) has a valid bridge
++ * 	vlan filter configuration and returns error otherwise.
++ */
++int br_dev_is_vlan_filter_enabled(const struct net_device *dev)
++{
++	struct net_bridge_port *p;
++	struct net_bridge_vlan_group *vg = NULL;
++	struct net_device *master = NULL;
++
++	if (!dev) {
++		return -ENODEV;
++	}
++
++	if (netif_is_bridge_master(dev)) {
++		/*
++		 * Its a bridge device
++		 */
++		if (!br_vlan_enabled(dev)) {
++			return -ENOENT;
++		}
++
++		vg = br_vlan_group(netdev_priv(dev));
++	} else if (dev->priv_flags & IFF_BRIDGE_PORT) {
++		/*
++		 * It's a bridge port
++		 */
++		master = netdev_master_upper_dev_get_rcu(dev);
++		if (!master) {
++			return -EINVAL;
++		}
++
++		if (!br_vlan_enabled(master)) {
++			return -ENOENT;
++		}
++
++		p = br_port_get_rcu(dev);
++		if (p)
++			vg = nbp_vlan_group(p);
++	} else {
++		/*
++		 * Neither a bridge device or port
++		 */
++		return -EINVAL;
++	}
++
++	if (vg != NULL && vg->num_vlans) {
++		return 0;
++	}
++
++	return -ENXIO;
++}
++EXPORT_SYMBOL_GPL(br_dev_is_vlan_filter_enabled);
++
++/*
++ * br_fdb_find_vid_by_mac()
++ * 	Caller ensures to ensure rcu_lock() is taken.
++ * 	Returns 0 in case of lookup was performed.
++ * 	Look up the bridge fdb table for the mac-address & find associated
++ * 	VLAN id associated with it.
++ * 	vid is non-zero for succesfull lookup, otherwise 0.
++ * 	We dev_hold() on the returned device, caller will release this hold.
++ */
++struct net_device *br_fdb_find_vid_by_mac(struct net_device *dev, u8 *mac, u16 *vid)
++{
++	struct net_bridge *br;
++	struct net_bridge_fdb_entry *f;
++	struct net_device *netdev = NULL;
++
++	if (!mac) {
++		return NULL;
++	}
++
++	if (!dev || !netif_is_bridge_master(dev)) {
++		return NULL;
++	}
++
++	br = netdev_priv(dev);
++	if (!br) {
++		return NULL;
++	}
++
++	hlist_for_each_entry_rcu(f, &br->fdb_list, fdb_node) {
++		if (ether_addr_equal(f->key.addr.addr, mac)) {
++			*vid = f->key.vlan_id;
++			if (f->dst) {
++				netdev = f->dst->dev;
++				dev_hold(netdev);
++				break;
++			}
++		}
++	}
++	return netdev;
++}
++EXPORT_SYMBOL_GPL(br_fdb_find_vid_by_mac);
++
++/*
++ * br_vlan_update_stats()
++ * 	Update bridge VLAN filter statistics.
++ */
++int br_vlan_update_stats(struct net_device *dev, u32 vid, u64 rx_bytes, u64 rx_packets, u64 tx_bytes, u64 tx_packets)
++{
++	struct net_bridge_port *p;
++	struct net_bridge_vlan *v;
++	struct pcpu_sw_netstats *stats;
++	const struct net_bridge *br;
++	struct net_bridge_vlan_group *vg;
++	struct net_device *brdev;
++
++	if (!dev) {
++		return -ENODEV;
++	}
++
++	if (!netif_is_bridge_port(dev) && !netif_is_bridge_master(dev)) {
++		return -EINVAL;
++	}
++
++	rcu_read_lock();
++
++	brdev = dev;
++	if (!netif_is_bridge_master(dev)) {
++		brdev = netdev_master_upper_dev_get_rcu(dev);
++		if (!brdev) {
++			rcu_read_unlock();
++			return -EPERM;
++		}
++	}
++
++	br = netdev_priv(brdev);
++	if (!br || !br_opt_get(br, BROPT_VLAN_STATS_ENABLED)) {
++		rcu_read_unlock();
++		return -EINVAL;
++	}
++
++	p = br_port_get_rcu(dev);
++	if (p) {
++		vg = nbp_vlan_group_rcu(p);
++	} else if (netif_is_bridge_master(dev)) {
++		vg = br_vlan_group(netdev_priv(dev));
++	} else {
++		rcu_read_unlock();
++		return -EINVAL;
++	}
++
++
++	if (!vg) {
++		rcu_read_unlock();
++		return -ENXIO;
++	}
++
++	v = br_vlan_find(vg, vid);
++	if (!v || !br_vlan_should_use(v)) {
++		rcu_read_unlock();
++		return -ENOENT;
++	}
++
++	stats = this_cpu_ptr(v->stats);
++	u64_stats_update_begin(&stats->syncp);
++	u64_stats_add(&stats->rx_bytes, rx_bytes);
++	u64_stats_add(&stats->rx_packets, rx_packets);
++	u64_stats_add(&stats->tx_bytes, tx_bytes);
++	u64_stats_add(&stats->tx_packets, tx_packets);
++	u64_stats_update_end(&stats->syncp);
++
++	rcu_read_unlock();
++	return 0;
++}
++EXPORT_SYMBOL_GPL(br_vlan_update_stats);
++
+ int __br_vlan_set_proto(struct net_bridge *br, __be16 proto,
+-			struct netlink_ext_ack *extack)
++	                        struct netlink_ext_ack *extack)
+ {
+ 	struct switchdev_attr attr = {
+ 		.orig_dev = br->dev,
+@@ -1068,7 +1250,7 @@ static bool vlan_default_pvid(struct net
+ 	return false;
+ }
+ 
+-static void br_vlan_disable_default_pvid(struct net_bridge *br)
++void br_vlan_disable_default_pvid(struct net_bridge *br)
+ {
+ 	struct net_bridge_port *p;
+ 	u16 pvid = br->default_pvid;
+--- a/net/core/dev.c
++++ b/net/core/dev.c
+@@ -7632,7 +7632,7 @@ EXPORT_SYMBOL(netdev_lower_get_first_pri
+  * Find a master upper device and return pointer to it or NULL in case
+  * it's not there. The caller must hold the RCU read lock.
+  */
+-struct net_device *netdev_master_upper_dev_get_rcu(struct net_device *dev)
++struct net_device *netdev_master_upper_dev_get_rcu(const struct net_device *dev)
+ {
+ 	struct netdev_adjacent *upper;
+ 
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960215-bridge-stp-Change-debug-level-STP.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,38 @@
+From 46de8b4dc7289c626c6c7414e316850caf53001f Mon Sep 17 00:00:00 2001
+From: Tian Yang <tiany@codeaurora.org>
+Date: Wed, 3 Feb 2021 13:46:19 -0800
+Subject: [PATCH 229/500] bridge: stp: Change debug level STP
+
+Easy to know whether kernel stp or user space stp is running.
+Avoiding error message when bridge-stp exists while user space stp is not chosen.
+
+Change-Id: I58ae9bc5e6908d9acfe0686c1da6fe50e1486976
+Signed-off-by: Tian Yang <tiany@codeaurora.org>
+---
+ net/bridge/br_stp_if.c | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+--- a/net/bridge/br_stp_if.c
++++ b/net/bridge/br_stp_if.c
+@@ -153,7 +153,7 @@ static void br_stp_start(struct net_brid
+ 		err = br_stp_call_user(br, "start");
+ 
+ 	if (err && err != -ENOENT)
+-		br_err(br, "failed to start userspace STP (%d)\n", err);
++		br_debug(br, "failed to start userspace STP (%d)\n", err);
+ 
+ 	spin_lock_bh(&br->lock);
+ 
+@@ -164,10 +164,10 @@ static void br_stp_start(struct net_brid
+ 
+ 	if (!err) {
+ 		br->stp_enabled = BR_USER_STP;
+-		br_debug(br, "userspace STP started\n");
++		br_info(br, "userspace STP started\n");
+ 	} else {
+ 		br->stp_enabled = BR_KERNEL_STP;
+-		br_debug(br, "using kernel STP\n");
++		br_info(br, "using kernel STP\n");
+ 
+ 		/* To start timers on any ports left in blocking */
+ 		if (br->dev->flags & IFF_UP)
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960216-linux-Delete-fdb-entry-using-netdev.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,48 @@
+From 8b88c8448c5aaf30c85193348bb1da81a4268794 Mon Sep 17 00:00:00 2001
+From: Subhranil Choudhury <subhrani@codeaurora.org>
+Date: Mon, 6 Apr 2020 01:22:29 +0530
+Subject: [PATCH 230/500] linux: Delete fdb entry using netdev
+
+Added and exported a new API to delete a bridge FDB entry
+using net device.
+
+Change-Id: Icc7c7f8608083edf02248cd25ee6a88cad81dd76
+Signed-off-by: Subhranil Choudhury <subhrani@codeaurora.org>
+---
+ include/linux/if_bridge.h |  2 ++
+ net/bridge/br_fdb.c       | 13 +++++++++++++
+ 2 files changed, 15 insertions(+)
+
+--- a/include/linux/if_bridge.h
++++ b/include/linux/if_bridge.h
+@@ -279,6 +279,8 @@ struct br_fdb_event {
+ extern void br_fdb_register_notify(struct notifier_block *nb);
+ extern void br_fdb_unregister_notify(struct notifier_block *nb);
+ extern struct net_device *br_fdb_bridge_dev_get_and_hold(struct net_bridge *br);
++extern int br_fdb_delete_by_netdev(struct net_device *dev,
++			const unsigned char *addr, u16 vid);
+ 
+ typedef struct net_bridge_port *br_get_dst_hook_t(
+ 		const struct net_bridge_port *src,
+--- a/net/bridge/br_fdb.c
++++ b/net/bridge/br_fdb.c
+@@ -1384,6 +1384,19 @@ static int __br_fdb_delete(struct net_br
+ 	return err;
+ }
+ 
++int br_fdb_delete_by_netdev(struct net_device *dev,
++			    const unsigned char *addr, u16 vid)
++{
++	int err;
++
++	rtnl_lock();
++	err = br_fdb_delete(NULL, NULL, dev, addr, vid);
++	rtnl_unlock();
++
++	return err;
++}
++EXPORT_SYMBOL_GPL(br_fdb_delete_by_netdev);
++
+ /* Remove neighbor entry with RTM_DELNEIGH */
+ int br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],
+ 		  struct net_device *dev,
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960217-linux-Removing-RTNL-lock-in-br_fdb_delete_by_netdev.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,79 @@
+From c15b6c052a1d49b7dd7e217b9826eaa49edd3f54 Mon Sep 17 00:00:00 2001
+From: Subhranil Choudhury <subhrani@codeaurora.org>
+Date: Mon, 11 May 2020 12:17:03 +0530
+Subject: [PATCH 231/500] linux: Removing RTNL lock in br_fdb_delete_by_netdev.
+
+Removing the rtnl lock in br_fdb_delete_by_netdev function.
+This function is being called from interrupt context in wifi driver.
+And rtnl_lock being a mutex lock, if held from an interrupt context
+results in a system crash.
+
+Change-Id: I4c4fb551764d3ba556794810f1274c020d250730
+Signed-off-by: Subhranil Choudhury <subhrani@codeaurora.org>
+Signed-off-by: Pavithra R <pavir@codeaurora.org>
+---
+ net/bridge/br_fdb.c | 49 +++++++++++++++++++++++++++++++++++++++++----
+ 1 file changed, 45 insertions(+), 4 deletions(-)
+
+--- a/net/bridge/br_fdb.c
++++ b/net/bridge/br_fdb.c
+@@ -1384,14 +1384,55 @@ static int __br_fdb_delete(struct net_br
+ 	return err;
+ }
+ 
++/* This function has to be called only for bridge-port netdevs.*/
++/* For bridge netdev br_fdb_delete has to be called.*/
+ int br_fdb_delete_by_netdev(struct net_device *dev,
+ 			    const unsigned char *addr, u16 vid)
+ {
+-	int err;
++	int err = 0;
++	struct net_bridge_vlan_group *vg;
++	struct net_bridge_vlan *v;
++	struct net_bridge_port *p = NULL;
+ 
+-	rtnl_lock();
+-	err = br_fdb_delete(NULL, NULL, dev, addr, vid);
+-	rtnl_unlock();
++	rcu_read_lock();
++	p = br_port_get_check_rcu(dev);
++	if (!p) {
++		rcu_read_unlock();
++		pr_info("bridge: %s not a bridge port\n",
++			dev->name);
++		return -EINVAL;
++	}
++	vg = nbp_vlan_group(p);
++
++	if (vid) {
++		v = br_vlan_find(vg, vid);
++		if (!v) {
++			rcu_read_unlock();
++			pr_info("bridge: with unconfigured vlan %d on %s\n"
++				, vid, dev->name);
++			return -EINVAL;
++		}
++
++		err =  __br_fdb_delete(p->br, p, addr, vid);
++		rcu_read_unlock();
++		return err;
++	}
++	err = __br_fdb_delete(p->br, p, addr, 0);
++
++	if (!vg || !vg->num_vlans) {
++		rcu_read_unlock();
++		return err;
++	}
++
++	/* We have vlans configured on this port and user didn't
++	 * specify a VLAN. So, delete entry for every vlan on this port.
++	 */
++	list_for_each_entry(v, &vg->vlan_list, vlist) {
++		if (!br_vlan_should_use(v))
++			continue;
++		err &= __br_fdb_delete(p->br, p, addr, v->vid);
++	}
++	rcu_read_unlock();
+ 
+ 	return err;
+ }
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960218-net-fix-potential-memory-leak.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,25 @@
+From 02b406e82dfde895c03a03e9016844138a2ea421 Mon Sep 17 00:00:00 2001
+From: Ken Zhu <quic_guigenz@quicinc.com>
+Date: Thu, 14 Oct 2021 08:50:03 -0700
+Subject: [PATCH 232/500] net: fix potential memory leak
+
+When A packets come from a disabled port, if it is not a accepted
+EAPOL, it has no chance to get freed.
+
+Change-Id: Ib2bddeb53f2117bcc803d11912471a8456a3148a
+Signed-off-by: Ken Zhu <quic_guigenz@quicinc.com>
+---
+ net/bridge/br_input.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/net/bridge/br_input.c
++++ b/net/bridge/br_input.c
+@@ -459,7 +459,7 @@ forward:
+ 				return RX_HANDLER_PASS;
+ 			}
+ 		}
+-		break;
++		goto drop;
+ 
+ 	case BR_STATE_FORWARDING:
+ 	case BR_STATE_LEARNING:
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960219-net-do-time-update-rather-than-fully-update-in-the-f.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,52 @@
+From 72a14726b11c05783835c06efb0ea12ca1afb4d0 Mon Sep 17 00:00:00 2001
+From: Ken Zhu <quic_guigenz@quicinc.com>
+Date: Mon, 25 Apr 2022 13:54:20 -0700
+Subject: [PATCH 233/500] net: do time update rather than fully update in the
+ fdb
+
+keep the fdb up to date when do refresh.
+
+Change-Id: Ib0297f11920b66bb573ef41f8a09da9ac0d774af
+Signed-off-by: Ken Zhu <quic_guigenz@quicinc.com>
+---
+ include/linux/if_bridge.h |  1 +
+ net/bridge/br_fdb.c       | 18 ++++++++++++++++++
+ 2 files changed, 19 insertions(+)
+
+--- a/include/linux/if_bridge.h
++++ b/include/linux/if_bridge.h
+@@ -78,6 +78,7 @@ extern struct net_device *br_port_dev_ge
+ 					  struct sk_buff *skb,
+ 					  unsigned int cookie);
+ extern void br_refresh_fdb_entry(struct net_device *dev, const char *addr);
++extern void br_fdb_entry_refresh(struct net_device *dev, const char *addr, __u16 vid);
+ extern void br_dev_update_stats(struct net_device *dev,
+ 				struct rtnl_link_stats64 *nlstats);
+ extern struct net_bridge_fdb_entry *br_fdb_has_entry(struct net_device *dev,
+--- a/net/bridge/br_fdb.c
++++ b/net/bridge/br_fdb.c
+@@ -1006,6 +1006,24 @@ void br_refresh_fdb_entry(struct net_dev
+ }
+ EXPORT_SYMBOL_GPL(br_refresh_fdb_entry);
+ 
++/* Update timestamp of FDB entries for bridge packets being forwarded by offload engines */
++void br_fdb_entry_refresh(struct net_device *dev, const char *addr, __u16 vid)
++{
++	struct net_bridge_fdb_entry *fdb;
++	struct net_bridge_port *p = br_port_get_rcu(dev);
++
++	if (!p || p->state == BR_STATE_DISABLED)
++		return;
++
++	rcu_read_lock();
++	fdb = fdb_find_rcu(&p->br->fdb_hash_tbl, addr, vid);
++	if (likely(fdb)) {
++		fdb->updated = jiffies;
++	}
++	rcu_read_unlock();
++}
++EXPORT_SYMBOL_GPL(br_fdb_entry_refresh);
++
+ /* Look up the MAC address in the device's bridge fdb table */
+ struct net_bridge_fdb_entry *br_fdb_has_entry(struct net_device *dev,
+ 					      const char *addr, __u16 vid)
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960220-bridge-Fix-the-bridge-stats-update-function.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,35 @@
+From 0d4365501a75d370d920a2b41c6bc006b15c01b7 Mon Sep 17 00:00:00 2001
+From: Manish Verma <quic_maniverm@quicinc.com>
+Date: Wed, 8 Jun 2022 18:47:35 +0530
+Subject: [PATCH 234/500] bridge: Fix the bridge stats update function
+
+1. For updating the stats, use the current core's stats pointer
+2. Hold the exclusive access to the sequence counter while updating
+   the bridge stats.
+
+Change-Id: I16d33677ee402dc4436741b630dfb9eb17caced0
+Signed-off-by: Manish Verma <quic_maniverm@quicinc.com>
+---
+ net/bridge/br_if.c | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+--- a/net/bridge/br_if.c
++++ b/net/bridge/br_if.c
+@@ -861,14 +861,16 @@ void br_dev_update_stats(struct net_devi
+ 	if (!(dev->priv_flags & IFF_EBRIDGE))
+ 		return;
+ 
+-	stats = per_cpu_ptr(dev->tstats, 0);
++	stats = this_cpu_ptr(dev->tstats);
+ 
++	local_bh_disable();
+ 	u64_stats_update_begin(&stats->syncp);
+ 	u64_stats_add(&stats->rx_packets, nlstats->rx_packets);
+ 	u64_stats_add(&stats->rx_bytes, nlstats->rx_bytes);
+ 	u64_stats_add(&stats->tx_packets, nlstats->tx_packets);
+ 	u64_stats_add(&stats->tx_bytes, nlstats->tx_bytes);
+ 	u64_stats_update_end(&stats->syncp);
++	local_bh_enable();
+ }
+ EXPORT_SYMBOL_GPL(br_dev_update_stats);
+ 
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960221-linux-fix-dscpremark-extention-doesn-t-set-the-type-.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,45 @@
+From dd3ba779d4ed0ae717c1f1b8d0bbcf2adbfd6963 Mon Sep 17 00:00:00 2001
+From: Ken Zhu <quic_guigenz@quicinc.com>
+Date: Thu, 28 Sep 2023 10:44:56 -0700
+Subject: [PATCH 175/500] linux: fix dscpremark extention doesn't set the type
+ length
+
+It needs to set up the type length for each extension.
+
+Change-Id: Ia2087d7c4653045665c006ca9d637ff49d27fd92
+Signed-off-by: Ken Zhu <quic_guigenz@quicinc.com>
+---
+ net/netfilter/nf_conntrack_extend.c | 8 ++++++++
+ 1 file changed, 8 insertions(+)
+
+--- a/net/netfilter/nf_conntrack_extend.c
++++ b/net/netfilter/nf_conntrack_extend.c
+@@ -24,6 +24,7 @@
+ #include <net/netfilter/nf_conntrack_synproxy.h>
+ #include <net/netfilter/nf_conntrack_act_ct.h>
+ #include <net/netfilter/nf_nat.h>
++#include <net/netfilter/nf_conntrack_dscpremark_ext.h>
+ 
+ #define NF_CT_EXT_PREALLOC	128u /* conntrack events are on by default */
+ 
+@@ -54,6 +55,10 @@ static const u8 nf_ct_ext_type_len[NF_CT
+ #if IS_ENABLED(CONFIG_NET_ACT_CT)
+ 	[NF_CT_EXT_ACT_CT] = sizeof(struct nf_conn_act_ct_ext),
+ #endif
++#ifdef CONFIG_NF_CONNTRACK_DSCPREMARK_EXT
++	[NF_CT_EXT_DSCPREMARK] = sizeof(struct nf_ct_dscpremark_ext),
++#endif
++
+ };
+ 
+ static __always_inline unsigned int total_extension_size(void)
+@@ -86,6 +91,9 @@ static __always_inline unsigned int tota
+ #if IS_ENABLED(CONFIG_NET_ACT_CT)
+ 		+ sizeof(struct nf_conn_act_ct_ext)
+ #endif
++#ifdef CONFIG_NF_CONNTRACK_DSCPREMARK_EXT
++		+ sizeof(struct nf_ct_dscpremark_ext)
++#endif
+ 	;
+ }
+ 
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960222-linux-Add-check-for-the-FTP-ALG-port.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,89 @@
+From 6e1b966b2030faf715cd36ec2de43f95631b7000 Mon Sep 17 00:00:00 2001
+From: Ken Zhu <guigenz@codeaurora.org>
+Date: Tue, 26 Mar 2019 14:44:09 -0700
+Subject: [PATCH 152/500] linux: Add check for the FTP ALG port
+
+Fix the MAP-E handling in the FTP ALG, to choose a proper port using
+the restricted PSID range configured by the network admin.
+
+Change-Id: I186148b25f6c9c70ffbe7c260d2001c937fe388f
+Signed-off-by: Ken Zhu <guigenz@codeaurora.org>
+---
+ net/netfilter/nf_nat_ftp.c | 45 +++++++++++++++++++++++++++++++-------
+ 1 file changed, 37 insertions(+), 8 deletions(-)
+
+--- a/net/netfilter/nf_nat_ftp.c
++++ b/net/netfilter/nf_nat_ftp.c
+@@ -25,11 +25,42 @@ MODULE_AUTHOR("Rusty Russell <rusty@rust
+ MODULE_DESCRIPTION("ftp NAT helper");
+ MODULE_ALIAS_NF_NAT_HELPER(NAT_HELPER_NAME);
+ 
++static ushort psid = 0;
++module_param(psid, ushort, 0644);
++MODULE_PARM_DESC(psid, "MAP_E devices's psid");
++
++static uint psid_len = 0;
++module_param(psid_len, uint, 0644);
++MODULE_PARM_DESC(psid_len, "MAP_E devices's psid length");
++
++static uint offset = 0;
++module_param(offset, uint, 0644);
++MODULE_PARM_DESC(offset, "MAP_E devices's psid offset");
++
+ /* FIXME: Time out? --RR */
+ 
+ static struct nf_conntrack_nat_helper nat_helper_ftp =
+ 	NF_CT_NAT_HELPER_INIT(NAT_HELPER_NAME);
+ 
++/**
++ * nf_nat_port_valid_check - check the port is in the range of psid
++ *   @skb the packets to be translated
++ *   @port the port to be checked.
++ **/
++static int nf_nat_port_valid_check(struct sk_buff *skb, u16 port)
++{
++	if (psid == 0 || psid_len == 0 || offset == 0)
++		return 1;
++
++	if ((psid_len + offset) > 16)
++		return 1;
++
++	if ((((port >> (16 - psid_len - offset)) & ((1 << psid_len) - 1))) == psid)
++		return 1;
++
++	return 0;
++}
++
+ static int nf_nat_ftp_fmt_cmd(struct nf_conn *ct, enum nf_ct_ftp_type type,
+ 			      char *buffer, size_t buflen,
+ 			      union nf_inet_addr *addr, u16 port)
+@@ -88,13 +119,9 @@ static unsigned int nf_nat_ftp(struct sk
+ 
+ 	/* In the case of MAP-E, the FTP ALG source port number must use its own
+ 	 * PSID. Otherwise the returned packets from ftp server will use other
+-	 * than its own IPv6 address. The port number of MAP-E has the format
+-	 * like offset | psid | pad. The offset length is usually 6 bits long.
+-	 * So this change reuses the least  10 bits which include the valid PSID
+-	 * and tries different offset value with a step size of 1024 till a
+-	 * free port number is available. */
+-	port = (ntohs(exp->saved_proto.tcp.port) & ~((1 << 10) - 1)) +
+-		(ntohs(ct->tuplehash[!dir].tuple.dst.u.tcp.port) & ((1 << 10) - 1));
++	 * than its own IPv6 address.
++         * so let the check hook to validate the port*/
++
+ 	static const unsigned int max_attempts = 128;
+ 	int range, attempts_left;
+ 	u16 min = port;
+@@ -105,9 +132,11 @@ static unsigned int nf_nat_ftp(struct sk
+ 	if (attempts_left > max_attempts)
+ 		attempts_left = max_attempts;
+ 
+-	for (; ;) {
++	for (port = ntohs(exp->saved_proto.tcp.port); ;) {
+ 		int ret;
+ 
++		if (!nf_nat_port_valid_check(skb, port))
++			continue;
+ 
+ 		exp->tuple.dst.u.tcp.port = htons(port);
+ 		ret = nf_ct_expect_related(exp, 0);
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960223-netfilter-Fix-compilation-issue-seen-in-netfilter-af.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,43 @@
+From e397e87f9a4f7cac388fb971a4f992b507bdc2e3 Mon Sep 17 00:00:00 2001
+From: Ramkishan Gurjar <quic_rgurjar@quicinc.com>
+Date: Fri, 20 Oct 2023 21:19:45 +0530
+Subject: [PATCH 153/500] netfilter: Fix compilation issue seen in netfilter
+ after enabling werror
+
+Change-Id: Iec9a368e519f5c40209079c2f023d32bd5dee633
+Signed-off-by: Ramkishan Gurjar <quic_rgurjar@quicinc.com>
+---
+ net/netfilter/nf_nat_ftp.c | 9 ++++-----
+ 1 file changed, 4 insertions(+), 5 deletions(-)
+
+--- a/net/netfilter/nf_nat_ftp.c
++++ b/net/netfilter/nf_nat_ftp.c
+@@ -105,6 +105,8 @@ static unsigned int nf_nat_ftp(struct sk
+ 	struct nf_conn *ct = exp->master;
+ 	char buffer[sizeof("|1||65535|") + INET6_ADDRSTRLEN];
+ 	unsigned int buflen;
++	static const unsigned int max_attempts = 128;
++	int range, attempts_left;
+ 
+ 	pr_debug("type %i, off %u len %u\n", type, matchoff, matchlen);
+ 
+@@ -122,17 +124,14 @@ static unsigned int nf_nat_ftp(struct sk
+ 	 * than its own IPv6 address.
+          * so let the check hook to validate the port*/
+ 
+-	static const unsigned int max_attempts = 128;
+-	int range, attempts_left;
+-	u16 min = port;
+-
++	port = ntohs(exp->saved_proto.tcp.port);
+ 	range = USHRT_MAX - port;
+ 	attempts_left = range;
+ 
+ 	if (attempts_left > max_attempts)
+ 		attempts_left = max_attempts;
+ 
+-	for (port = ntohs(exp->saved_proto.tcp.port); ;) {
++	for (;port != 0; port++) {
+ 		int ret;
+ 
+ 		if (!nf_nat_port_valid_check(skb, port))
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960224-net-Add-extra-priv_flag-support-in-netdevice.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,178 @@
+From 5c907ac28f19fdef880d56e0ffc15a0d6369c372 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <quic_msezgin@quicinc.com>
+Date: Thu, 18 May 2023 08:47:34 -0700
+Subject: [PATCH 181/500] net: Add extra priv_flag support in netdevice
+
+This patch adds a flag in struct net_device which
+is an extension to priv_flags and is used to
+check the type of device.
+
+Change-Id: Ibb5a3f0c706e1b169b848aed7004aa4ea6d57069
+Signed-off-by: Pavithra R <pavir@codeaurora.org>
+
+Add GRE std support in device tree and priv_flags
+
+Added dts support and priv flags support for GRE and
+to check the type of device
+
+Change-Id: Ib05a32e9e5458c724c182187362116338d767169
+Signed-off-by: ratheesh kannoth <rkannoth@codeaurora.org>
+Signed-off-by: Pavithra R <pavir@codeaurora.org>
+
+drivers: ifb: Add flag to identify the IFB interface.
+
+Add IFB flag in netdevice's ext priv flags and define an API
+to let other modules find out if the netdev is IFB or not.
+
+Change-Id: I6dbdae521240b4a991069c2330d893ff38aec68d
+Signed-off-by: Manish Verma <maniverm@codeaurora.org>
+Signed-off-by: pavir <pavir@codeaurora.org>
+
+net: add IFF_EXT_MAPT flag in net_device priv_flags_ext
+
+Add IFF_EXT_MAPT flag in priv_flags_ext for MAP-T device.
+
+Change-Id: I8aa1715c4b9c62b88eee1b40412cf4e734b2a337
+Signed-off-by: Suruchi Agarwal <quic_suruchia@quicinc.com>
+Signed-off-by: Murat Sezgin <quic_msezgin@quicinc.com>
+---
+ drivers/net/ifb.c         |  1 +
+ include/linux/netdevice.h | 35 ++++++++++++++++++++++++++++++++++-
+ net/ipv4/ip_gre.c         |  2 +-
+ net/ipv6/ip6_gre.c        |  4 +---
+ 4 files changed, 37 insertions(+), 5 deletions(-)
+
+--- a/drivers/net/ifb.c
++++ b/drivers/net/ifb.c
+@@ -326,6 +326,7 @@ static void ifb_setup(struct net_device
+ 	dev->flags |= IFF_NOARP;
+ 	dev->flags &= ~IFF_MULTICAST;
+ 	dev->priv_flags &= ~IFF_TX_SKB_SHARING;
++	dev->priv_flags_ext |= IFF_EXT_IFB;	/* Mark the device as an IFB device. */
+ 	netif_keep_dst(dev);
+ 	eth_hw_addr_random(dev);
+ 	dev->needs_free_netdev = true;
+--- a/include/linux/netdevice.h
++++ b/include/linux/netdevice.h
+@@ -1761,6 +1761,32 @@ enum netdev_priv_flags {
+ 	IFF_NO_IP_ALIGN			= BIT_ULL(34),
+ };
+ 
++/**
++ * enum netdev_priv_flags_ext - &struct net_device priv_flags_ext
++ *
++ * These flags are used to check for device type and can be
++ * set and used by the drivers
++ *
++ * @IFF_EXT_TUN_TAP: device is a TUN/TAP device
++ * @IFF_EXT_PPP_L2TPV2: device is a L2TPV2 device
++ * @IFF_EXT_PPP_L2TPV3: device is a L2TPV3 device
++ * @IFF_EXT_PPP_PPTP: device is a PPTP device
++ * @IFF_EXT_GRE_V4_TAP: device is a GRE IPv4 TAP device
++ * @IFF_EXT_GRE_V6_TAP: device is a GRE IPv6 TAP device
++ * @IFF_EXT_IFB: device is an IFB device
++ * @IFF_EXT_MAPT: device is an MAPT device
++ */
++enum netdev_priv_flags_ext {
++	IFF_EXT_TUN_TAP			= 1<<0,
++	IFF_EXT_PPP_L2TPV2		= 1<<1,
++	IFF_EXT_PPP_L2TPV3		= 1<<2,
++	IFF_EXT_PPP_PPTP		= 1<<3,
++	IFF_EXT_GRE_V4_TAP		= 1<<4,
++	IFF_EXT_GRE_V6_TAP		= 1<<5,
++	IFF_EXT_IFB				= 1<<6,
++	IFF_EXT_MAPT			= 1<<7,
++};
++
+ #define IFF_802_1Q_VLAN			IFF_802_1Q_VLAN
+ #define IFF_EBRIDGE			IFF_EBRIDGE
+ #define IFF_BONDING			IFF_BONDING
+@@ -1881,6 +1907,8 @@ enum netdev_stat_type {
+  *	@xdp_features:	XDP capability supported by the device
+  *	@priv_flags:	Like 'flags' but invisible to userspace,
+  *			see if.h for the definitions
++ *	@priv_flags_ext:	Extension for 'priv_flags'
++ *
+  *	@gflags:	Global flags ( kept as legacy )
+  *	@padded:	How much padding added by alloc_netdev()
+  *	@operstate:	RFC2863 operstate
+@@ -2126,6 +2154,7 @@ struct net_device {
+ 	unsigned int		flags;
+ 	xdp_features_t		xdp_features;
+ 	unsigned long long	priv_flags;
++	unsigned int		priv_flags_ext;
+ 	const struct net_device_ops *netdev_ops;
+ 	const struct xdp_metadata_ops *xdp_metadata_ops;
+ 	int			ifindex;
+@@ -4278,7 +4307,6 @@ static inline bool netif_dormant(const s
+ 	return test_bit(__LINK_STATE_DORMANT, &dev->state);
+ }
+ 
+-
+ /**
+  *	netif_testing_on - mark device as under test.
+  *	@dev: network device
+@@ -5221,6 +5249,11 @@ static inline bool netif_is_failover_sla
+ 	return dev->priv_flags & IFF_FAILOVER_SLAVE;
+ }
+ 
++static inline bool netif_is_ifb_dev(const struct net_device *dev)
++{
++	return dev->priv_flags_ext & IFF_EXT_IFB;
++}
++
+ /* This device needs to keep skb dst for qdisc enqueue or ndo_start_xmit() */
+ static inline void netif_keep_dst(struct net_device *dev)
+ {
+--- a/net/ipv4/ip_gre.c
++++ b/net/ipv4/ip_gre.c
+@@ -828,7 +828,6 @@ static int ipgre_tunnel_ctl(struct net_d
+    It allows to construct virtual multiprotocol broadcast "LAN"
+    over the Internet, provided multicast routing is tuned.
+ 
+-
+    I have no idea was this bicycle invented before me,
+    so that I had to set ARPHRD_IPGRE to a random value.
+    I have an impression, that Cisco could make something similar,
+@@ -1337,6 +1336,7 @@ static void ipgre_tap_setup(struct net_d
+ 	dev->netdev_ops	= &gre_tap_netdev_ops;
+ 	dev->priv_flags &= ~IFF_TX_SKB_SHARING;
+ 	dev->priv_flags	|= IFF_LIVE_ADDR_CHANGE;
++	dev->priv_flags_ext	|= IFF_EXT_GRE_V4_TAP;
+ 	ip_tunnel_setup(dev, gre_tap_net_id);
+ }
+ 
+--- a/net/ipv6/ip6_gre.c
++++ b/net/ipv6/ip6_gre.c
+@@ -53,7 +53,6 @@
+ #include <net/erspan.h>
+ #include <net/dst_metadata.h>
+ 
+-
+ static bool log_ecn_error = true;
+ module_param(log_ecn_error, bool, 0644);
+ MODULE_PARM_DESC(log_ecn_error, "Log packets received with corrupted ECN");
+@@ -414,7 +413,6 @@ static void ip6gre_tunnel_uninit(struct
+ 	netdev_put(dev, &t->dev_tracker);
+ }
+ 
+-
+ static int ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
+ 		       u8 type, u8 code, int offset, __be32 info)
+ {
+@@ -1618,7 +1616,6 @@ static int __net_init ip6gre_init_net(st
+ 	 */
+ 	ign->fb_tunnel_dev->features |= NETIF_F_NETNS_LOCAL;
+ 
+-
+ 	ip6gre_fb_tunnel_init(ign->fb_tunnel_dev);
+ 	ign->fb_tunnel_dev->rtnl_link_ops = &ip6gre_link_ops;
+ 
+@@ -1941,6 +1938,7 @@ static void ip6gre_tap_setup(struct net_
+ 
+ 	dev->priv_flags &= ~IFF_TX_SKB_SHARING;
+ 	dev->priv_flags |= IFF_LIVE_ADDR_CHANGE;
++	dev->priv_flags_ext |= IFF_EXT_GRE_V6_TAP;
+ 	netif_keep_dst(dev);
+ }
+ 
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960225-net-Export-dev_shutdown.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,26 @@
+From cb26188380781e99501632228bd8c74710c49884 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Fri, 24 Apr 2020 10:59:16 -0700
+Subject: [PATCH 182/500] net: Export dev_shutdown()
+
+This API is needed by interface drivers to ensure qdiscs are destroyed
+before the NSS interfaces are destroyed. Since Linux destroys qdiscs
+only at unregister_netdevice(), it is too late for destroying any NSS
+qdiscs that may be configured on the interface.
+
+Change-Id: I66a6ec5b5393f9848ff1202e2753c738786c515f
+Signed-off-by: Shyam Sunder <ssunde@codeaurora.org>
+---
+ net/sched/sch_generic.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/net/sched/sch_generic.c
++++ b/net/sched/sch_generic.c
+@@ -1494,6 +1494,7 @@ void dev_shutdown(struct net_device *dev
+ 
+ 	WARN_ON(timer_pending(&dev->watchdog_timer));
+ }
++EXPORT_SYMBOL(dev_shutdown);
+ 
+ /**
+  * psched_ratecfg_precompute__() - Pre-compute values for reciprocal division
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960252-etherip-Enable-Etherip-protocol-number-97-in-linux.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,52 @@
+From 93059a8e8b34aa61b64851586a9ac22ffd05d3b4 Mon Sep 17 00:00:00 2001
+From: Suhas N Bhargav <quic_sbhargav@quicinc.com>
+Date: Tue, 27 Jun 2023 12:27:27 +0530
+Subject: [PATCH 312/500] etherip: Enable Etherip protocol number (97) in linux
+
+Change-Id: I59f8eefe9a53eb0ab77a3a8a912a7866f5c8c333
+Signed-off-by: Suhas N Bhargav <quic_sbhargav@quicinc.com>
+---
+ include/uapi/linux/in.h       | 4 +++-
+ tools/include/uapi/linux/in.h | 4 +++-
+ 2 files changed, 6 insertions(+), 2 deletions(-)
+
+--- a/include/uapi/linux/in.h
++++ b/include/uapi/linux/in.h
+@@ -63,6 +63,8 @@ enum {
+ #define IPPROTO_MTP		IPPROTO_MTP
+   IPPROTO_BEETPH = 94,		/* IP option pseudo header for BEET	*/
+ #define IPPROTO_BEETPH		IPPROTO_BEETPH
++  IPPROTO_ETHERIP = 97,		/* ETHERIP protocol number		*/
++#define IPPROTO_ETHERIP		IPPROTO_ETHERIP
+   IPPROTO_ENCAP = 98,		/* Encapsulation Header			*/
+ #define IPPROTO_ENCAP		IPPROTO_ENCAP
+   IPPROTO_PIM = 103,		/* Protocol Independent Multicast	*/
+@@ -327,7 +329,7 @@ struct sockaddr_in {
+ #endif
+ 
+ /* <asm/byteorder.h> contains the htonl type stuff.. */
+-#include <asm/byteorder.h> 
++#include <asm/byteorder.h>
+ 
+ 
+ #endif /* _UAPI_LINUX_IN_H */
+--- a/tools/include/uapi/linux/in.h
++++ b/tools/include/uapi/linux/in.h
+@@ -63,6 +63,8 @@ enum {
+ #define IPPROTO_MTP		IPPROTO_MTP
+   IPPROTO_BEETPH = 94,		/* IP option pseudo header for BEET	*/
+ #define IPPROTO_BEETPH		IPPROTO_BEETPH
++  IPPROTO_ETHERIP = 97,		/* ETHERIP protocol number		*/
++#define IPPROTO_ETHERIP		IPPROTO_ETHERIP
+   IPPROTO_ENCAP = 98,		/* Encapsulation Header			*/
+ #define IPPROTO_ENCAP		IPPROTO_ENCAP
+   IPPROTO_PIM = 103,		/* Protocol Independent Multicast	*/
+@@ -327,7 +329,7 @@ struct sockaddr_in {
+ #endif
+ 
+ /* <asm/byteorder.h> contains the htonl type stuff.. */
+-#include <asm/byteorder.h> 
++#include <asm/byteorder.h>
+ 
+ 
+ #endif /* _UAPI_LINUX_IN_H */
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960253-Revert-xfrm-remove-get_mtu-indirection-from-xfrm_typ.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,213 @@
+From dca631b8e4eee1615e4e2f541237064226bce65b Mon Sep 17 00:00:00 2001
+From: Pavithra R <quic_pavir@quicinc.com>
+Date: Tue, 6 Jun 2023 14:16:37 +0530
+Subject: [PATCH 277/500] Revert "xfrm: remove get_mtu indirection from
+ xfrm_type"
+
+This reverts commit c7b37c769d2a5e711106a3c793140a4f46768e04.
+
+Change-Id: Iaa8f93f1d311f21fc2d62a0609b1eb4b0bc3ef3a
+Signed-off-by: Neelansh Mittal <neelanshm@codeaurora.org>
+Signed-off-by: Pavithra R <quic_pavir@quicinc.com>
+---
+ include/net/xfrm.h     |  4 +++-
+ net/ipv4/esp4.c        | 27 ++++++++++++++++++++++++++-
+ net/ipv6/esp6.c        | 18 +++++++++++++++++-
+ net/xfrm/xfrm_device.c |  5 +++--
+ net/xfrm/xfrm_state.c  | 34 +++++-----------------------------
+ 5 files changed, 54 insertions(+), 34 deletions(-)
+
+--- a/include/net/xfrm.h
++++ b/include/net/xfrm.h
+@@ -433,6 +433,8 @@ struct xfrm_type {
+ 	int			(*output)(struct xfrm_state *, struct sk_buff *pskb);
+ 	int			(*reject)(struct xfrm_state *, struct sk_buff *,
+ 					  const struct flowi *);
++	/* Estimate maximal size of result of transformation of a dgram */
++	u32			(*get_mtu)(struct xfrm_state *, int size);
+ };
+ 
+ int xfrm_register_type(const struct xfrm_type *type, unsigned short family);
+@@ -1660,7 +1662,7 @@ void xfrm_sad_getinfo(struct net *net, s
+ void xfrm_spd_getinfo(struct net *net, struct xfrmk_spdinfo *si);
+ u32 xfrm_replay_seqhi(struct xfrm_state *x, __be32 net_seq);
+ int xfrm_init_replay(struct xfrm_state *x, struct netlink_ext_ack *extack);
+-u32 xfrm_state_mtu(struct xfrm_state *x, int mtu);
++int xfrm_state_mtu(struct xfrm_state *x, int mtu);
+ int __xfrm_init_state(struct xfrm_state *x, bool init_replay, bool offload,
+ 		      struct netlink_ext_ack *extack);
+ int xfrm_init_state(struct xfrm_state *x);
+--- a/net/ipv4/esp4.c
++++ b/net/ipv4/esp4.c
+@@ -35,6 +35,8 @@ struct esp_output_extra {
+ 
+ #define ESP_SKB_CB(__skb) ((struct esp_skb_cb *)&((__skb)->cb[0]))
+ 
++static u32 esp4_get_mtu(struct xfrm_state *x, int mtu);
++
+ /*
+  * Allocate an AEAD request structure with extra space for SG and IV.
+  *
+@@ -673,7 +675,7 @@ static int esp_output(struct xfrm_state
+ 		struct xfrm_dst *dst = (struct xfrm_dst *)skb_dst(skb);
+ 		u32 padto;
+ 
+-		padto = min(x->tfcpad, xfrm_state_mtu(x, dst->child_mtu_cached));
++		padto = min(x->tfcpad, esp4_get_mtu(x, dst->child_mtu_cached));
+ 		if (skb->len < padto)
+ 			esp.tfclen = padto - skb->len;
+ 	}
+@@ -967,6 +969,28 @@ out:
+ 	return err;
+ }
+ 
++static u32 esp4_get_mtu(struct xfrm_state *x, int mtu)
++{
++	struct crypto_aead *aead = x->data;
++	u32 blksize = ALIGN(crypto_aead_blocksize(aead), 4);
++	unsigned int net_adj;
++
++	switch (x->props.mode) {
++	case XFRM_MODE_TRANSPORT:
++	case XFRM_MODE_BEET:
++		net_adj = sizeof(struct iphdr);
++		break;
++	case XFRM_MODE_TUNNEL:
++		net_adj = 0;
++		break;
++	default:
++		BUG();
++	}
++
++	return ((mtu - x->props.header_len - crypto_aead_authsize(aead) -
++		 net_adj) & ~(blksize - 1)) + net_adj - 2;
++}
++
+ static int esp4_err(struct sk_buff *skb, u32 info)
+ {
+ 	struct net *net = dev_net(skb->dev);
+@@ -1211,6 +1235,7 @@ static const struct xfrm_type esp_type =
+ 	.flags		= XFRM_TYPE_REPLAY_PROT,
+ 	.init_state	= esp_init_state,
+ 	.destructor	= esp_destroy,
++	.get_mtu	= esp4_get_mtu,
+ 	.input		= esp_input,
+ 	.output		= esp_output,
+ };
+--- a/net/ipv6/esp6.c
++++ b/net/ipv6/esp6.c
+@@ -51,6 +51,8 @@ struct esp_output_extra {
+ 
+ #define ESP_SKB_CB(__skb) ((struct esp_skb_cb *)&((__skb)->cb[0]))
+ 
++static u32 esp6_get_mtu(struct xfrm_state *x, int mtu);
++
+ /*
+  * Allocate an AEAD request structure with extra space for SG and IV.
+  *
+@@ -711,7 +713,7 @@ static int esp6_output(struct xfrm_state
+ 		struct xfrm_dst *dst = (struct xfrm_dst *)skb_dst(skb);
+ 		u32 padto;
+ 
+-		padto = min(x->tfcpad, xfrm_state_mtu(x, dst->child_mtu_cached));
++		padto = min(x->tfcpad, esp6_get_mtu(x, dst->child_mtu_cached));
+ 		if (skb->len < padto)
+ 			esp.tfclen = padto - skb->len;
+ 	}
+@@ -1015,6 +1017,19 @@ out:
+ 	return ret;
+ }
+ 
++static u32 esp6_get_mtu(struct xfrm_state *x, int mtu)
++{
++	struct crypto_aead *aead = x->data;
++	u32 blksize = ALIGN(crypto_aead_blocksize(aead), 4);
++	unsigned int net_adj = 0;
++
++	if (x->props.mode != XFRM_MODE_TUNNEL)
++		net_adj = sizeof(struct ipv6hdr);
++
++	return ((mtu - x->props.header_len - crypto_aead_authsize(aead) -
++		 net_adj) & ~(blksize - 1)) + net_adj - 2;
++}
++
+ static int esp6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
+ 		    u8 type, u8 code, int offset, __be32 info)
+ {
+@@ -1263,6 +1278,7 @@ static const struct xfrm_type esp6_type
+ 	.flags		= XFRM_TYPE_REPLAY_PROT,
+ 	.init_state	= esp6_init_state,
+ 	.destructor	= esp6_destroy,
++	.get_mtu	= esp6_get_mtu,
+ 	.input		= esp6_input,
+ 	.output		= esp6_output,
+ };
+--- a/net/xfrm/xfrm_device.c
++++ b/net/xfrm/xfrm_device.c
+@@ -418,8 +418,9 @@ bool xfrm_dev_offload_ok(struct sk_buff
+ 
+ 	if (x->xso.type == XFRM_DEV_OFFLOAD_PACKET ||
+ 	    ((!dev || (dev == xfrm_dst_path(dst)->dev)) &&
+-	     !xdst->child->xfrm)) {
+-		mtu = xfrm_state_mtu(x, xdst->child_mtu_cached);
++	     !(xdst->child->xfrm && x->type->get_mtu))) {
++		mtu = x->type->get_mtu(x, xdst->child_mtu_cached);
++
+ 		if (skb->len <= mtu)
+ 			goto ok;
+ 
+--- a/net/xfrm/xfrm_state.c
++++ b/net/xfrm/xfrm_state.c
+@@ -28,8 +28,6 @@
+ #include <linux/interrupt.h>
+ #include <linux/kernel.h>
+ 
+-#include <crypto/aead.h>
+-
+ #include "xfrm_hash.h"
+ 
+ #define xfrm_state_deref_prot(table, net) \
+@@ -2798,38 +2796,16 @@ void xfrm_state_delete_tunnel(struct xfr
+ }
+ EXPORT_SYMBOL(xfrm_state_delete_tunnel);
+ 
+-u32 xfrm_state_mtu(struct xfrm_state *x, int mtu)
++int xfrm_state_mtu(struct xfrm_state *x, int mtu)
+ {
+ 	const struct xfrm_type *type = READ_ONCE(x->type);
+-	struct crypto_aead *aead;
+-	u32 blksize, net_adj = 0;
+-
+-	if (x->km.state != XFRM_STATE_VALID ||
+-	    !type || type->proto != IPPROTO_ESP)
+-		return mtu - x->props.header_len;
+-
+-	aead = x->data;
+-	blksize = ALIGN(crypto_aead_blocksize(aead), 4);
+ 
+-	switch (x->props.mode) {
+-	case XFRM_MODE_TRANSPORT:
+-	case XFRM_MODE_BEET:
+-		if (x->props.family == AF_INET)
+-			net_adj = sizeof(struct iphdr);
+-		else if (x->props.family == AF_INET6)
+-			net_adj = sizeof(struct ipv6hdr);
+-		break;
+-	case XFRM_MODE_TUNNEL:
+-		break;
+-	default:
+-		WARN_ON_ONCE(1);
+-		break;
+-	}
++	if (x->km.state == XFRM_STATE_VALID &&
++	    type && type->get_mtu)
++		return type->get_mtu(x, mtu);
+ 
+-	return ((mtu - x->props.header_len - crypto_aead_authsize(aead) -
+-		 net_adj) & ~(blksize - 1)) + net_adj - 2;
++	return mtu - x->props.header_len;
+ }
+-EXPORT_SYMBOL_GPL(xfrm_state_mtu);
+ 
+ int __xfrm_init_state(struct xfrm_state *x, bool init_replay, bool offload,
+ 		      struct netlink_ext_ack *extack)
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960255-net-Add-new-xfrm_state-xflag.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,25 @@
+From 80e1883dee774e4696dd8f88c8c86a513a618503 Mon Sep 17 00:00:00 2001
+From: Neelansh Mittal <neelanshm@codeaurora.org>
+Date: Sun, 29 Nov 2020 05:52:39 +0530
+Subject: [PATCH 278/500] net: Add new xfrm_state xflag
+
+New custom flag XFRM_STATE_OFFLOAD_NSS to identify
+xfrm states offloaded to the NSS
+
+Change-Id: Ib90a42fb9fd6818a6dfcb04e1ed35b4cfa6614c6
+Signed-off-by: Neelansh Mittal <neelanshm@codeaurora.org>
+Signed-off-by: Pavithra R <quic_pavir@quicinc.com>
+---
+ include/net/xfrm.h | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/include/net/xfrm.h
++++ b/include/net/xfrm.h
+@@ -302,6 +302,7 @@ static inline struct net *xs_net(struct
+ /* xflags - make enum if more show up */
+ #define XFRM_TIME_DEFER	1
+ #define XFRM_SOFT_EXPIRE 2
++#define XFRM_STATE_OFFLOAD_NSS 4
+ 
+ enum {
+ 	XFRM_STATE_VOID,
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960256-inet-Multicast-acceleration-support-for-6.6.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,691 @@
+From 6e90eaf9302012d7bc7f66bbb33e95bbd13c2b72 Mon Sep 17 00:00:00 2001
+From: Himanshu Joshi <himajosh@codeaurora.org>
+Date: Mon, 11 Apr 2016 19:28:47 +0530
+Subject: [PATCH 176/500] inet: Multicast acceleration support for 6.6
+
+Added APIs for IPv4/v6 Multicast acceleration for 6.1 kernel
+
+Change-Id: Iaa9182ed6643a59645f9b23b6ed53f9fccb3966a
+Signed-off-by: Shyam Sunder <ssunde@codeaurora.org>
+---
+ include/linux/mroute.h  |  38 +++++++
+ include/linux/mroute6.h |  41 +++++++
+ net/ipv4/ipmr.c         | 230 ++++++++++++++++++++++++++++++++++++++
+ net/ipv6/ip6mr.c        | 241 +++++++++++++++++++++++++++++++++++++++-
+ 4 files changed, 547 insertions(+), 3 deletions(-)
+
+--- a/include/linux/mroute.h
++++ b/include/linux/mroute.h
+@@ -92,4 +92,42 @@ struct rtmsg;
+ int ipmr_get_route(struct net *net, struct sk_buff *skb,
+ 		   __be32 saddr, __be32 daddr,
+ 		   struct rtmsg *rtm, u32 portid);
++
++#define IPMR_MFC_EVENT_UPDATE   1
++#define IPMR_MFC_EVENT_DELETE   2
++
++/*
++ * Callback to registered modules in the event of updates to a multicast group
++ */
++typedef void (*ipmr_mfc_event_offload_callback_t)(__be32 origin, __be32 group,
++						  u32 max_dest_dev,
++						  u32 dest_dev_idx[],
++						  u8 op);
++
++/*
++ * Register the callback used to inform offload modules when updates occur to
++ * MFC. The callback is registered by offload modules
++ */
++extern bool ipmr_register_mfc_event_offload_callback(
++			ipmr_mfc_event_offload_callback_t mfc_offload_cb);
++
++/*
++ * De-Register the callback used to inform offload modules when updates occur
++ * to MFC
++ */
++extern void ipmr_unregister_mfc_event_offload_callback(void);
++
++/*
++ * Find the destination interface list, given a multicast group and source
++ */
++extern int ipmr_find_mfc_entry(struct net *net, __be32 origin, __be32 group,
++				 u32 max_dst_cnt, u32 dest_dev[]);
++
++/*
++ * Out-of-band multicast statistics update for flows that are offloaded from
++ * Linux
++ */
++extern int ipmr_mfc_stats_update(struct net *net, __be32 origin, __be32 group,
++				 u64 pkts_in, u64 bytes_in,
++				 u64 pkts_out, u64 bytes_out);
+ #endif
+--- a/include/linux/mroute6.h
++++ b/include/linux/mroute6.h
+@@ -93,10 +93,51 @@ struct mfc6_cache {
+ 
+ #define MFC_ASSERT_THRESH (3*HZ)		/* Maximal freq. of asserts */
+ 
++#define IP6MR_MFC_EVENT_UPDATE   1
++#define IP6MR_MFC_EVENT_DELETE   2
++
+ struct rtmsg;
+ extern int ip6mr_get_route(struct net *net, struct sk_buff *skb,
+ 			   struct rtmsg *rtm, u32 portid);
+ 
++/*
++ * Callback to registered modules in the event of updates to a multicast group
++ */
++typedef void (*ip6mr_mfc_event_offload_callback_t)(struct in6_addr *origin,
++						   struct in6_addr *group,
++						   u32 max_dest_dev,
++						   u32 dest_dev_idx[],
++						   uint8_t op);
++
++/*
++ * Register the callback used to inform offload modules when updates occur
++ * to MFC. The callback is registered by offload modules
++ */
++extern bool ip6mr_register_mfc_event_offload_callback(
++			ip6mr_mfc_event_offload_callback_t mfc_offload_cb);
++
++/*
++ * De-Register the callback used to inform offload modules when updates occur
++ * to MFC
++ */
++extern void ip6mr_unregister_mfc_event_offload_callback(void);
++
++/*
++ * Find the destination interface list given a multicast group and source
++ */
++extern int ip6mr_find_mfc_entry(struct net *net, struct in6_addr *origin,
++				struct in6_addr *group, u32 max_dst_cnt,
++				u32 dest_dev[]);
++
++/*
++ * Out-of-band multicast statistics update for flows that are offloaded from
++ * Linux
++ */
++extern int ip6mr_mfc_stats_update(struct net *net, struct in6_addr *origin,
++				  struct in6_addr *group, uint64_t pkts_in,
++				  uint64_t bytes_in, uint64_t pkts_out,
++				  uint64_t bytes_out);
++
+ #ifdef CONFIG_IPV6_MROUTE
+ bool mroute6_is_socket(struct net *net, struct sk_buff *skb);
+ extern int ip6mr_sk_done(struct sock *sk);
+--- a/net/ipv4/ipmr.c
++++ b/net/ipv4/ipmr.c
+@@ -89,6 +89,9 @@ static struct net_device *vif_dev_read(c
+ /* Special spinlock for queue of unresolved entries */
+ static DEFINE_SPINLOCK(mfc_unres_lock);
+ 
++/* spinlock for offload */
++static DEFINE_SPINLOCK(lock);
++
+ /* We return to original Alan's scheme. Hash table of resolved
+  * entries is changed only in process context and protected
+  * with weak lock mrt_lock. Queue of unresolved entries is protected
+@@ -112,6 +115,9 @@ static void mroute_netlink_event(struct
+ static void igmpmsg_netlink_event(const struct mr_table *mrt, struct sk_buff *pkt);
+ static void mroute_clean_tables(struct mr_table *mrt, int flags);
+ static void ipmr_expire_process(struct timer_list *t);
++static struct mfc_cache *ipmr_cache_find(struct mr_table *mrt, __be32 origin,
++					 __be32 mcastgrp);
++static ipmr_mfc_event_offload_callback_t __rcu ipmr_mfc_event_offload_callback;
+ 
+ #ifdef CONFIG_IP_MROUTE_MULTIPLE_TABLES
+ #define ipmr_for_each_table(mrt, net)					\
+@@ -223,6 +229,78 @@ static int ipmr_rule_fill(struct fib_rul
+ 	return 0;
+ }
+ 
++/* ipmr_sync_entry_update()
++ * Call the registered offload callback to report an update to a multicast
++ * route entry. The callback receives the list of destination interfaces and
++ * the interface count
++ */
++static void ipmr_sync_entry_update(struct mr_table *mrt,
++				   struct mfc_cache *cache)
++{
++	int vifi, dest_if_count = 0;
++	u32 dest_dev[MAXVIFS];
++	__be32  origin;
++	__be32  group;
++	ipmr_mfc_event_offload_callback_t offload_update_cb_f;
++
++	memset(dest_dev, 0, sizeof(dest_dev));
++
++	origin = cache->mfc_origin;
++	group = cache->mfc_mcastgrp;
++
++	spin_lock(&mrt_lock);
++	for (vifi = 0; vifi < cache->_c.mfc_un.res.maxvif; vifi++) {
++		if (!((cache->_c.mfc_un.res.ttls[vifi] > 0) &&
++		      (cache->_c.mfc_un.res.ttls[vifi] < 255))) {
++			continue;
++		}
++		if (dest_if_count == MAXVIFS) {
++			spin_unlock(&mrt_lock);
++			return;
++		}
++
++		if (!VIF_EXISTS(mrt, vifi)) {
++			spin_unlock(&mrt_lock);
++			return;
++		}
++		dest_dev[dest_if_count] = mrt->vif_table[vifi].dev->ifindex;
++		dest_if_count++;
++	}
++	spin_unlock(&mrt_lock);
++
++	rcu_read_lock();
++	offload_update_cb_f = rcu_dereference(ipmr_mfc_event_offload_callback);
++
++	if (!offload_update_cb_f) {
++		rcu_read_unlock();
++		return;
++	}
++
++	offload_update_cb_f(group, origin, dest_if_count, dest_dev,
++			    IPMR_MFC_EVENT_UPDATE);
++	rcu_read_unlock();
++}
++
++/* ipmr_sync_entry_delete()
++ * Call the registered offload callback to inform of a multicast route entry
++ * delete event
++ */
++static void ipmr_sync_entry_delete(u32 origin, u32 group)
++{
++	ipmr_mfc_event_offload_callback_t offload_update_cb_f;
++
++	rcu_read_lock();
++	offload_update_cb_f = rcu_dereference(ipmr_mfc_event_offload_callback);
++
++	if (!offload_update_cb_f) {
++		rcu_read_unlock();
++		return;
++	}
++
++	offload_update_cb_f(group, origin, 0, NULL, IPMR_MFC_EVENT_DELETE);
++	rcu_read_unlock();
++}
++
+ static const struct fib_rules_ops __net_initconst ipmr_rules_ops_template = {
+ 	.family		= RTNL_FAMILY_IPMR,
+ 	.rule_size	= sizeof(struct ipmr_rule),
+@@ -236,6 +314,154 @@ static const struct fib_rules_ops __net_
+ 	.owner		= THIS_MODULE,
+ };
+ 
++/* ipmr_register_mfc_event_offload_callback()
++ * Register the IPv4 Multicast update offload callback with IPMR
++ */
++bool ipmr_register_mfc_event_offload_callback(
++		ipmr_mfc_event_offload_callback_t mfc_offload_cb)
++{
++	ipmr_mfc_event_offload_callback_t offload_update_cb_f;
++
++	rcu_read_lock();
++	offload_update_cb_f = rcu_dereference(ipmr_mfc_event_offload_callback);
++
++	if (offload_update_cb_f) {
++		rcu_read_unlock();
++		return false;
++	}
++	rcu_read_unlock();
++
++	spin_lock(&lock);
++	rcu_assign_pointer(ipmr_mfc_event_offload_callback, mfc_offload_cb);
++	spin_unlock(&lock);
++	synchronize_rcu();
++	return true;
++}
++EXPORT_SYMBOL(ipmr_register_mfc_event_offload_callback);
++
++/* ipmr_unregister_mfc_event_offload_callback()
++ * De-register the IPv4 Multicast update offload callback with IPMR
++ */
++void ipmr_unregister_mfc_event_offload_callback(void)
++{
++	spin_lock(&lock);
++	rcu_assign_pointer(ipmr_mfc_event_offload_callback, NULL);
++	spin_unlock(&lock);
++	synchronize_rcu();
++}
++EXPORT_SYMBOL(ipmr_unregister_mfc_event_offload_callback);
++
++/* ipmr_find_mfc_entry()
++ * Returns destination interface list for a particular multicast flow, and
++ * the number of interfaces in the list
++ */
++int ipmr_find_mfc_entry(struct net *net, __be32 origin, __be32 group,
++			u32 max_dest_cnt, u32 dest_dev[])
++{
++	int vifi, dest_if_count = 0;
++	struct mr_table *mrt;
++	struct mfc_cache *cache;
++
++	mrt = ipmr_get_table(net, RT_TABLE_DEFAULT);
++	if (!mrt)
++		return -ENOENT;
++
++	rcu_read_lock();
++	cache = ipmr_cache_find(mrt, origin, group);
++	if (!cache) {
++		rcu_read_unlock();
++		return -ENOENT;
++	}
++
++	spin_lock(&mrt_lock);
++	for (vifi = 0; vifi < cache->_c.mfc_un.res.maxvif; vifi++) {
++		if (!((cache->_c.mfc_un.res.ttls[vifi] > 0) &&
++		      (cache->_c.mfc_un.res.ttls[vifi] < 255))) {
++			continue;
++		}
++
++		/* We have another valid destination interface entry. Check if
++		 * the number of the destination interfaces for the route is
++		 * exceeding the size of the array given to us
++		 */
++		if (dest_if_count == max_dest_cnt) {
++			spin_unlock(&mrt_lock);
++			rcu_read_unlock();
++			return -EINVAL;
++		}
++
++		if (!VIF_EXISTS(mrt, vifi)) {
++			spin_unlock(&mrt_lock);
++			rcu_read_unlock();
++			return -EINVAL;
++		}
++
++		dest_dev[dest_if_count] = mrt->vif_table[vifi].dev->ifindex;
++		dest_if_count++;
++	}
++	spin_unlock(&mrt_lock);
++	rcu_read_unlock();
++
++	return dest_if_count;
++}
++EXPORT_SYMBOL(ipmr_find_mfc_entry);
++
++/* ipmr_mfc_stats_update()
++ * Update the MFC/VIF statistics for offloaded flows
++ */
++int ipmr_mfc_stats_update(struct net *net, __be32 origin, __be32 group,
++			  u64 pkts_in, u64 bytes_in,
++			  u64 pkts_out, u64 bytes_out)
++{
++	int vif, vifi;
++	struct mr_table *mrt;
++	struct mfc_cache *cache;
++
++	mrt = ipmr_get_table(net, RT_TABLE_DEFAULT);
++	if (!mrt)
++		return -ENOENT;
++
++	rcu_read_lock();
++	cache = ipmr_cache_find(mrt, origin, group);
++	if (!cache) {
++		rcu_read_unlock();
++		return -ENOENT;
++	}
++
++	vif = cache->_c.mfc_parent;
++
++	spin_lock(&mrt_lock);
++	if (!VIF_EXISTS(mrt, vif)) {
++		spin_unlock(&mrt_lock);
++		rcu_read_unlock();
++		return -EINVAL;
++	}
++
++	mrt->vif_table[vif].pkt_in += pkts_in;
++	mrt->vif_table[vif].bytes_in += bytes_in;
++	cache->_c.mfc_un.res.pkt  += pkts_out;
++	cache->_c.mfc_un.res.bytes += bytes_out;
++
++	for (vifi = cache->_c.mfc_un.res.minvif;
++			vifi < cache->_c.mfc_un.res.maxvif; vifi++) {
++		if ((cache->_c.mfc_un.res.ttls[vifi] > 0) &&
++		    (cache->_c.mfc_un.res.ttls[vifi] < 255)) {
++			if (!VIF_EXISTS(mrt, vifi)) {
++				spin_unlock(&mrt_lock);
++				rcu_read_unlock();
++				return -EINVAL;
++			}
++			mrt->vif_table[vifi].pkt_out += pkts_out;
++			mrt->vif_table[vifi].bytes_out += bytes_out;
++		}
++	}
++	spin_unlock(&mrt_lock);
++	rcu_read_unlock();
++
++	return 0;
++}
++EXPORT_SYMBOL(ipmr_mfc_stats_update);
++
+ static int __net_init ipmr_rules_init(struct net *net)
+ {
+ 	struct fib_rules_ops *ops;
+@@ -1191,6 +1417,8 @@ static int ipmr_mfc_delete(struct mr_tab
+ 	call_ipmr_mfc_entry_notifiers(net, FIB_EVENT_ENTRY_DEL, c, mrt->id);
+ 	mroute_netlink_event(mrt, c, RTM_DELROUTE);
+ 	mr_cache_put(&c->_c);
++	/* Inform offload modules of the delete event */
++	ipmr_sync_entry_delete(c->mfc_origin, c->mfc_mcastgrp);
+ 
+ 	return 0;
+ }
+@@ -1221,6 +1449,8 @@ static int ipmr_mfc_add(struct net *net,
+ 		call_ipmr_mfc_entry_notifiers(net, FIB_EVENT_ENTRY_REPLACE, c,
+ 					      mrt->id);
+ 		mroute_netlink_event(mrt, c, RTM_NEWROUTE);
++		/* Inform offload modules of the update event */
++		ipmr_sync_entry_update(mrt, c);
+ 		return 0;
+ 	}
+ 
+--- a/net/ipv6/ip6mr.c
++++ b/net/ipv6/ip6mr.c
+@@ -74,6 +74,9 @@ static struct net_device *vif_dev_read(c
+ /* Special spinlock for queue of unresolved entries */
+ static DEFINE_SPINLOCK(mfc_unres_lock);
+ 
++/* Spinlock for offload */
++static DEFINE_SPINLOCK(lock);
++
+ /* We return to original Alan's scheme. Hash table of resolved
+    entries is changed only in process context and protected
+    with weak lock mrt_lock. Queue of unresolved entries is protected
+@@ -101,12 +104,15 @@ static int ip6mr_rtm_dumproute(struct sk
+ 			       struct netlink_callback *cb);
+ static void mroute_clean_tables(struct mr_table *mrt, int flags);
+ static void ipmr_expire_process(struct timer_list *t);
++static struct mfc6_cache *ip6mr_cache_find(struct mr_table *mrt,
++					   const struct in6_addr *origin,
++					   const struct in6_addr *mcastgrp);
++static ip6mr_mfc_event_offload_callback_t __rcu
++				ip6mr_mfc_event_offload_callback;
+ 
+ #ifdef CONFIG_IPV6_MROUTE_MULTIPLE_TABLES
+ #define ip6mr_for_each_table(mrt, net) \
+-	list_for_each_entry_rcu(mrt, &net->ipv6.mr6_tables, list, \
+-				lockdep_rtnl_is_held() || \
+-				list_empty(&net->ipv6.mr6_tables))
++	list_for_each_entry_rcu(mrt, &net->ipv6.mr6_tables, list)
+ 
+ static struct mr_table *ip6mr_mr_table_iter(struct net *net,
+ 					    struct mr_table *mrt)
+@@ -375,6 +381,82 @@ static struct mfc6_cache_cmp_arg ip6mr_m
+ 	.mf6c_mcastgrp = IN6ADDR_ANY_INIT,
+ };
+ 
++/* ip6mr_sync_entry_update()
++ * Call the registered offload callback to report an update to a multicast
++ * route entry. The callback receives the list of destination interfaces and
++ * the interface count
++ */
++static void ip6mr_sync_entry_update(struct mr_table *mrt,
++				    struct mfc6_cache *cache)
++{
++	int vifi, dest_if_count = 0;
++	u32 dest_dev[MAXMIFS];
++	struct in6_addr mc_origin, mc_group;
++	ip6mr_mfc_event_offload_callback_t offload_update_cb_f;
++
++	memset(dest_dev, 0, sizeof(dest_dev));
++
++	spin_lock(&mrt_lock);
++
++	for (vifi = 0; vifi < cache->_c.mfc_un.res.maxvif; vifi++) {
++		if (!((cache->_c.mfc_un.res.ttls[vifi] > 0) &&
++		      (cache->_c.mfc_un.res.ttls[vifi] < 255))) {
++			continue;
++		}
++
++		if (dest_if_count == MAXMIFS) {
++			spin_unlock(&mrt_lock);
++			return;
++		}
++
++		if (!VIF_EXISTS(mrt, vifi)) {
++			spin_unlock(&mrt_lock);
++			return;
++		}
++
++		dest_dev[dest_if_count] = mrt->vif_table[vifi].dev->ifindex;
++		dest_if_count++;
++	}
++
++	memcpy(&mc_origin, &cache->mf6c_origin, sizeof(struct in6_addr));
++	memcpy(&mc_group, &cache->mf6c_mcastgrp, sizeof(struct in6_addr));
++	spin_unlock(&mrt_lock);
++
++	rcu_read_lock();
++	offload_update_cb_f = rcu_dereference(ip6mr_mfc_event_offload_callback);
++
++	if (!offload_update_cb_f) {
++		rcu_read_unlock();
++		return;
++	}
++
++	offload_update_cb_f(&mc_group, &mc_origin, dest_if_count, dest_dev,
++			    IP6MR_MFC_EVENT_UPDATE);
++	rcu_read_unlock();
++}
++
++/* ip6mr_sync_entry_delete()
++ * Call the registered offload callback to inform of a multicast route entry
++ * delete event
++ */
++static void ip6mr_sync_entry_delete(struct in6_addr *mc_origin,
++				    struct in6_addr *mc_group)
++{
++	ip6mr_mfc_event_offload_callback_t offload_update_cb_f;
++
++	rcu_read_lock();
++	offload_update_cb_f = rcu_dereference(ip6mr_mfc_event_offload_callback);
++
++	if (!offload_update_cb_f) {
++		rcu_read_unlock();
++		return;
++	}
++
++	offload_update_cb_f(mc_group, mc_origin, 0, NULL,
++			    IP6MR_MFC_EVENT_DELETE);
++	rcu_read_unlock();
++}
++
+ static struct mr_table_ops ip6mr_mr_table_ops = {
+ 	.rht_params = &ip6mr_rht_params,
+ 	.cmparg_any = &ip6mr_mr_table_ops_cmparg_any,
+@@ -697,6 +779,149 @@ static int call_ip6mr_mfc_entry_notifier
+ 				     &mfc->_c, tb_id, &net->ipv6.ipmr_seq);
+ }
+ 
++/* ip6mr_register_mfc_event_offload_callback()
++ * Register the IPv6 multicast update callback for offload modules
++ */
++bool ip6mr_register_mfc_event_offload_callback(
++		ip6mr_mfc_event_offload_callback_t mfc_offload_cb)
++{
++	ip6mr_mfc_event_offload_callback_t offload_update_cb_f;
++
++	rcu_read_lock();
++	offload_update_cb_f = rcu_dereference(ip6mr_mfc_event_offload_callback);
++
++	if (offload_update_cb_f) {
++		rcu_read_unlock();
++		return false;
++	}
++	rcu_read_unlock();
++
++	spin_lock(&lock);
++	rcu_assign_pointer(ip6mr_mfc_event_offload_callback, mfc_offload_cb);
++	spin_unlock(&lock);
++	synchronize_rcu();
++	return true;
++}
++EXPORT_SYMBOL(ip6mr_register_mfc_event_offload_callback);
++
++/* ip6mr_unregister_mfc_event_offload_callback()
++ * De-register the IPv6 multicast update callback for offload modules
++ */
++void ip6mr_unregister_mfc_event_offload_callback(void)
++{
++	spin_lock(&lock);
++	rcu_assign_pointer(ip6mr_mfc_event_offload_callback, NULL);
++	spin_unlock(&lock);
++	synchronize_rcu();
++}
++EXPORT_SYMBOL(ip6mr_unregister_mfc_event_offload_callback);
++
++/* ip6mr_find_mfc_entry()
++ * Return the destination interface list for a particular multicast flow, and
++ * the number of interfaces in the list
++ */
++int ip6mr_find_mfc_entry(struct net *net, struct in6_addr *origin,
++			 struct in6_addr *group, u32 max_dest_cnt,
++			 u32 dest_dev[])
++{
++	int vifi, dest_if_count = 0;
++	struct mr_table *mrt;
++	struct mfc6_cache *cache;
++
++	mrt = ip6mr_get_table(net, RT6_TABLE_DFLT);
++	if (!mrt)
++		return -ENOENT;
++
++	spin_lock(&mrt_lock);
++	cache = ip6mr_cache_find(mrt, origin, group);
++	if (!cache) {
++		spin_unlock(&mrt_lock);
++		return -ENOENT;
++	}
++
++	for (vifi = 0; vifi < cache->_c.mfc_un.res.maxvif; vifi++) {
++		if (!((cache->_c.mfc_un.res.ttls[vifi] > 0) &&
++		      (cache->_c.mfc_un.res.ttls[vifi] < 255))) {
++			continue;
++		}
++
++		/* We have another valid destination interface entry. Check if
++		 * the number of the destination interfaces for the route is
++		 * exceeding the size of the array given to us
++		 */
++		if (dest_if_count == max_dest_cnt) {
++			spin_unlock(&mrt_lock);
++			return -EINVAL;
++		}
++
++		if (!VIF_EXISTS(mrt, vifi)) {
++			spin_unlock(&mrt_lock);
++			return -EINVAL;
++		}
++
++		dest_dev[dest_if_count] = mrt->vif_table[vifi].dev->ifindex;
++		dest_if_count++;
++	}
++	spin_unlock(&mrt_lock);
++
++	return dest_if_count;
++}
++EXPORT_SYMBOL(ip6mr_find_mfc_entry);
++
++/* ip6mr_mfc_stats_update()
++ * Update the MFC/VIF statistics for offloaded flows
++ */
++int ip6mr_mfc_stats_update(struct net *net, struct in6_addr *origin,
++			   struct in6_addr *group, u64 pkts_in,
++			   u64 bytes_in, uint64_t pkts_out,
++			   u64 bytes_out)
++{
++	int vif, vifi;
++	struct mr_table *mrt;
++	struct mfc6_cache *cache;
++
++	mrt = ip6mr_get_table(net, RT6_TABLE_DFLT);
++
++	if (!mrt)
++		return -ENOENT;
++
++	spin_lock(&mrt_lock);
++	cache = ip6mr_cache_find(mrt, origin, group);
++	if (!cache) {
++		spin_unlock(&mrt_lock);
++		return -ENOENT;
++	}
++
++	vif = cache->_c.mfc_parent;
++
++	if (!VIF_EXISTS(mrt, vif)) {
++		spin_unlock(&mrt_lock);
++		return -EINVAL;
++	}
++
++	mrt->vif_table[vif].pkt_in += pkts_in;
++	mrt->vif_table[vif].bytes_in += bytes_in;
++	cache->_c.mfc_un.res.pkt += pkts_out;
++	cache->_c.mfc_un.res.bytes += bytes_out;
++
++	for (vifi = cache->_c.mfc_un.res.minvif;
++			vifi < cache->_c.mfc_un.res.maxvif; vifi++) {
++		if ((cache->_c.mfc_un.res.ttls[vifi] > 0) &&
++		    (cache->_c.mfc_un.res.ttls[vifi] < 255)) {
++			if (!VIF_EXISTS(mrt, vifi)) {
++				spin_unlock(&mrt_lock);
++				return -EINVAL;
++			}
++			mrt->vif_table[vifi].pkt_out += pkts_out;
++			mrt->vif_table[vifi].bytes_out += bytes_out;
++		}
++	}
++
++	spin_unlock(&mrt_lock);
++	return 0;
++}
++EXPORT_SYMBOL(ip6mr_mfc_stats_update);
++
+ /* Delete a VIF entry */
+ static int mif6_delete(struct mr_table *mrt, int vifi, int notify,
+ 		       struct list_head *head)
+@@ -1221,6 +1446,7 @@ static int ip6mr_mfc_delete(struct mr_ta
+ 			    int parent)
+ {
+ 	struct mfc6_cache *c;
++	struct in6_addr mc_origin, mc_group;
+ 
+ 	/* The entries are added/deleted only under RTNL */
+ 	rcu_read_lock();
+@@ -1229,6 +1455,9 @@ static int ip6mr_mfc_delete(struct mr_ta
+ 	rcu_read_unlock();
+ 	if (!c)
+ 		return -ENOENT;
++
++	memcpy(&mc_origin, &c->mf6c_origin, sizeof(struct in6_addr));
++	memcpy(&mc_group, &c->mf6c_mcastgrp, sizeof(struct in6_addr));
+ 	rhltable_remove(&mrt->mfc_hash, &c->_c.mnode, ip6mr_rht_params);
+ 	list_del_rcu(&c->_c.list);
+ 
+@@ -1236,6 +1465,9 @@ static int ip6mr_mfc_delete(struct mr_ta
+ 				       FIB_EVENT_ENTRY_DEL, c, mrt->id);
+ 	mr6_netlink_event(mrt, c, RTM_DELROUTE);
+ 	mr_cache_put(&c->_c);
++	/* Inform offload modules of the delete event */
++	ip6mr_sync_entry_delete(&mc_origin, &mc_group);
++
+ 	return 0;
+ }
+ 
+@@ -1457,6 +1689,9 @@ static int ip6mr_mfc_add(struct net *net
+ 		call_ip6mr_mfc_entry_notifiers(net, FIB_EVENT_ENTRY_REPLACE,
+ 					       c, mrt->id);
+ 		mr6_netlink_event(mrt, c, RTM_NEWROUTE);
++
++		/* Inform offload modules of the update event */
++		ip6mr_sync_entry_update(mrt, c);
+ 		return 0;
+ 	}
+ 
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960257-linux-fix-icmp-of-ipip6-tunnel-not-working-issue.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,39 @@
+From 82010950651b3225d6bc16c2c8b1929ad958e40e Mon Sep 17 00:00:00 2001
+From: Ken Zhu <quic_guigenz@quicinc.com>
+Date: Tue, 20 Jun 2023 13:16:31 -0700
+Subject: [PATCH 316/500] linux: fix icmp of ipip6 tunnel not working issue
+
+It should use address of the header instead of the address of point
+of the address of header
+
+Change-Id: I2c183c80c2cb0e0b41c933d2548919f4c3a34baa
+Signed-off-by: Zhu Ken <guigenz@codeaurora.org>
+Signed-off-by: John Sanli <quic_jsanli@quicinc.com>
+---
+ net/ipv6/ip6_tunnel.c | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+--- a/net/ipv6/ip6_tunnel.c
++++ b/net/ipv6/ip6_tunnel.c
+@@ -849,7 +849,7 @@ static void ip4ip6_fmr_calc(struct in6_a
+ 	use_dest_addr = (xmit && dsth == iph) || (!xmit && dsth != iph);
+ 
+ 	/* get dst port */
+-	if (((u8*)&dsth[1]) <= end && (
++	if (((u8 *)&dsth[1]) <= end && (
+ 		dsth->protocol == IPPROTO_UDP ||
+ 		dsth->protocol == IPPROTO_TCP ||
+ 		dsth->protocol == IPPROTO_SCTP ||
+@@ -864,9 +864,9 @@ static void ip4ip6_fmr_calc(struct in6_a
+ 		struct icmphdr *ih = (struct icmphdr*)(((u8*)dsth) + dsth->ihl * 4);
+ 
+ 		/* use icmp identifier as port */
+-		if (((u8*)&ih) <= end && (
+-		    (use_dest_addr && (
+-		    ih->type == ICMP_ECHOREPLY ||
++		if (((u8 *)ih) <= end && (
++			(use_dest_addr && (
++			ih->type == ICMP_ECHOREPLY ||
+ 			ih->type == ICMP_TIMESTAMPREPLY ||
+ 			ih->type == ICMP_INFO_REPLY ||
+ 			ih->type == ICMP_ADDRESSREPLY)) ||
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960258-openvswitch-Add-support-for-OVS-DP-acceleration.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,476 @@
+From 4ba8a046ad965f87067ed856aa18db73c827a07e Mon Sep 17 00:00:00 2001
+From: Ratheesh Kannoth <rkannoth@codeaurora.org>
+Date: Tue, 30 Jun 2020 11:20:02 +0530
+Subject: [PATCH 276/500] openvswitch: Add support for OVS DP acceleration
+
+ This patch will allow inline datapath accelerator
+ to register for bridge notifications and packet
+ processing callbacks
+
+Change-Id: If69faec1abafa7a6cc54835a60c16bb4bd789275
+Signed-off-by: Pavithra R <quic_pavir@quicinc.com>
+---
+ include/uapi/linux/openvswitch.h |   2 +-
+ net/openvswitch/datapath.c       | 291 ++++++++++++++++++++++++++++++-
+ net/openvswitch/datapath.h       |  41 +++++
+ 3 files changed, 332 insertions(+), 2 deletions(-)
+
+--- a/include/uapi/linux/openvswitch.h
++++ b/include/uapi/linux/openvswitch.h
+@@ -278,6 +278,7 @@ enum ovs_vport_attr {
+ 	OVS_VPORT_ATTR_IFINDEX,
+ 	OVS_VPORT_ATTR_NETNSID,
+ 	OVS_VPORT_ATTR_UPCALL_STATS,
++	OVS_VPORT_ATTR_MASTER,	/* Master device for this vport, device name */
+ 	__OVS_VPORT_ATTR_MAX
+ };
+ 
+@@ -304,7 +305,6 @@ enum {
+ 
+ #define OVS_VXLAN_EXT_MAX (__OVS_VXLAN_EXT_MAX - 1)
+ 
+-
+ /* OVS_VPORT_ATTR_OPTIONS attributes for tunnels.
+  */
+ enum {
+--- a/net/openvswitch/datapath.c
++++ b/net/openvswitch/datapath.c
+@@ -51,6 +51,7 @@
+ #include "vport-netdev.h"
+ 
+ unsigned int ovs_net_id __read_mostly;
++static struct ovs_accel_callback *ovs_accel_cb;
+ 
+ static struct genl_family dp_packet_genl_family;
+ static struct genl_family dp_flow_genl_family;
+@@ -242,6 +243,126 @@ void ovs_dp_detach_port(struct vport *p)
+ 	ovs_vport_del(p);
+ }
+ 
++/* Notify datapath add event to acceleration callback */
++static void ovs_dp_add_notify(struct datapath *dp, struct vport *vp)
++{
++	struct ovs_accel_callback *ovs_cb;
++
++	rcu_read_lock();
++	ovs_cb = rcu_dereference(ovs_accel_cb);
++	if (ovs_cb && ovs_cb->ovs_accel_dp_add)
++		ovs_cb->ovs_accel_dp_add((void *)dp, vp->dev);
++	rcu_read_unlock();
++}
++
++/* Notify datapath delete event to acceleration callback */
++static void ovs_dp_del_notify(struct datapath *dp, struct vport *vp)
++{
++	struct ovs_accel_callback *ovs_cb;
++
++	rcu_read_lock();
++	ovs_cb = rcu_dereference(ovs_accel_cb);
++	if (ovs_cb && ovs_cb->ovs_accel_dp_del)
++		ovs_cb->ovs_accel_dp_del((void *)dp, vp->dev);
++	rcu_read_unlock();
++}
++
++/* Notify datapath port add event to acceleration callback */
++static void ovs_dp_port_add_notify(struct datapath *dp, struct vport *vp,
++				   struct nlattr **a)
++{
++	struct ovs_accel_callback *ovs_cb;
++	const char *master = NULL;
++
++	if (a[OVS_VPORT_ATTR_MASTER])
++		master = nla_data(a[OVS_VPORT_ATTR_MASTER]);
++
++	rcu_read_lock();
++	ovs_cb = rcu_dereference(ovs_accel_cb);
++	if (ovs_cb && ovs_cb->ovs_accel_dp_port_add)
++		ovs_cb->ovs_accel_dp_port_add((void *)dp, (void *)vp,
++					      vp->port_no, vp->ops->type,
++					      master, vp->dev);
++	rcu_read_unlock();
++}
++
++/* Notify datapath port delete event to acceleration callback */
++static void ovs_dp_port_del_notify(struct datapath *dp, struct vport *vp)
++{
++	struct ovs_accel_callback *ovs_cb;
++
++	rcu_read_lock();
++	ovs_cb = rcu_dereference(ovs_accel_cb);
++	if (ovs_cb && ovs_cb->ovs_accel_dp_port_del)
++		ovs_cb->ovs_accel_dp_port_del((void *)dp, (void *)vp, vp->dev);
++	rcu_read_unlock();
++}
++
++/* Notify datapath flow add event to acceleration callback */
++static void ovs_dp_flow_add_notify(struct datapath *dp, struct sw_flow *sf)
++{
++	struct ovs_accel_callback *ovs_cb;
++
++	rcu_read_lock();
++	ovs_cb = rcu_dereference(ovs_accel_cb);
++	if (ovs_cb && ovs_cb->ovs_accel_dp_flow_add)
++		ovs_cb->ovs_accel_dp_flow_add((void *)dp, sf);
++	rcu_read_unlock();
++}
++
++/* Notify datapath flow delete event to acceleration callback */
++static void ovs_dp_flow_del_notify(struct datapath *dp, struct sw_flow *sf)
++{
++	struct ovs_accel_callback *ovs_cb;
++
++	rcu_read_lock();
++	ovs_cb = rcu_dereference(ovs_accel_cb);
++	if (ovs_cb && ovs_cb->ovs_accel_dp_flow_del)
++		ovs_cb->ovs_accel_dp_flow_del((void *)dp, sf);
++	rcu_read_unlock();
++}
++
++/* Notify datapath flow table flush event to acceleration callback */
++static void ovs_dp_flow_tbl_flush_notify(struct datapath *dp)
++{
++	struct ovs_accel_callback *ovs_cb;
++
++	rcu_read_lock();
++	ovs_cb = rcu_dereference(ovs_accel_cb);
++	if (ovs_cb && ovs_cb->ovs_accel_dp_flow_tbl_flush)
++		ovs_cb->ovs_accel_dp_flow_tbl_flush((void *)dp);
++	rcu_read_unlock();
++}
++
++/* Notify datapath flow set/change event to acceleration callback */
++static void ovs_dp_flow_set_notify(struct datapath *dp, struct sw_flow *sf,
++				   struct sw_flow_actions *new_sfa)
++{
++	struct ovs_accel_callback *ovs_cb;
++
++	rcu_read_lock();
++	ovs_cb = rcu_dereference(ovs_accel_cb);
++	if (ovs_cb && ovs_cb->ovs_accel_dp_flow_set)
++		ovs_cb->ovs_accel_dp_flow_set((void *)dp, sf, new_sfa);
++	rcu_read_unlock();
++}
++
++/* Forward datapath packet to acceleration callback
++ * Must be called with rcu_read_lock.
++ */
++static void ovs_dp_pkt_process_notify(struct datapath *dp, struct sk_buff *skb,
++				      struct sw_flow_key *key, struct sw_flow *sf,
++		struct sw_flow_actions *sfa)
++{
++	struct ovs_accel_callback *ovs_cb;
++
++	WARN_ON(!rcu_read_lock_held());
++
++	ovs_cb = rcu_dereference(ovs_accel_cb);
++	if (ovs_cb && ovs_cb->ovs_accel_dp_pkt_process)
++		ovs_cb->ovs_accel_dp_pkt_process((void *)dp, skb, key, sf, sfa);
++}
++
+ /* Must be called with rcu_read_lock. */
+ void ovs_dp_process_packet(struct sk_buff *skb, struct sw_flow_key *key)
+ {
+@@ -291,6 +412,7 @@ void ovs_dp_process_packet(struct sk_buf
+ 
+ 	ovs_flow_stats_update(flow, key->tp.flags, skb);
+ 	sf_acts = rcu_dereference(flow->sf_acts);
++	ovs_dp_pkt_process_notify(dp, skb, key, flow, sf_acts);
+ 	error = ovs_execute_actions(dp, skb, sf_acts, key);
+ 	if (unlikely(error))
+ 		net_dbg_ratelimited("ovs: action execution error on datapath %s: %d\n",
+@@ -1057,6 +1179,7 @@ static int ovs_flow_cmd_new(struct sk_bu
+ 			goto err_unlock_ovs;
+ 		}
+ 
++		ovs_dp_flow_add_notify(dp, new_flow);
+ 		if (unlikely(reply)) {
+ 			error = ovs_flow_cmd_fill_info(new_flow,
+ 						       ovs_header->dp_ifindex,
+@@ -1269,6 +1392,7 @@ static int ovs_flow_cmd_set(struct sk_bu
+ 	if (likely(acts)) {
+ 		old_acts = ovsl_dereference(flow->sf_acts);
+ 		rcu_assign_pointer(flow->sf_acts, acts);
++		ovs_dp_flow_set_notify(dp, flow, old_acts);
+ 
+ 		if (unlikely(reply)) {
+ 			error = ovs_flow_cmd_fill_info(flow,
+@@ -1404,6 +1528,7 @@ static int ovs_flow_cmd_del(struct sk_bu
+ 	}
+ 
+ 	if (unlikely(!a[OVS_FLOW_ATTR_KEY] && !ufid_present)) {
++		ovs_dp_flow_tbl_flush_notify(dp);
+ 		err = ovs_flow_tbl_flush(&dp->table);
+ 		goto unlock;
+ 	}
+@@ -1417,6 +1542,7 @@ static int ovs_flow_cmd_del(struct sk_bu
+ 		goto unlock;
+ 	}
+ 
++	ovs_dp_flow_del_notify(dp, flow);
+ 	ovs_flow_tbl_remove(&dp->table, flow);
+ 	ovs_unlock();
+ 
+@@ -1863,6 +1989,7 @@ static int ovs_dp_cmd_new(struct sk_buff
+ 
+ 	ovs_net = net_generic(ovs_dp_get_net(dp), ovs_net_id);
+ 	list_add_tail_rcu(&dp->list_node, &ovs_net->dps);
++	ovs_dp_add_notify(dp, vport);
+ 
+ 	ovs_unlock();
+ 
+@@ -1906,6 +2033,7 @@ static void __dp_destroy(struct datapath
+ 				ovs_dp_detach_port(vport);
+ 	}
+ 
++	ovs_dp_del_notify(dp, ovs_vport_ovsl(dp, OVSP_LOCAL));
+ 	list_del_rcu(&dp->list_node);
+ 
+ 	/* OVSP_LOCAL is datapath internal port. We need to make sure that
+@@ -2316,6 +2444,7 @@ restart:
+ 		goto exit_unlock_free;
+ 	}
+ 
++	ovs_dp_port_add_notify(dp, vport, a);
+ 	err = ovs_vport_cmd_fill_info(vport, reply, genl_info_net(info),
+ 				      info->snd_portid, info->snd_seq, 0,
+ 				      OVS_VPORT_CMD_NEW, GFP_KERNEL);
+@@ -2368,7 +2497,6 @@ static int ovs_vport_cmd_set(struct sk_b
+ 			goto exit_unlock_free;
+ 	}
+ 
+-
+ 	if (a[OVS_VPORT_ATTR_UPCALL_PID]) {
+ 		struct nlattr *ids = a[OVS_VPORT_ATTR_UPCALL_PID];
+ 
+@@ -2417,6 +2545,7 @@ static int ovs_vport_cmd_del(struct sk_b
+ 		goto exit_unlock_free;
+ 	}
+ 
++	ovs_dp_port_del_notify(vport->dp, vport);
+ 	err = ovs_vport_cmd_fill_info(vport, reply, genl_info_net(info),
+ 				      info->snd_portid, info->snd_seq, 0,
+ 				      OVS_VPORT_CMD_DEL, GFP_KERNEL);
+@@ -2447,6 +2576,166 @@ exit_unlock_free:
+ 	return err;
+ }
+ 
++/* Register OVS datapath accelerator */
++int ovs_register_accelerator(struct ovs_accel_callback *oac)
++{
++	ovs_lock();
++
++	if (unlikely(rcu_access_pointer(ovs_accel_cb))) {
++		ovs_unlock();
++		return -EEXIST;
++	}
++
++	rcu_assign_pointer(ovs_accel_cb, oac);
++	ovs_unlock();
++	return 0;
++}
++EXPORT_SYMBOL(ovs_register_accelerator);
++
++/* Unregister OVS datapath accelerator */
++void ovs_unregister_accelerator(struct ovs_accel_callback *oac)
++{
++	ovs_lock();
++	rcu_assign_pointer(ovs_accel_cb, NULL);
++	ovs_unlock();
++}
++EXPORT_SYMBOL(ovs_unregister_accelerator);
++
++/* Find datapath flow rule using the key*/
++struct sw_flow *ovs_accel_flow_find(void *dp_inst, struct sw_flow_key *key)
++{
++	struct datapath *dp = dp_inst;
++	struct sw_flow *flow;
++
++	rcu_read_lock();
++	flow = ovs_flow_tbl_lookup(&dp->table, key);
++	rcu_read_unlock();
++
++	return flow;
++}
++EXPORT_SYMBOL(ovs_accel_flow_find);
++
++/* Update flow rule statistics */
++int ovs_accel_flow_stats_update(void *dp_inst, void *out_vport,
++				 struct sw_flow_key *key, int pkts, int bytes)
++{
++	struct datapath *dp = dp_inst;
++	struct sw_flow_stats *stats;
++	struct sw_flow *flow;
++	struct dp_stats_percpu *dp_stats;
++	int node = numa_node_id();
++	u64 *stats_counter;
++	u32 n_mask_hit;
++	u32  n_cache_hit;
++
++	rcu_read_lock();
++	flow = ovs_flow_tbl_lookup_stats(&dp->table, key, 0,
++					&n_mask_hit, &n_cache_hit);
++	if (!flow) {
++		rcu_read_unlock();
++		return -EINVAL;
++	}
++
++	/* Update node specific statistics, if memory is not allocated
++	 * for this node then update in 0 node
++	 */
++	stats = rcu_dereference(flow->stats[node]);
++	if (unlikely(!stats))
++		stats = rcu_dereference(flow->stats[0]);
++
++	rcu_read_unlock();
++
++	spin_lock(&stats->lock);
++	stats->used = jiffies;
++	stats->packet_count += pkts;
++	stats->byte_count += bytes;
++
++	/* Update datapath statistics, only hit count should be updated here,
++	 * miss count is taken care by datapath.
++	 * n_mask_hit and stats_counter are updated per packet, whereas
++	 * stats_counter will match the number of packets processed in datapath
++	 * n_mask_hit is updated number of packets times the total masks that
++	 * are processed.  Datapath flows are now accelerated and this API is
++	 * called to update flow statistics, datpath statistics should use
++	 * number of packets.
++	 */
++	dp_stats = this_cpu_ptr(dp->stats_percpu);
++	stats_counter = &dp_stats->n_hit;
++
++	u64_stats_update_begin(&dp_stats->syncp);
++	(*stats_counter) += pkts;
++	dp_stats->n_mask_hit += n_mask_hit * pkts;
++	dp_stats->n_cache_hit += n_cache_hit * pkts;
++	u64_stats_update_end(&dp_stats->syncp);
++
++	spin_unlock(&stats->lock);
++	return 0;
++}
++EXPORT_SYMBOL(ovs_accel_flow_stats_update);
++
++/* Find netdev using vport number */
++struct net_device *ovs_accel_dev_find(void *dp_inst, int vport_no)
++{
++	struct datapath *dp = dp_inst;
++	struct net_device *dev;
++	struct vport *vport;
++
++	rcu_read_lock();
++
++	vport = ovs_vport_rcu(dp, vport_no);
++	if (!vport) {
++		rcu_read_unlock();
++		return NULL;
++	}
++
++	dev = vport->dev;
++	rcu_read_unlock();
++	return dev;
++}
++EXPORT_SYMBOL(ovs_accel_dev_find);
++
++/* Find egress interface using key and skb */
++struct net_device *ovs_accel_egress_dev_find(void *dp_inst,
++					     struct sw_flow_key *key,
++					     struct sk_buff *skb)
++{
++	struct datapath *dp = dp_inst;
++	struct sw_flow *flow;
++	struct sw_flow_actions *sf_acts;
++	struct net_device *dev;
++	const struct nlattr *a;
++	int rem;
++
++	rcu_read_lock();
++	flow = ovs_accel_flow_find(dp_inst, key);
++	if (unlikely(!flow))
++		goto done;
++
++	sf_acts = rcu_dereference(flow->sf_acts);
++	for (a = sf_acts->actions, rem = sf_acts->actions_len; rem > 0;
++			     a = nla_next(a, &rem)) {
++		struct vport *vport;
++		int port_no;
++
++		switch (nla_type(a)) {
++		case OVS_ACTION_ATTR_OUTPUT:
++			port_no = nla_get_u32(a);
++			vport = ovs_vport_ovsl_rcu(dp, port_no);
++			if (!vport) {
++				goto done;
++			}
++
++			dev = vport->dev;
++			rcu_read_unlock();
++			return dev;
++		}
++	}
++done:
++	rcu_read_unlock();
++	return NULL;
++}
++EXPORT_SYMBOL(ovs_accel_egress_dev_find);
++
+ static int ovs_vport_cmd_get(struct sk_buff *skb, struct genl_info *info)
+ {
+ 	struct nlattr **a = info->attrs;
+--- a/net/openvswitch/datapath.h
++++ b/net/openvswitch/datapath.h
+@@ -174,6 +174,37 @@ enum ovs_pkt_hash_types {
+ 	OVS_PACKET_HASH_L4_BIT = (1ULL << 33),
+ };
+ 
++/**
++ *	struct ovs_accel_callback - OVS acceleration callbacks
++ *	@ovs_accel_dp_add - new data path is created
++ *	@ovs_accel_dp_del - data path is deleted
++ *	@ovs_accel_dp_port_add - new port is added into data path
++ *	@ovs_accel_dp_port_del - port is deleted from data path
++ *	@ovs_accel_dp_flow_add - new flow rule is added in data path
++ *	@ovs_accel_dp_flow_del - flow rule is deleted from data path
++ *	@ovs_accel_dp_flow_set - existing flow rule is modified in data path
++ *	@ovs_accel_dp_flow_tbl_flush - flow table is flushed in data path
++ *	@ovs_accel_dp_pkt_process - Process data path packet
++ */
++struct ovs_accel_callback {
++	void (*ovs_accel_dp_add)(void *dp, struct net_device *dev);
++	void (*ovs_accel_dp_del)(void *dp, struct net_device *dev);
++	void (*ovs_accel_dp_port_add)(void *dp, void *vp,
++				      int vp_num, enum ovs_vport_type vp_type,
++				      const char *master, struct net_device *dev);
++	void (*ovs_accel_dp_port_del)(void *dp,  void *vp,
++				      struct net_device *dev);
++	void (*ovs_accel_dp_flow_add)(void *dp, struct sw_flow *sf);
++	void (*ovs_accel_dp_flow_del)(void *dp, struct sw_flow *sf);
++	void (*ovs_accel_dp_flow_set)(void *dp, struct sw_flow *sf,
++				      struct sw_flow_actions *sfa);
++	void (*ovs_accel_dp_flow_tbl_flush)(void *dp);
++	void (*ovs_accel_dp_pkt_process)(void *dp, struct sk_buff *skb,
++					 struct sw_flow_key *key,
++					 struct sw_flow *sf,
++					 struct sw_flow_actions *sfa);
++};
++
+ extern unsigned int ovs_net_id;
+ void ovs_lock(void);
+ void ovs_unlock(void);
+@@ -273,6 +304,16 @@ void ovs_dp_notify_wq(struct work_struct
+ int action_fifos_init(void);
+ void action_fifos_exit(void);
+ 
++int ovs_register_accelerator(struct ovs_accel_callback *oac);
++void ovs_unregister_accelerator(struct ovs_accel_callback *oac);
++int ovs_accel_flow_stats_update(void *dp, void *out_vport,
++				struct sw_flow_key *sf, int pkts, int bytes);
++struct sw_flow *ovs_accel_flow_find(void *dp, struct sw_flow_key *sfk);
++struct net_device *ovs_accel_dev_find(void *dp, int vport_no);
++struct net_device *ovs_accel_egress_dev_find(void *dp_inst,
++					     struct sw_flow_key *key,
++					     struct sk_buff *skb);
++
+ /* 'KEY' must not have any bits set outside of the 'MASK' */
+ #define OVS_MASKED(OLD, KEY, MASK) ((KEY) | ((OLD) & ~(MASK)))
+ #define OVS_SET_MASKED(OLD, KEY, MASK) ((OLD) = OVS_MASKED(OLD, KEY, MASK))
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960259-net-ipv6-Add-MAP-E-enable-disable-config.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,30 @@
+From 5cd2185af65337978dbfacf80e6637668234e545 Mon Sep 17 00:00:00 2001
+From: Himanshu Joshi <himajosh@codeaurora.org>
+Date: Sat, 2 May 2020 23:41:16 +0530
+Subject: [PATCH 174/500] net: ipv6: Add MAP-E enable/disable config.
+
+This patch adds Kconfig option for enable/disable MAP-E config.
+
+Signed-off-by: Himanshu Joshi <himajosh@codeaurora.org>
+Change-Id: Ib4bcabd0b626da562dc073326cb3e59cfa5e026a
+---
+ net/ipv6/Kconfig | 10 ++++++++++
+ 1 file changed, 10 insertions(+)
+
+--- a/net/ipv6/Kconfig
++++ b/net/ipv6/Kconfig
+@@ -341,4 +341,14 @@ config IPV6_IOAM6_LWTUNNEL
+ 
+ 	  If unsure, say N.
+ 
++config MAP_E_SUPPORT
++	bool "IPv6: MAP (RFC 7597) support"
++	default n
++	depends on IPV6
++	help
++	  MAP-E is a mechanism for transporting IPv4 packets across
++	  an IPv6 network using IP encapsulation.
++
++	  If unsure, say N.
++
+ endif # IPV6
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960260-net-patch-linux-kernel-to-support-shortcut-fe.patch	2024-12-24 14:55:11.827624709 +0800
@@ -0,0 +1,77 @@
+From 7a12e1c963727e2988cc80a2cd91160d4db78ffa Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Wed, 11 Mar 2020 11:58:55 -0700
+Subject: [PATCH 245/500] net: patch linux kernel to support shortcut-fe
+
+1, add a new flag 'fast_forwarded' in skb structure.
+2, put a hook in '__netif_receive_skb_core' to
+   deliver packet to shortcut-fe.
+
+Change-Id: Icaa7c172a06df1c3bc89ff89814d1136772fe217
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ include/linux/skbuff.h |  2 ++
+ net/core/dev.c         | 21 +++++++++++++++++++--
+ 2 files changed, 21 insertions(+), 2 deletions(-)
+
+--- a/include/linux/skbuff.h
++++ b/include/linux/skbuff.h
+@@ -986,6 +986,7 @@ struct sk_buff {
+ #endif
+ 	/* Linear packets processed by dev_fast_xmit() */
+ 	__u8			fast_xmit:1;
++	__u8			fast_forwarded:1;
+ 	/* Flag to check if skb is allocated from recycler */
+ 	__u8			is_from_recycler:1;
+ 	/* Flag for fast recycle in fast xmit path */
+--- a/net/core/dev.c
++++ b/net/core/dev.c
+@@ -3594,8 +3594,13 @@ static int xmit_one(struct sk_buff *skb,
+ 	unsigned int len;
+ 	int rc;
+ 
+-	if (dev_nit_active(dev))
+-		dev_queue_xmit_nit(skb, dev);
++	/* If this skb has been fast forwarded then we don't want it to
++	 * go to any taps (by definition we're trying to bypass them).
++	 */
++	if (unlikely(!skb->fast_forwarded)) {
++		if (dev_nit_active(dev))
++			dev_queue_xmit_nit(skb, dev);
++	}
+ 
+ #ifdef CONFIG_ETHERNET_PACKET_MANGLE
+ 	if (dev->eth_mangle_tx && !(skb = dev->eth_mangle_tx(dev, skb)))
+@@ -5441,6 +5446,9 @@ void netdev_rx_handler_unregister(struct
+ }
+ EXPORT_SYMBOL_GPL(netdev_rx_handler_unregister);
+ 
++int (*athrs_fast_nat_recv)(struct sk_buff *skb) __rcu __read_mostly;
++EXPORT_SYMBOL_GPL(athrs_fast_nat_recv);
++
+ /*
+  * Limit the use of PFMEMALLOC reserves to those protocols that implement
+  * the special handling of PFMEMALLOC skbs.
+@@ -5488,6 +5496,7 @@ static int __netif_receive_skb_core(stru
+ 	bool deliver_exact = false;
+ 	int ret = NET_RX_DROP;
+ 	__be16 type;
++	int (*fast_recv)(struct sk_buff *skb);
+ 
+ 	net_timestamp_check(!READ_ONCE(netdev_tstamp_prequeue), skb);
+ 
+@@ -5526,6 +5535,14 @@ another_round:
+ 			goto out;
+ 	}
+ 
++	fast_recv = rcu_dereference(athrs_fast_nat_recv);
++	if (fast_recv) {
++		if (fast_recv(skb)) {
++			ret = NET_RX_SUCCESS;
++			goto out;
++		}
++	}
++
+ 	if (skb_skip_tc_classify(skb))
+ 		goto skip_classify;
+ 
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960261-linux-fix-ipv6-address-error-for-unusual-icmp-messag.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,29 @@
+From d88a80397d18b3308547af6cd2ec4522286863da Mon Sep 17 00:00:00 2001
+From: Ken Zhu <quic_guigenz@quicinc.com>
+Date: Tue, 20 Jun 2023 13:11:11 -0700
+Subject: [PATCH 315/500] linux: fix ipv6 address error for unusual icmp
+ message in ipip6 tunnel
+
+the ipv6 destination address is wrong for unusual icmp message, such as
+unreachable, redirect etc. type message.
+Rather than echo/reply icmp packet, unusual icmp message needs to generate
+the ipv6 address from the original ipv4 header inside its packet.
+
+Change-Id: Iaa69e7907a273c0b4d65101d834ce1949eabe3f8
+Signed-off-by: Ken Zhu <guigenz@codeaurora.org>
+Signed-off-by: John Sanli <quic_jsanli@quicinc.com>
+---
+ net/ipv6/ip6_tunnel.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/net/ipv6/ip6_tunnel.c
++++ b/net/ipv6/ip6_tunnel.c
+@@ -883,7 +883,7 @@ static void ip4ip6_fmr_calc(struct in6_a
+ 		int frombyte = fmr->ip6_prefix_len / 8;
+ 		int fromrem = fmr->ip6_prefix_len % 8;
+ 		int bytes = sizeof(struct in6_addr) - frombyte;
+-		const u32 *addr = (use_dest_addr) ? &iph->daddr : &iph->saddr;
++		const u32 *addr = (use_dest_addr) ? &dsth->daddr : &dsth->saddr;
+ 		u64 eabits = ((u64)ntohl(*addr)) << (32 + fmr->ip4_prefix_len);
+ 		u64 t = 0;
+ 
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960262-net-openvswitch-Use-sleepable-rcu.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,185 @@
+From c2be7f22462a611580260e59fb0ae3a622b2e714 Mon Sep 17 00:00:00 2001
+From: Ratheesh Kannoth <rkannoth@codeaurora.org>
+Date: Mon, 13 Jul 2020 10:35:07 +0530
+Subject: [PATCH 282/500] net: openvswitch: Use sleepable rcu
+
+Change-Id: Iab03855cb7f9cd2a7b584fa22780adf6772b92f1
+Signed-off-by: Pavithra R <quic_pavir@quicinc.com>
+---
+ net/openvswitch/datapath.c | 44 +++++++++++++++++++++-----------------
+ 1 file changed, 24 insertions(+), 20 deletions(-)
+
+--- a/net/openvswitch/datapath.c
++++ b/net/openvswitch/datapath.c
+@@ -51,7 +51,8 @@
+ #include "vport-netdev.h"
+ 
+ unsigned int ovs_net_id __read_mostly;
+-static struct ovs_accel_callback *ovs_accel_cb;
++static struct ovs_accel_callback __rcu *ovs_accel_cb;
++static struct srcu_struct ovs_accel_cb_sp_rcu;
+ 
+ static struct genl_family dp_packet_genl_family;
+ static struct genl_family dp_flow_genl_family;
+@@ -247,12 +248,11 @@ void ovs_dp_detach_port(struct vport *p)
+ static void ovs_dp_add_notify(struct datapath *dp, struct vport *vp)
+ {
+ 	struct ovs_accel_callback *ovs_cb;
+-
+-	rcu_read_lock();
++	int idx = srcu_read_lock(&ovs_accel_cb_sp_rcu);
+ 	ovs_cb = rcu_dereference(ovs_accel_cb);
+ 	if (ovs_cb && ovs_cb->ovs_accel_dp_add)
+ 		ovs_cb->ovs_accel_dp_add((void *)dp, vp->dev);
+-	rcu_read_unlock();
++	srcu_read_unlock(&ovs_accel_cb_sp_rcu, idx);
+ }
+ 
+ /* Notify datapath delete event to acceleration callback */
+@@ -260,11 +260,11 @@ static void ovs_dp_del_notify(struct dat
+ {
+ 	struct ovs_accel_callback *ovs_cb;
+ 
+-	rcu_read_lock();
++	int idx = srcu_read_lock(&ovs_accel_cb_sp_rcu);
+ 	ovs_cb = rcu_dereference(ovs_accel_cb);
+ 	if (ovs_cb && ovs_cb->ovs_accel_dp_del)
+ 		ovs_cb->ovs_accel_dp_del((void *)dp, vp->dev);
+-	rcu_read_unlock();
++	srcu_read_unlock(&ovs_accel_cb_sp_rcu, idx);
+ }
+ 
+ /* Notify datapath port add event to acceleration callback */
+@@ -273,17 +273,18 @@ static void ovs_dp_port_add_notify(struc
+ {
+ 	struct ovs_accel_callback *ovs_cb;
+ 	const char *master = NULL;
++	int idx;
+ 
+ 	if (a[OVS_VPORT_ATTR_MASTER])
+ 		master = nla_data(a[OVS_VPORT_ATTR_MASTER]);
+ 
+-	rcu_read_lock();
++	idx = srcu_read_lock(&ovs_accel_cb_sp_rcu);
+ 	ovs_cb = rcu_dereference(ovs_accel_cb);
+ 	if (ovs_cb && ovs_cb->ovs_accel_dp_port_add)
+ 		ovs_cb->ovs_accel_dp_port_add((void *)dp, (void *)vp,
+ 					      vp->port_no, vp->ops->type,
+ 					      master, vp->dev);
+-	rcu_read_unlock();
++	srcu_read_unlock(&ovs_accel_cb_sp_rcu, idx);
+ }
+ 
+ /* Notify datapath port delete event to acceleration callback */
+@@ -291,11 +292,11 @@ static void ovs_dp_port_del_notify(struc
+ {
+ 	struct ovs_accel_callback *ovs_cb;
+ 
+-	rcu_read_lock();
++	int idx = srcu_read_lock(&ovs_accel_cb_sp_rcu);
+ 	ovs_cb = rcu_dereference(ovs_accel_cb);
+ 	if (ovs_cb && ovs_cb->ovs_accel_dp_port_del)
+ 		ovs_cb->ovs_accel_dp_port_del((void *)dp, (void *)vp, vp->dev);
+-	rcu_read_unlock();
++	srcu_read_unlock(&ovs_accel_cb_sp_rcu, idx);
+ }
+ 
+ /* Notify datapath flow add event to acceleration callback */
+@@ -303,11 +304,11 @@ static void ovs_dp_flow_add_notify(struc
+ {
+ 	struct ovs_accel_callback *ovs_cb;
+ 
+-	rcu_read_lock();
++	int idx = srcu_read_lock(&ovs_accel_cb_sp_rcu);
+ 	ovs_cb = rcu_dereference(ovs_accel_cb);
+ 	if (ovs_cb && ovs_cb->ovs_accel_dp_flow_add)
+ 		ovs_cb->ovs_accel_dp_flow_add((void *)dp, sf);
+-	rcu_read_unlock();
++	srcu_read_unlock(&ovs_accel_cb_sp_rcu, idx);
+ }
+ 
+ /* Notify datapath flow delete event to acceleration callback */
+@@ -315,11 +316,11 @@ static void ovs_dp_flow_del_notify(struc
+ {
+ 	struct ovs_accel_callback *ovs_cb;
+ 
+-	rcu_read_lock();
++	int idx = srcu_read_lock(&ovs_accel_cb_sp_rcu);
+ 	ovs_cb = rcu_dereference(ovs_accel_cb);
+ 	if (ovs_cb && ovs_cb->ovs_accel_dp_flow_del)
+ 		ovs_cb->ovs_accel_dp_flow_del((void *)dp, sf);
+-	rcu_read_unlock();
++	srcu_read_unlock(&ovs_accel_cb_sp_rcu, idx);
+ }
+ 
+ /* Notify datapath flow table flush event to acceleration callback */
+@@ -327,11 +328,11 @@ static void ovs_dp_flow_tbl_flush_notify
+ {
+ 	struct ovs_accel_callback *ovs_cb;
+ 
+-	rcu_read_lock();
++	int idx = srcu_read_lock(&ovs_accel_cb_sp_rcu);
+ 	ovs_cb = rcu_dereference(ovs_accel_cb);
+ 	if (ovs_cb && ovs_cb->ovs_accel_dp_flow_tbl_flush)
+ 		ovs_cb->ovs_accel_dp_flow_tbl_flush((void *)dp);
+-	rcu_read_unlock();
++	srcu_read_unlock(&ovs_accel_cb_sp_rcu, idx);
+ }
+ 
+ /* Notify datapath flow set/change event to acceleration callback */
+@@ -340,11 +341,11 @@ static void ovs_dp_flow_set_notify(struc
+ {
+ 	struct ovs_accel_callback *ovs_cb;
+ 
+-	rcu_read_lock();
++	int idx = srcu_read_lock(&ovs_accel_cb_sp_rcu);
+ 	ovs_cb = rcu_dereference(ovs_accel_cb);
+ 	if (ovs_cb && ovs_cb->ovs_accel_dp_flow_set)
+ 		ovs_cb->ovs_accel_dp_flow_set((void *)dp, sf, new_sfa);
+-	rcu_read_unlock();
++	srcu_read_unlock(&ovs_accel_cb_sp_rcu, idx);
+ }
+ 
+ /* Forward datapath packet to acceleration callback
+@@ -356,8 +357,6 @@ static void ovs_dp_pkt_process_notify(st
+ {
+ 	struct ovs_accel_callback *ovs_cb;
+ 
+-	WARN_ON(!rcu_read_lock_held());
+-
+ 	ovs_cb = rcu_dereference(ovs_accel_cb);
+ 	if (ovs_cb && ovs_cb->ovs_accel_dp_pkt_process)
+ 		ovs_cb->ovs_accel_dp_pkt_process((void *)dp, skb, key, sf, sfa);
+@@ -2588,6 +2587,7 @@ int ovs_register_accelerator(struct ovs_
+ 
+ 	rcu_assign_pointer(ovs_accel_cb, oac);
+ 	ovs_unlock();
++	synchronize_srcu(&ovs_accel_cb_sp_rcu);
+ 	return 0;
+ }
+ EXPORT_SYMBOL(ovs_register_accelerator);
+@@ -2598,6 +2598,7 @@ void ovs_unregister_accelerator(struct o
+ 	ovs_lock();
+ 	rcu_assign_pointer(ovs_accel_cb, NULL);
+ 	ovs_unlock();
++	synchronize_srcu(&ovs_accel_cb_sp_rcu);
+ }
+ EXPORT_SYMBOL(ovs_unregister_accelerator);
+ 
+@@ -3015,6 +3016,8 @@ static int __init dp_init(void)
+ 
+ 	pr_info("Open vSwitch switching datapath\n");
+ 
++	init_srcu_struct(&ovs_accel_cb_sp_rcu);
++
+ 	err = action_fifos_init();
+ 	if (err)
+ 		goto error;
+@@ -3067,6 +3070,7 @@ error_unreg_rtnl_link:
+ error_action_fifos_exit:
+ 	action_fifos_exit();
+ error:
++	cleanup_srcu_struct(&ovs_accel_cb_sp_rcu);
+ 	return err;
+ }
+ 
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960263-net-add-IFF_EXT_HW_NO_OFFLOAD-flag-in-net_device-pri.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,23 @@
+From 50baaaed5dcb4387cfee867336e595a4e5593527 Mon Sep 17 00:00:00 2001
+From: "Hardik S. Panchal" <quic_hpanchal@quicinc.com>
+Date: Sat, 26 Aug 2023 00:46:10 +0530
+Subject: [PATCH 314/500] net: add IFF_EXT_HW_NO_OFFLOAD flag in net_device
+ priv_flags_ext
+
+Change-Id: I6a2d531657d9c9c61b288d7d1be57f0297d708de
+Signed-off-by: Hardik S. Panchal <quic_hpanchal@quicinc.com>
+Signed-off-by: Pavithra R <quic_pavir@quicinc.com>
+---
+ include/linux/netdevice.h | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/include/linux/netdevice.h
++++ b/include/linux/netdevice.h
+@@ -1785,6 +1785,7 @@ enum netdev_priv_flags_ext {
+ 	IFF_EXT_GRE_V6_TAP		= 1<<5,
+ 	IFF_EXT_IFB				= 1<<6,
+ 	IFF_EXT_MAPT			= 1<<7,
++	IFF_EXT_HW_NO_OFFLOAD		= 1<<8,
+ };
+ 
+ #define IFF_802_1Q_VLAN			IFF_802_1Q_VLAN
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960264-ip6_tunnel-Fix-NLA_F_NESTED-check-issue-in-kernel-5..patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,26 @@
+From d51eaebb796b33b826adc05ceca6662e02ae3ac8 Mon Sep 17 00:00:00 2001
+From: Tian Yang <quic_tiany@quicinc.com>
+Date: Tue, 20 Jun 2023 13:07:23 -0700
+Subject: [PATCH 317/500] ip6_tunnel: Fix NLA_F_NESTED check issue in kernel
+ 5.4
+
+Use nla_parse_nested_deprecated instead of nla_parse_nested to bypass the NLA_F_NESTED flag check.
+
+Change-Id: Ic2bc0903bd5366f516be011d87932138ede1d004
+Signed-off-by: Tian Yang <tiany@codeaurora.org>
+Signed-off-by: John Sanli <quic_jsanli@quicinc.com>
+---
+ net/ipv6/ip6_tunnel.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/net/ipv6/ip6_tunnel.c
++++ b/net/ipv6/ip6_tunnel.c
+@@ -2190,7 +2190,7 @@ static void ip6_tnl_netlink_parms(struct
+ 			struct nlattr *fmrd[IFLA_IPTUN_FMR_MAX + 1], *c;
+ 			struct __ip6_tnl_fmr *nfmr;
+ 
+-			nla_parse_nested(fmrd, IFLA_IPTUN_FMR_MAX,
++			nla_parse_nested_deprecated(fmrd, IFLA_IPTUN_FMR_MAX,
+ 				fmr, ip6_tnl_fmr_policy, NULL);
+ 
+ 			if (!(nfmr = kzalloc(sizeof(*nfmr), GFP_KERNEL)))
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960265-net-Correct-FMR-Calculation-in-Linux-6.1.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,49 @@
+From 3d55122c4a9bab65e4e9652e72155d1e20b3d27d Mon Sep 17 00:00:00 2001
+From: John Sanli <quic_jsanli@quicinc.com>
+Date: Tue, 20 Jun 2023 13:03:01 -0700
+Subject: [PATCH 239/500] net: Correct FMR Calculation in Linux 6.1
+
+Previously FMR calculation was set to only occur in ip4ip6_tnl_xmit()
+Linux 6.1 replaces this with ipxip6_tnl_xmit()
+
+There is one tnl_xmit function for both ipv4 and ipv6 in this kernel.
+This patch ensures FMR calculation is only performed in outbound direction.
+
+Change-Id: If36e1033be7f8b9fbea4e1d9a3664c1d8b41c666
+Signed-off-by: John Sanli <quic_jsanli@quicinc.com>
+---
+ net/ipv6/ip6_tunnel.c | 22 ++++++++++++----------
+ 1 file changed, 12 insertions(+), 10 deletions(-)
+
+--- a/net/ipv6/ip6_tunnel.c
++++ b/net/ipv6/ip6_tunnel.c
+@@ -1540,17 +1540,19 @@ ipxip6_tnl_xmit(struct sk_buff *skb, str
+ 	fl6.flowi6_uid = sock_net_uid(dev_net(dev), NULL);
+ 	dsfield = INET_ECN_encapsulate(dsfield, orig_dsfield);
+ 
+-	/* try to find matching FMR */
+-	for (fmr = t->parms.fmrs; fmr; fmr = fmr->next) {
+-		unsigned mshift = 32 - fmr->ip4_prefix_len;
+-		if (ntohl(fmr->ip4_prefix.s_addr) >> mshift ==
+-				ntohl(ip_hdr(skb)->daddr) >> mshift)
+-			break;
+-	}
++	if (protocol == IPPROTO_IPIP) {
++		/* try to find matching FMR */
++		for (fmr = t->parms.fmrs; fmr; fmr = fmr->next) {
++			unsigned mshift = 32 - fmr->ip4_prefix_len;
++			if (ntohl(fmr->ip4_prefix.s_addr) >> mshift ==
++					ntohl(ip_hdr(skb)->daddr) >> mshift)
++				break;
++		}
+ 
+-	/* change dstaddr according to FMR */
+-	if (fmr)
+-		ip4ip6_fmr_calc(&fl6.daddr, ip_hdr(skb), skb_tail_pointer(skb), fmr, true);
++		/* change dstaddr according to FMR */
++		if (fmr)
++			ip4ip6_fmr_calc(&fl6.daddr, ip_hdr(skb), skb_tail_pointer(skb), fmr, true);
++	}
+ 
+ 	if (iptunnel_handle_offloads(skb, SKB_GSO_IPXIP6))
+ 		return -1;
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960270-Add-fast-transmit-API-version-for-virtual-port-path.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,95 @@
+From f2d3587f593cd5ee16d873ec0e8e17f95a0254b8 Mon Sep 17 00:00:00 2001
+From: Subhash Kumar Katnapally <quic_skatnapa@quicinc.com>
+Date: Tue, 26 Jul 2022 09:24:19 +0530
+Subject: [PATCH 246/500] Add fast transmit API version for virtual port path
+
+Removed additional checks not needed for VP Tx path such
+as dst check. Non-linear packets are handled via dev_queue_xmit
+path.
+
+Change-Id: I80a55dd5ae17d31a1484c83e99015987cda38e1b
+Signed-off-by: Subhash Kumar Katnapally <quic_skatnapa@quicinc.com>
+---
+ include/linux/netdevice.h |  1 +
+ net/core/dev.c            | 60 +++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 61 insertions(+)
+
+--- a/include/linux/netdevice.h
++++ b/include/linux/netdevice.h
+@@ -3187,6 +3187,7 @@ static inline int dev_direct_xmit(struct
+ 	return ret;
+ }
+ 
++bool dev_fast_xmit_vp(struct sk_buff *skb, struct net_device *dev);
+ bool dev_fast_xmit(struct sk_buff *skb, struct net_device *dev,
+ 		   netdev_features_t features);
+ int register_netdevice(struct net_device *dev);
+--- a/net/core/dev.c
++++ b/net/core/dev.c
+@@ -4301,6 +4301,66 @@ struct netdev_queue *netdev_core_pick_tx
+ }
+ 
+ /**
++ *	dev_fast_xmit_vp - fast xmit the skb to a PPE virtual port
++ *	@skb:buffer to transmit
++ *	@dev: the device to be transmited to
++ *	sucessful return true
++ *	failed return false
++ */
++bool dev_fast_xmit_vp(struct sk_buff *skb,
++		struct net_device *dev)
++{
++	struct netdev_queue *txq;
++	int cpu;
++	netdev_tx_t rc;
++
++	if (unlikely(!(dev->flags & IFF_UP))) {
++		return false;
++	}
++
++	if (unlikely(skb_is_nonlinear(skb))) {
++		return false;
++	}
++
++	rcu_read_lock_bh();
++	cpu = smp_processor_id();
++
++	/*
++	 * TODO: Skip this altogether and eventually move this call to ppe_vp
++	 * this would avoid multiple function calls when giving packet to wifi VAP.
++	 */
++	txq = netdev_core_pick_tx(dev, skb, NULL);
++
++	if (likely(txq->xmit_lock_owner != cpu)) {
++#define FAST_VP_HARD_TX_LOCK(txq, cpu) {	\
++		__netif_tx_lock(txq, cpu);		\
++}
++
++#define FAST_VP_HARD_TX_UNLOCK(txq) {		\
++		__netif_tx_unlock(txq);			\
++}
++		skb->fast_xmit = 1;
++		FAST_VP_HARD_TX_LOCK(txq, cpu);
++		if (likely(!netif_xmit_stopped(txq))) {
++			rc = netdev_start_xmit(skb, dev, txq, 0);
++			if (unlikely(!dev_xmit_complete(rc))) {
++				FAST_VP_HARD_TX_UNLOCK(txq);
++				goto q_xmit;
++			}
++			FAST_VP_HARD_TX_UNLOCK(txq);
++			rcu_read_unlock_bh();
++			return true;
++		}
++		FAST_VP_HARD_TX_UNLOCK(txq);
++	}
++q_xmit:
++	skb->fast_xmit = 0;
++	rcu_read_unlock_bh();
++	return false;
++}
++EXPORT_SYMBOL(dev_fast_xmit_vp);
++
++/**
+  *	dev_fast_xmit - fast xmit the skb
+  *	@skb:buffer to transmit
+  *	@dev: the device to be transmited to
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960273-xfrm-Add-API-to-override-state-afinfo-object.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,50 @@
+From 41aef1ce703f060524dae34c5f833f764ef973de Mon Sep 17 00:00:00 2001
+From: Neelansh Mittal <neelanshm@codeaurora.org>
+Date: Thu, 5 Nov 2020 09:45:05 +0530
+Subject: [PATCH 279/500] xfrm: Add API to override state afinfo object.
+
+Add a new API that can be used to override the
+currently registered xfrm_state_afinfo object
+with a newly provided one.
+
+Change-Id: Ic520dc496e14ddf5803d5769a3bd14cbfd98749c
+Signed-off-by: Neelansh Mittal <neelanshm@codeaurora.org>
+Signed-off-by: Pavithra R <quic_pavir@quicinc.com>
+---
+ include/net/xfrm.h    |  1 +
+ net/xfrm/xfrm_state.c | 14 ++++++++++++++
+ 2 files changed, 15 insertions(+)
+
+--- a/include/net/xfrm.h
++++ b/include/net/xfrm.h
+@@ -404,6 +404,7 @@ int xfrm_state_register_afinfo(struct xf
+ int xfrm_state_unregister_afinfo(struct xfrm_state_afinfo *afinfo);
+ struct xfrm_state_afinfo *xfrm_state_get_afinfo(unsigned int family);
+ struct xfrm_state_afinfo *xfrm_state_afinfo_get_rcu(unsigned int family);
++struct xfrm_state_afinfo *xfrm_state_update_afinfo(unsigned int family, struct xfrm_state_afinfo *new);
+ 
+ struct xfrm_input_afinfo {
+ 	u8			family;
+--- a/net/xfrm/xfrm_state.c
++++ b/net/xfrm/xfrm_state.c
+@@ -2775,6 +2775,20 @@ struct xfrm_state_afinfo *xfrm_state_get
+ 	return afinfo;
+ }
+ 
++struct xfrm_state_afinfo *xfrm_state_update_afinfo(unsigned int family, struct xfrm_state_afinfo *new)
++{
++	struct xfrm_state_afinfo *afinfo;
++
++	spin_lock_bh(&xfrm_state_afinfo_lock);
++	afinfo = rcu_dereference_protected(xfrm_state_afinfo[family], lockdep_is_held(&xfrm_state_afinfo_lock));
++	rcu_assign_pointer(xfrm_state_afinfo[afinfo->family], new);
++	spin_unlock_bh(&xfrm_state_afinfo_lock);
++
++	synchronize_rcu();
++	return afinfo;
++}
++EXPORT_SYMBOL(xfrm_state_update_afinfo);
++
+ void xfrm_flush_gc(void)
+ {
+ 	flush_work(&xfrm_state_gc_work);
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960274-xfrm-Add-xfrm-event-notifier.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,143 @@
+From c7c7962d7474e15e09a3ba96974681781756d322 Mon Sep 17 00:00:00 2001
+From: Neelansh Mittal <neelanshm@codeaurora.org>
+Date: Tue, 30 Mar 2021 14:10:51 +0530
+Subject: [PATCH 280/500] xfrm: Add xfrm event notifier.
+
+Add xfrm_state change event notifier
+
+Change-Id: Ia211ad89fe78a0eff57c4f643d79c1396c0be0af
+Signed-off-by: Neelansh Mittal <neelanshm@codeaurora.org>
+Signed-off-by: Pavithra R <quic_pavir@quicinc.com>
+---
+ include/net/netns/xfrm.h |  2 ++
+ include/net/xfrm.h       | 16 ++++++++++++++++
+ net/xfrm/xfrm_policy.c   |  4 ++++
+ net/xfrm/xfrm_state.c    | 37 +++++++++++++++++++++++++++++++++++++
+ net/xfrm/xfrm_user.c     |  3 +++
+ 5 files changed, 62 insertions(+)
+
+--- a/include/net/netns/xfrm.h
++++ b/include/net/netns/xfrm.h
+@@ -83,6 +83,8 @@ struct netns_xfrm {
+ 
+ 	spinlock_t xfrm_policy_lock;
+ 	struct mutex xfrm_cfg_mutex;
++	spinlock_t xfrm_event_lock;
++	struct list_head event_notifier_list;
+ };
+ 
+ #endif
+--- a/include/net/xfrm.h
++++ b/include/net/xfrm.h
+@@ -294,6 +294,21 @@ struct xfrm_state {
+ 	void			*data;
+ };
+ 
++enum xfrm_event_type {
++	XFRM_EVENT_NONE = 0,
++	XFRM_EVENT_STATE_ADD,
++	XFRM_EVENT_STATE_DEL,
++	XFRM_EVENT_MAX
++};
++
++struct xfrm_event_notifier {
++	struct list_head list;
++	void (*state_notify)(struct xfrm_state *x, enum xfrm_event_type event);
++};
++
++int xfrm_event_register_notifier(struct net *net, struct xfrm_event_notifier *event);
++void xfrm_event_unregister_notifier(struct net *net, struct xfrm_event_notifier *event);
++
+ static inline struct net *xs_net(struct xfrm_state *x)
+ {
+ 	return read_pnet(&x->xs_net);
+@@ -1620,6 +1635,7 @@ struct xfrm_state *xfrm_state_lookup_bya
+ 					    const xfrm_address_t *saddr,
+ 					    u8 proto,
+ 					    unsigned short family);
++void xfrm_state_change_notify(struct xfrm_state *x, enum xfrm_event_type);
+ #ifdef CONFIG_XFRM_SUB_POLICY
+ void xfrm_tmpl_sort(struct xfrm_tmpl **dst, struct xfrm_tmpl **src, int n,
+ 		    unsigned short family);
+--- a/net/xfrm/xfrm_policy.c
++++ b/net/xfrm/xfrm_policy.c
+@@ -4238,6 +4238,10 @@ static int __net_init xfrm_net_init(stru
+ 	spin_lock_init(&net->xfrm.xfrm_policy_lock);
+ 	seqcount_spinlock_init(&net->xfrm.xfrm_policy_hash_generation, &net->xfrm.xfrm_policy_lock);
+ 	mutex_init(&net->xfrm.xfrm_cfg_mutex);
++	spin_lock_init(&net->xfrm.xfrm_event_lock);
++
++	INIT_LIST_HEAD(&net->xfrm.event_notifier_list);
++
+ 	net->xfrm.policy_default[XFRM_POLICY_IN] = XFRM_USERPOLICY_ACCEPT;
+ 	net->xfrm.policy_default[XFRM_POLICY_FWD] = XFRM_USERPOLICY_ACCEPT;
+ 	net->xfrm.policy_default[XFRM_POLICY_OUT] = XFRM_USERPOLICY_ACCEPT;
+--- a/net/xfrm/xfrm_state.c
++++ b/net/xfrm/xfrm_state.c
+@@ -756,6 +756,7 @@ int __xfrm_state_delete(struct xfrm_stat
+ 			sock_put(rcu_dereference_raw(x->encap_sk));
+ 
+ 		xfrm_dev_state_delete(x);
++		xfrm_state_change_notify(x, XFRM_EVENT_STATE_DEL);
+ 
+ 		/* All xfrm_state objects are created by xfrm_state_alloc.
+ 		 * The xfrm_state_alloc call gives a reference, and that
+@@ -3141,3 +3142,39 @@ void xfrm_audit_state_icvfail(struct xfr
+ }
+ EXPORT_SYMBOL_GPL(xfrm_audit_state_icvfail);
+ #endif /* CONFIG_AUDITSYSCALL */
++
++void xfrm_state_change_notify(struct xfrm_state *x, enum xfrm_event_type type)
++{
++	struct xfrm_event_notifier *event;
++	struct net *net = xs_net(x);
++
++	rcu_read_lock();
++	list_for_each_entry_rcu(event, &net->xfrm.event_notifier_list, list) {
++		if (event->state_notify) {
++			event->state_notify(x, type);
++		}
++
++		BUG_ON(refcount_read(&x->refcnt) <= 0);
++	}
++
++	rcu_read_unlock();
++}
++EXPORT_SYMBOL(xfrm_state_change_notify);
++
++int xfrm_event_register_notifier(struct net *net, struct xfrm_event_notifier *event)
++{
++	spin_lock_bh(&net->xfrm.xfrm_event_lock);
++	list_add_tail_rcu(&event->list, &net->xfrm.event_notifier_list);
++	spin_unlock_bh(&net->xfrm.xfrm_event_lock);
++	return 0;
++}
++EXPORT_SYMBOL(xfrm_event_register_notifier);
++
++void xfrm_event_unregister_notifier(struct net *net, struct xfrm_event_notifier *event)
++{
++	spin_lock_bh(&net->xfrm.xfrm_event_lock);
++	list_del_rcu(&event->list);
++	spin_unlock_bh(&net->xfrm.xfrm_event_lock);
++	synchronize_rcu();
++}
++EXPORT_SYMBOL(xfrm_event_unregister_notifier);
+--- a/net/xfrm/xfrm_user.c
++++ b/net/xfrm/xfrm_user.c
+@@ -773,6 +773,8 @@ static struct xfrm_state *xfrm_state_con
+ 			goto error;
+ 	}
+ 
++	xfrm_state_change_notify(x, XFRM_EVENT_STATE_ADD);
++
+ 	return x;
+ 
+ error:
+@@ -811,6 +813,7 @@ static int xfrm_add_sa(struct sk_buff *s
+ 	if (err < 0) {
+ 		x->km.state = XFRM_STATE_DEAD;
+ 		xfrm_dev_state_delete(x);
++		xfrm_state_change_notify(x, XFRM_EVENT_STATE_DEL);
+ 		__xfrm_state_put(x);
+ 		goto out;
+ 	}
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960275-inet-vlan-Added-an-API-to-return-next-VLAN-device.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,44 @@
+From 7e55d330bd4736543b74f82d17ceeab9cc482980 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Fri, 24 Apr 2020 10:58:42 -0700
+Subject: [PATCH 090/500] inet: vlan: Added an API to return next VLAN device
+
+The new API returns the next dev when a VLAN dev passed
+in parameter i.e.
+eth0.10.20 -> eth0.10 -> eth0 The new API returns eth0.10
+when eth0.10.20 is passed as a parameter.
+
+Change-Id: I743beb0672e8fd0d6562eec8ec88b1e36eec2973
+Signed-off-by: Shyam Sunder <ssunde@codeaurora.org>
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ include/linux/if_vlan.h | 1 +
+ net/8021q/vlan_core.c   | 7 +++++++
+ 2 files changed, 8 insertions(+)
+
+--- a/include/linux/if_vlan.h
++++ b/include/linux/if_vlan.h
+@@ -144,6 +144,7 @@ extern int vlan_for_each(struct net_devi
+ 			 int (*action)(struct net_device *dev, int vid,
+ 				       void *arg), void *arg);
+ extern struct net_device *vlan_dev_real_dev(const struct net_device *dev);
++extern struct net_device *vlan_dev_next_dev(const struct net_device *dev);
+ extern u16 vlan_dev_vlan_id(const struct net_device *dev);
+ extern __be16 vlan_dev_vlan_proto(const struct net_device *dev);
+ 
+--- a/net/8021q/vlan_core.c
++++ b/net/8021q/vlan_core.c
+@@ -110,6 +110,13 @@ struct net_device *vlan_dev_real_dev(con
+ }
+ EXPORT_SYMBOL(vlan_dev_real_dev);
+ 
++/* Caller is responsible to hold the reference of the returned device */
++struct net_device *vlan_dev_next_dev(const struct net_device *dev)
++{
++	return vlan_dev_priv(dev)->real_dev;
++}
++EXPORT_SYMBOL(vlan_dev_next_dev);
++
+ u16 vlan_dev_vlan_id(const struct net_device *dev)
+ {
+ 	return vlan_dev_priv(dev)->vlan_id;
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960276-opevswitch-Invoke-callbacks-even-if-flow-cannot-be-f.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,23 @@
+From 5b966d1a083c876521339045391655e2a71ab48f Mon Sep 17 00:00:00 2001
+From: Ratheesh Kannoth <rkannoth@codeaurora.org>
+Date: Fri, 25 Sep 2020 07:28:44 +0530
+Subject: [PATCH 283/500] opevswitch: Invoke callbacks even if flow cannot be
+ found
+
+Change-Id: I9f8dffff268d1d08472a178eb0660e3f354e125b
+Signed-off-by: Pavithra R <quic_pavir@quicinc.com>
+---
+ net/openvswitch/datapath.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/net/openvswitch/datapath.c
++++ b/net/openvswitch/datapath.c
+@@ -377,6 +377,8 @@ void ovs_dp_process_packet(struct sk_buf
+ 
+ 	stats = this_cpu_ptr(dp->stats_percpu);
+ 
++	ovs_dp_pkt_process_notify(dp, skb, key, NULL, NULL);
++
+ 	/* Look up flow. */
+ 	flow = ovs_flow_tbl_lookup_stats(&dp->table, key, skb_get_hash(skb),
+ 					 &n_mask_hit, &n_cache_hit);
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960278-net-Add-API-to-update-L4-protocol-registrant.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,100 @@
+From 94972ba5210ab34f071b011e9001f7234860fe89 Mon Sep 17 00:00:00 2001
+From: "Hardik S. Panchal" <hpanchal@codeaurora.org>
+Date: Tue, 8 May 2018 10:16:32 +0530
+Subject: [PATCH 281/500] net: Add API to update L4 protocol registrant.
+
+Change-Id: I0d01fe33a590bb3eec596de621f86537f60c7071
+Signed-off-by: Hardik S. Panchal <hpanchal@codeaurora.org>
+Signed-off-by: Pavithra R <quic_pavir@quicinc.com>
+---
+ include/net/protocol.h |  4 ++++
+ net/ipv4/protocol.c    | 26 ++++++++++++++++++++++++++
+ net/ipv6/protocol.c    | 26 ++++++++++++++++++++++++++
+ 3 files changed, 56 insertions(+)
+
+--- a/include/net/protocol.h
++++ b/include/net/protocol.h
+@@ -101,12 +101,16 @@ int inet_add_protocol(const struct net_p
+ int inet_del_protocol(const struct net_protocol *prot, unsigned char num);
+ int inet_add_offload(const struct net_offload *prot, unsigned char num);
+ int inet_del_offload(const struct net_offload *prot, unsigned char num);
++int inet_update_protocol(const struct net_protocol *new_prot,
++		unsigned char num, const struct net_protocol **old_prot);
+ void inet_register_protosw(struct inet_protosw *p);
+ void inet_unregister_protosw(struct inet_protosw *p);
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ int inet6_add_protocol(const struct inet6_protocol *prot, unsigned char num);
+ int inet6_del_protocol(const struct inet6_protocol *prot, unsigned char num);
++int inet6_update_protocol(const struct inet6_protocol *new_prot,
++		unsigned char num, const struct inet6_protocol **old_prot);
+ int inet6_register_protosw(struct inet_protosw *p);
+ void inet6_unregister_protosw(struct inet_protosw *p);
+ #endif
+--- a/net/ipv4/protocol.c
++++ b/net/ipv4/protocol.c
+@@ -68,3 +68,29 @@ int inet_del_offload(const struct net_of
+ 	return ret;
+ }
+ EXPORT_SYMBOL(inet_del_offload);
++
++int inet_update_protocol(const struct net_protocol *new_prot,
++		unsigned char protocol, const struct net_protocol **old_prot)
++{
++	int ret;
++
++	rcu_read_lock();
++	*old_prot = rcu_dereference(inet_protos[protocol]);
++	if (!*old_prot) {
++		rcu_read_unlock();
++		return -1;
++	}
++	rcu_read_unlock();
++
++	/*
++	 * old_prot is not protected as cmpxchg is successful only if
++	 * old_prot matches with the value in inet_protos[protocol]
++	 */
++	ret = (cmpxchg((const struct net_protocol **)&inet_protos[protocol],
++			*old_prot, new_prot) == *old_prot) ? 0 : -1;
++
++	 synchronize_net();
++
++	 return ret;
++}
++EXPORT_SYMBOL(inet_update_protocol);
+--- a/net/ipv6/protocol.c
++++ b/net/ipv6/protocol.c
+@@ -44,6 +44,32 @@ int inet6_del_protocol(const struct inet
+ 	return ret;
+ }
+ EXPORT_SYMBOL(inet6_del_protocol);
++
++int inet6_update_protocol(const struct inet6_protocol *new_prot,
++		unsigned char protocol, const struct inet6_protocol **old_prot)
++{
++	int ret;
++
++	rcu_read_lock();
++	*old_prot = rcu_dereference(inet6_protos[protocol]);
++	if (!*old_prot) {
++		rcu_read_unlock();
++		return -1;
++	}
++	rcu_read_unlock();
++
++	/*
++	 * old_prot is not protected as cmpxchg is successful only if
++	 * old_prot matches with the value in inet6_protos[protocol]
++	 */
++	ret = (cmpxchg((const struct inet6_protocol **)&inet6_protos[protocol],
++			*old_prot, new_prot) == *old_prot) ? 0 : -1;
++
++	synchronize_net();
++
++	return ret;
++}
++EXPORT_SYMBOL(inet6_update_protocol);
+ #endif
+ 
+ const struct net_offload __rcu *inet6_offloads[MAX_INET_PROTOS] __read_mostly;
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960280-openvswitch-Function-to-search-OVS-flow-rule-by-MAC-.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,113 @@
+From c051e50ee93118ed5de57d7708e2b9ce82cb19b1 Mon Sep 17 00:00:00 2001
+From: Ratheesh Kannoth <rkannoth@codeaurora.org>
+Date: Wed, 16 Sep 2020 10:53:55 +0530
+Subject: [PATCH 284/500] openvswitch: Function to search OVS flow rule by MAC
+ address
+
+This new function will search datapath flow table and match given
+MAC address with source MAC of flow rule and return the rule.
+
+Change-Id: I2577e9980698460c62205a39da52a95ecacb9947
+Signed-off-by: Pavithra R <quic_pavir@quicinc.com>
+---
+ net/openvswitch/datapath.c | 75 ++++++++++++++++++++++++++++++++++++++
+ net/openvswitch/datapath.h |  4 ++
+ 2 files changed, 79 insertions(+)
+
+--- a/net/openvswitch/datapath.c
++++ b/net/openvswitch/datapath.c
+@@ -2618,6 +2618,81 @@ struct sw_flow *ovs_accel_flow_find(void
+ }
+ EXPORT_SYMBOL(ovs_accel_flow_find);
+ 
++/* Find datapath flow rule using MAC addresses*/
++struct sw_flow *ovs_accel_flow_find_by_mac(void *dp_inst,
++						struct net_device *br_dev,
++						uint8_t *smac, uint8_t *dmac, uint16_t type)
++{
++	struct datapath *dp = dp_inst;
++	struct table_instance *ti;
++	struct sw_flow *flow = NULL;
++	struct sw_flow_actions *sf_acts;
++	const struct nlattr *a;
++	bool flow_found = false;
++	int egress_ports = 0;
++	int rem;
++	int i;
++
++	rcu_read_lock();
++	ti = rcu_dereference(dp->table.ti);
++
++	for (i = 0; i < ti->n_buckets; i++) {
++		struct hlist_head *head =  &ti->buckets[i];
++		struct hlist_node *n;
++
++		if (unlikely(!head))
++			continue;
++
++		hlist_for_each_entry_safe(flow, n, head,
++				flow_table.node[ti->node_ver]) {
++			if ((flow->key.eth.type == type) &&
++			     ether_addr_equal(flow->key.eth.src, smac) &&
++			     ether_addr_equal(flow->key.eth.dst, dmac)) {
++				flow_found = true;
++				goto found;
++			}
++		}
++	}
++found:
++	if (!flow_found) {
++		rcu_read_unlock();
++		return NULL;
++	}
++
++	/*
++	 * Flow is found, check if output action is br_dev
++	 */
++	flow_found = false;
++	sf_acts = rcu_dereference(flow->sf_acts);
++	for (a = sf_acts->actions, rem = sf_acts->actions_len; rem > 0;
++			a = nla_next(a, &rem)) {
++		struct vport *vport;
++		int port_no;
++
++		if (nla_type(a) != OVS_ACTION_ATTR_OUTPUT)
++			continue;
++
++		port_no = nla_get_u32(a);
++		vport = ovs_vport_ovsl_rcu(dp, port_no);
++
++		if (vport && (br_dev == vport->dev)) {
++			flow_found = true;
++		}
++		egress_ports++;
++	}
++
++	/*
++	 * flow should be unicast and egress port should be
++	 * bridge interface.
++	 */
++	if (!flow_found || (egress_ports != 1))
++		flow = NULL;
++
++	rcu_read_unlock();
++	return flow;
++}
++EXPORT_SYMBOL(ovs_accel_flow_find_by_mac);
++
+ /* Update flow rule statistics */
+ int ovs_accel_flow_stats_update(void *dp_inst, void *out_vport,
+ 				 struct sw_flow_key *key, int pkts, int bytes)
+--- a/net/openvswitch/datapath.h
++++ b/net/openvswitch/datapath.h
+@@ -314,6 +314,10 @@ struct net_device *ovs_accel_egress_dev_
+ 					     struct sw_flow_key *key,
+ 					     struct sk_buff *skb);
+ 
++struct sw_flow *ovs_accel_flow_find_by_mac(void *dp_inst,
++						struct net_device *br_dev,
++						uint8_t *smac, uint8_t *dmac, uint16_t type);
++
+ /* 'KEY' must not have any bits set outside of the 'MASK' */
+ #define OVS_MASKED(OLD, KEY, MASK) ((KEY) | ((OLD) & ~(MASK)))
+ #define OVS_SET_MASKED(OLD, KEY, MASK) ((OLD) = OVS_MASKED(OLD, KEY, MASK))
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960281-net-vxlan-Adding-APIs-to-VxLAN-driver.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,132 @@
+From 02d4a6aaa370c93878fc21ad812f219529759c3d Mon Sep 17 00:00:00 2001
+From: Sachin Kohli <quic_sachkohl@quicinc.com>
+Date: Tue, 19 Dec 2023 10:15:33 +0530
+Subject: [PATCH 206/500] net: vxlan: Adding APIs to VxLAN driver.
+
+Adding new APIs to verify VxLAN netdevice and
+update mac entries in VxLAN's fdb.
+Change-Id: I22962d4845cba3a258c095f6424557a29d3b354b
+Signed-off-by: Apoorv Gupta <apoogupt@codeaurora.org>
+
+net: vxlan: Added vxlan fdb notify chain
+
+Registered modules are notified based on following events:
+1. RTM_GETNEIGH
+2. RTM_NEWNEIGH
+3. RTM_DELNEIGH
+
+Change-Id: I0802b305a829800cafbabd4728c3c47ff3679938
+Signed-off-by: Cemil Coskun <ccoskun@codeaurora.org>
+Signed-off-by: Apoorv Gupta <apoogupt@codeaurora.org>
+Signed-off-by: Vishnu Vardhan Bantanahal <quic_vishvard@quicinc.com>
+---
+ drivers/net/vxlan/vxlan_core.c | 31 +++++++++++++++++++++++++++++++
+ include/net/vxlan.h            | 29 +++++++++++++++++++++++++++++
+ 2 files changed, 60 insertions(+)
+
+--- a/drivers/net/vxlan/vxlan_core.c
++++ b/drivers/net/vxlan/vxlan_core.c
+@@ -65,6 +65,20 @@ static void vxlan_vs_del_dev(struct vxla
+ /* salt for hash table */
+ static u32 vxlan_salt __read_mostly;
+ 
++ATOMIC_NOTIFIER_HEAD(vxlan_fdb_notifier_list);
++
++void vxlan_fdb_register_notify(struct notifier_block *nb)
++{
++	atomic_notifier_chain_register(&vxlan_fdb_notifier_list, nb);
++}
++EXPORT_SYMBOL(vxlan_fdb_register_notify);
++
++void vxlan_fdb_unregister_notify(struct notifier_block *nb)
++{
++	atomic_notifier_chain_unregister(&vxlan_fdb_notifier_list, nb);
++}
++EXPORT_SYMBOL(vxlan_fdb_unregister_notify);
++
+ static inline bool vxlan_collect_metadata(struct vxlan_sock *vs)
+ {
+ 	return vs->flags & VXLAN_F_COLLECT_METADATA ||
+@@ -260,6 +274,7 @@ static void __vxlan_fdb_notify(struct vx
+ {
+ 	struct net *net = dev_net(vxlan->dev);
+ 	struct sk_buff *skb;
++	struct vxlan_fdb_event vfe;
+ 	int err = -ENOBUFS;
+ 
+ 	skb = nlmsg_new(vxlan_nlmsg_size(), GFP_ATOMIC);
+@@ -275,6 +290,10 @@ static void __vxlan_fdb_notify(struct vx
+ 	}
+ 
+ 	rtnl_notify(skb, net, 0, RTNLGRP_NEIGH, NULL, GFP_ATOMIC);
++	vfe.dev = vxlan->dev;
++	vfe.rdst = rd;
++	ether_addr_copy(vfe.eth_addr, fdb->eth_addr);
++	atomic_notifier_call_chain(&vxlan_fdb_notifier_list, type, (void *)&vfe);
+ 	return;
+ errout:
+ 	if (err < 0)
+@@ -441,6 +460,18 @@ static struct vxlan_fdb *vxlan_find_mac(
+ 	return f;
+ }
+ 
++/* Find and update age of fdb entry corresponding to MAC. */
++void vxlan_fdb_update_mac(struct vxlan_dev *vxlan, const u8 *mac, uint32_t vni)
++{
++	u32 hash_index;
++
++	hash_index = fdb_head_index(vxlan, mac, vni);
++	spin_lock_bh(&vxlan->hash_lock[hash_index]);
++	vxlan_find_mac(vxlan, mac, vni);
++	spin_unlock_bh(&vxlan->hash_lock[hash_index]);
++}
++EXPORT_SYMBOL(vxlan_fdb_update_mac);
++
+ /* caller should hold vxlan->hash_lock */
+ static struct vxlan_rdst *vxlan_fdb_find_rdst(struct vxlan_fdb *f,
+ 					      union vxlan_addr *ip, __be16 port,
+--- a/include/net/vxlan.h
++++ b/include/net/vxlan.h
+@@ -352,6 +352,19 @@ struct vxlan_dev {
+ 					 VXLAN_F_VNIFILTER         |    \
+ 					 VXLAN_F_LOCALBYPASS)
+ 
++/*
++ * Application data for fdb notifier event
++ */
++struct vxlan_fdb_event {
++	struct net_device *dev;
++	struct vxlan_rdst *rdst;
++	u8 eth_addr[ETH_ALEN];
++};
++
++extern void vxlan_fdb_register_notify(struct notifier_block *nb);
++extern void vxlan_fdb_unregister_notify(struct notifier_block *nb);
++extern void vxlan_fdb_update_mac(struct vxlan_dev *vxlan, const u8 *mac, uint32_t vni);
++
+ struct net_device *vxlan_dev_create(struct net *net, const char *name,
+ 				    u8 name_assign_type, struct vxlan_config *conf);
+ 
+@@ -440,6 +453,22 @@ static inline __be32 vxlan_compute_rco(u
+ 	return vni_field;
+ }
+ 
++/*
++ * is_vxlan_dev()
++ *       Check if it is a VxLAN netdevice.
++ */
++static inline bool is_vxlan_dev(const struct net_device *dev)
++{
++	if (!dev)
++		return false;
++
++	if ((dev->dev.type) &&
++		!strncmp(dev->dev.type->name, "vxlan", sizeof("vxlan"))) {
++			return true;
++	}
++	return false;
++}
++
+ static inline unsigned short vxlan_get_sk_family(struct vxlan_sock *vs)
+ {
+ 	return vs->sock->sk->sk_family;
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960282-net-tc-filter-taps-support-for-sfe-path.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,69 @@
+From c8f7549b4a1d08cc6a894a39c31eab8fcaf9cfdd Mon Sep 17 00:00:00 2001
+From: Subhash Kumar Katnapally <quic_skatnapa@quicinc.com>
+Date: Mon, 10 Jul 2023 18:43:50 +0530
+Subject: [PATCH 247/500] net: tc filter/taps support for sfe path
+
+Added sysctl to toggle filter support in sfe path.
+
+Change-Id: I724a96283a7e3436c98505e2da94bf84bc05d5b8
+Signed-off-by: Subhash Kumar Katnapally <quic_skatnapa@quicinc.com>
+---
+ net/core/dev.c | 33 ++++++++++++++++++++++++++++-----
+ 1 file changed, 28 insertions(+), 5 deletions(-)
+
+--- a/net/core/dev.c
++++ b/net/core/dev.c
+@@ -2096,6 +2096,9 @@ static int call_netdevice_notifiers_mtu(
+ 	return call_netdevice_notifiers_info(val, &info.info);
+ }
+ 
++bool fast_tc_filter = false;
++EXPORT_SYMBOL_GPL(fast_tc_filter);
++
+ #ifdef CONFIG_NET_INGRESS
+ static DEFINE_STATIC_KEY_FALSE(ingress_needed_key);
+ 
+@@ -5608,11 +5611,13 @@ another_round:
+ 			goto out;
+ 	}
+ 
+-	fast_recv = rcu_dereference(athrs_fast_nat_recv);
+-	if (fast_recv) {
+-		if (fast_recv(skb)) {
+-			ret = NET_RX_SUCCESS;
+-			goto out;
++	if (likely(!fast_tc_filter)) {
++		fast_recv = rcu_dereference(athrs_fast_nat_recv);
++		if (fast_recv) {
++			if (fast_recv(skb)) {
++				ret = NET_RX_SUCCESS;
++				goto out;
++			}
+ 		}
+ 	}
+ 
+@@ -5668,6 +5673,24 @@ skip_classify:
+ 			goto out;
+ 	}
+ 
++	if (unlikely(!fast_tc_filter)) {
++		goto skip_fast_recv;
++	}
++
++	fast_recv = rcu_dereference(athrs_fast_nat_recv);
++	if (fast_recv) {
++		if (pt_prev) {
++			ret = deliver_skb(skb, pt_prev, orig_dev);
++			pt_prev = NULL;
++		}
++
++		if (fast_recv(skb)) {
++			ret = NET_RX_SUCCESS;
++			goto out;
++		}
++	}
++skip_fast_recv:
++
+ 	rx_handler = rcu_dereference(skb->dev->rx_handler);
+ 	if (rx_handler) {
+ 		if (pt_prev) {
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960283-vlan-Add-vlan-stats-update-function.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,66 @@
+From 8a24a1c2c3cfbf93d661cfb50468b4a9a5a74254 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Tue, 27 Jan 2015 18:06:30 +0000
+Subject: [PATCH 091/500] vlan: Add vlan stats update function
+
+Change-Id: Ib1165b37f29d48e5dbcee2c709b2f873dfb3e34d
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ include/linux/if_vlan.h |  9 +++++++++
+ net/8021q/vlan_core.c   | 20 ++++++++++++++++++++
+ 2 files changed, 29 insertions(+)
+
+--- a/include/linux/if_vlan.h
++++ b/include/linux/if_vlan.h
+@@ -143,6 +143,9 @@ extern struct net_device *__vlan_find_de
+ extern int vlan_for_each(struct net_device *dev,
+ 			 int (*action)(struct net_device *dev, int vid,
+ 				       void *arg), void *arg);
++extern void __vlan_dev_update_accel_stats(struct net_device *dev,
++				    struct rtnl_link_stats64 *stats);
++
+ extern struct net_device *vlan_dev_real_dev(const struct net_device *dev);
+ extern struct net_device *vlan_dev_next_dev(const struct net_device *dev);
+ extern u16 vlan_dev_vlan_id(const struct net_device *dev);
+@@ -237,6 +240,12 @@ extern void vlan_vids_del_by_dev(struct
+ extern bool vlan_uses_dev(const struct net_device *dev);
+ 
+ #else
++static inline void __vlan_dev_update_accel_stats(struct net_device *dev,
++					   struct rtnl_link_stats64 *stats)
++{
++
++}
++
+ static inline struct net_device *
+ __vlan_find_dev_deep_rcu(struct net_device *real_dev,
+ 		     __be16 vlan_proto, u16 vlan_id)
+--- a/net/8021q/vlan_core.c
++++ b/net/8021q/vlan_core.c
+@@ -72,6 +72,26 @@ bool vlan_do_receive(struct sk_buff **sk
+ 	return true;
+ }
+ 
++/* Update the VLAN device with statistics from network offload engines */
++void __vlan_dev_update_accel_stats(struct net_device *dev,
++				   struct rtnl_link_stats64 *nlstats)
++{
++	struct vlan_pcpu_stats *stats;
++
++	if (!is_vlan_dev(dev))
++		return;
++
++	stats = this_cpu_ptr(vlan_dev_priv(dev)->vlan_pcpu_stats);
++
++	u64_stats_update_begin(&stats->syncp);
++	u64_stats_add(&stats->rx_packets, nlstats->rx_packets);
++	u64_stats_add(&stats->rx_bytes, nlstats->rx_bytes);
++	u64_stats_add(&stats->tx_packets, nlstats->tx_packets);
++	u64_stats_add(&stats->tx_bytes, nlstats->tx_bytes);
++	u64_stats_update_end(&stats->syncp);
++}
++EXPORT_SYMBOL(__vlan_dev_update_accel_stats);
++
+ /* Must be invoked with rcu_read_lock. */
+ struct net_device *__vlan_find_dev_deep_rcu(struct net_device *dev,
+ 					__be16 vlan_proto, u16 vlan_id)
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960284-ip_tunnel_core-NULL-pointer-check-before-netif_is_vx.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,113 @@
+From bd7f46b6e8b0ef8a0e74277b9528e27a39af4ea2 Mon Sep 17 00:00:00 2001
+From: Sachin Kohli <quic_sachkohl@quicinc.com>
+Date: Tue, 19 Dec 2023 10:17:14 +0530
+Subject: [PATCH 207/500] ip_tunnel_core: NULL pointer check before
+ netif_is_vxlan
+
+We need to check if in_dev is NULL before calling netif_is_vxlan
+Change-Id: Ia1d38441bf37af691d2afab7f5545a721192e83e
+Signed-off-by: Tian Yang <quic_tiany@quicinc.com>
+Signed-off-by: Vishnu Vardhan Bantanahal <quic_vishvard@quicinc.com>
+
+net: Setting skb input interface to vxlan during encapsulation.
+
+Setting skb_iif to vxlan when encapsulating with IP/IPv6 header.
+Also removed the is_vxlan_dev() API support, as it can be replaced
+by in-built API netif_is_vxlan().
+
+Change-Id: I480d15b2ef2e91038676c620a98217e35e29b002
+Signed-off-by: Apoorv Gupta <apoogupt@codeaurora.org>
+Signed-off-by: Vishnu Vardhan Bantanahal <quic_vishvard@quicinc.com>
+---
+ drivers/net/vxlan/vxlan_core.c |  6 ++++++
+ include/net/vxlan.h            | 15 ++++-----------
+ net/ipv4/ip_tunnel_core.c      | 15 +++++++++++++++
+ 3 files changed, 25 insertions(+), 11 deletions(-)
+
+--- a/drivers/net/vxlan/vxlan_core.c
++++ b/drivers/net/vxlan/vxlan_core.c
+@@ -2631,6 +2631,9 @@ void vxlan_xmit_one(struct sk_buff *skb,
+ 			goto out_unlock;
+ 		}
+ 
++                /* Reset the skb_iif to Tunnels interface index */
++		skb->skb_iif = dev->ifindex;
++
+ 		tos = ip_tunnel_ecn_encap(tos, old_iph, skb);
+ 		ttl = ttl ? : ip4_dst_hoplimit(&rt->dst);
+ 		err = vxlan_build_skb(skb, ndst, sizeof(struct iphdr),
+@@ -2702,6 +2705,9 @@ void vxlan_xmit_one(struct sk_buff *skb,
+ 		if (err < 0)
+ 			goto tx_error;
+ 
++                /* Reset the skb_iif to Tunnels interface index */
++		skb->skb_iif = dev->ifindex;
++
+ 		udp_tunnel6_xmit_skb(ndst, sock6->sock->sk, skb, dev,
+ 				     &local_ip.sin6.sin6_addr,
+ 				     &dst->sin6.sin6_addr, tos, ttl,
+--- a/include/net/vxlan.h
++++ b/include/net/vxlan.h
+@@ -454,19 +454,12 @@ static inline __be32 vxlan_compute_rco(u
+ }
+ 
+ /*
+- * is_vxlan_dev()
+- *       Check if it is a VxLAN netdevice.
++ * vxlan_get_vni()
++ * Returns the vni corresponding to tunnel
+  */
+-static inline bool is_vxlan_dev(const struct net_device *dev)
++static inline u32 vxlan_get_vni(struct vxlan_dev *vxlan_tun)
+ {
+-	if (!dev)
+-		return false;
+-
+-	if ((dev->dev.type) &&
+-		!strncmp(dev->dev.type->name, "vxlan", sizeof("vxlan"))) {
+-			return true;
+-	}
+-	return false;
++	return be32_to_cpu(vxlan_tun->cfg.vni);
+ }
+ 
+ static inline unsigned short vxlan_get_sk_family(struct vxlan_sock *vs)
+--- a/net/ipv4/ip_tunnel_core.c
++++ b/net/ipv4/ip_tunnel_core.c
+@@ -38,6 +38,7 @@
+ #include <net/geneve.h>
+ #include <net/vxlan.h>
+ #include <net/erspan.h>
++#include <net/vxlan.h>
+ 
+ const struct ip_tunnel_encap_ops __rcu *
+ 		iptun_encaps[MAX_IPTUN_ENCAP_OPS] __read_mostly;
+@@ -55,7 +56,12 @@ void iptunnel_xmit(struct sock *sk, stru
+ 	struct net *net = dev_net(rt->dst.dev);
+ 	struct net_device *dev = skb->dev;
+ 	struct iphdr *iph;
++	struct net_device *in_dev = NULL;
+ 	int err;
++	int skb_iif;
++
++	/* Save input interface index */
++        skb_iif = skb->skb_iif;
+ 
+ 	skb_scrub_packet(skb, xnet);
+ 
+@@ -79,6 +85,15 @@ void iptunnel_xmit(struct sock *sk, stru
+ 	iph->ttl	=	ttl;
+ 	__ip_select_ident(net, iph, skb_shinfo(skb)->gso_segs ?: 1);
+ 
++        /* Get input interface */
++	if (skb_iif) {
++		in_dev = __dev_get_by_index(&init_net, skb_iif);
++	}
++
++	if (proto == IPPROTO_IPV6 || proto == IPPROTO_GRE || (in_dev && netif_is_vxlan(in_dev))) {
++		skb->skb_iif = skb_iif;
++	}
++
+ 	err = ip_local_out(net, sk, skb);
+ 
+ 	if (dev) {
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960285-net-openvswitch-Delay-flow-delete-notification.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,25 @@
+From 16fe11fe2f74099dde0be54b8fc4288c4d73f60d Mon Sep 17 00:00:00 2001
+From: Ratheesh Kannoth <rkannoth@codeaurora.org>
+Date: Fri, 27 Nov 2020 07:16:55 +0530
+Subject: [PATCH 286/500] net: openvswitch: Delay flow delete notification
+
+Notify flow delete event after removing from datapath flow table
+
+Change-Id: Ib80da37088b411831d63325b688c64aed7dfecdb
+Signed-off-by: Pavithra R <quic_pavir@quicinc.com>
+---
+ net/openvswitch/datapath.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/net/openvswitch/datapath.c
++++ b/net/openvswitch/datapath.c
+@@ -1543,8 +1543,8 @@ static int ovs_flow_cmd_del(struct sk_bu
+ 		goto unlock;
+ 	}
+ 
+-	ovs_dp_flow_del_notify(dp, flow);
+ 	ovs_flow_tbl_remove(&dp->table, flow);
++	ovs_dp_flow_del_notify(dp, flow);
+ 	ovs_unlock();
+ 
+ 	reply = ovs_flow_cmd_alloc_info((const struct sw_flow_actions __force *) flow->sf_acts,
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960286-openvswitch-Update-function-to-search-OVS-flow-rule-.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,105 @@
+From 50e6a8c8eed6db36079b6c91647316ea5927686a Mon Sep 17 00:00:00 2001
+From: Suman Ghosh <sumaghos@codeaurora.org>
+Date: Wed, 4 Nov 2020 13:34:19 +0530
+Subject: [PATCH 285/500] openvswitch: Update function to search OVS flow rule
+ by MAC address for Multicast
+
+Change-Id: Ie8f65c22dd7578a9a09370a10f67333228d45722
+Signed-off-by: Pavithra R <quic_pavir@quicinc.com>
+---
+ net/openvswitch/datapath.c | 40 +++++++++++++++++++++++++++-----------
+ net/openvswitch/datapath.h |  3 ++-
+ 2 files changed, 31 insertions(+), 12 deletions(-)
+
+--- a/net/openvswitch/datapath.c
++++ b/net/openvswitch/datapath.c
+@@ -2620,7 +2620,8 @@ EXPORT_SYMBOL(ovs_accel_flow_find);
+ 
+ /* Find datapath flow rule using MAC addresses*/
+ struct sw_flow *ovs_accel_flow_find_by_mac(void *dp_inst,
+-						struct net_device *br_dev,
++						struct net_device *indev,
++						struct net_device *outdev,
+ 						uint8_t *smac, uint8_t *dmac, uint16_t type)
+ {
+ 	struct datapath *dp = dp_inst;
+@@ -2628,8 +2629,8 @@ struct sw_flow *ovs_accel_flow_find_by_m
+ 	struct sw_flow *flow = NULL;
+ 	struct sw_flow_actions *sf_acts;
+ 	const struct nlattr *a;
++	struct vport *vport;
+ 	bool flow_found = false;
+-	int egress_ports = 0;
+ 	int rem;
+ 	int i;
+ 
+@@ -2660,13 +2661,35 @@ found:
+ 	}
+ 
+ 	/*
+-	 * Flow is found, check if output action is br_dev
++	 * Flow is found, check if ingress port matches indev
++	 */
++	if (!indev) {
++		goto check_outdev;
++	}
++
++	vport = ovs_vport_ovsl_rcu(dp, flow->key.phy.in_port);
++	if (!vport || (indev != vport->dev)) {
++		rcu_read_unlock();
++		return NULL;
++	}
++
++check_outdev:
++	/*
++	 * if outdev is NULL, then the API is called
++	 * to find the flow only
++	 */
++	if (!outdev) {
++		rcu_read_unlock();
++		return flow;
++	}
++
++	/*
++	 * Flow is found, check if output action is outdev
+ 	 */
+ 	flow_found = false;
+ 	sf_acts = rcu_dereference(flow->sf_acts);
+ 	for (a = sf_acts->actions, rem = sf_acts->actions_len; rem > 0;
+ 			a = nla_next(a, &rem)) {
+-		struct vport *vport;
+ 		int port_no;
+ 
+ 		if (nla_type(a) != OVS_ACTION_ATTR_OUTPUT)
+@@ -2675,17 +2698,12 @@ found:
+ 		port_no = nla_get_u32(a);
+ 		vport = ovs_vport_ovsl_rcu(dp, port_no);
+ 
+-		if (vport && (br_dev == vport->dev)) {
++		if (vport && (outdev == vport->dev)) {
+ 			flow_found = true;
+ 		}
+-		egress_ports++;
+ 	}
+ 
+-	/*
+-	 * flow should be unicast and egress port should be
+-	 * bridge interface.
+-	 */
+-	if (!flow_found || (egress_ports != 1))
++	if (!flow_found)
+ 		flow = NULL;
+ 
+ 	rcu_read_unlock();
+--- a/net/openvswitch/datapath.h
++++ b/net/openvswitch/datapath.h
+@@ -315,7 +315,8 @@ struct net_device *ovs_accel_egress_dev_
+ 					     struct sk_buff *skb);
+ 
+ struct sw_flow *ovs_accel_flow_find_by_mac(void *dp_inst,
+-						struct net_device *br_dev,
++						struct net_device *indev,
++						struct net_device *outdev,
+ 						uint8_t *smac, uint8_t *dmac, uint16_t type);
+ 
+ /* 'KEY' must not have any bits set outside of the 'MASK' */
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960288-net-OVS-Handle-netdev-unregister.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,55 @@
+From 0eac6181aedd615aedfb686bf8b63d44b4716609 Mon Sep 17 00:00:00 2001
+From: Subhash Kumar Katnapally <quic_skatnapa@quicinc.com>
+Date: Tue, 6 Sep 2022 14:39:55 +0530
+Subject: [PATCH 287/500] net: OVS: Handle netdev unregister
+
+Trigger ovsmgr port deletion during openvswitch netdev unregister handling.
+
+Change-Id: If59360cd89a39294876a4b577afd0bbf98212718
+Signed-off-by: Subhash Kumar Katnapally <quic_skatnapa@quicinc.com>
+Signed-off-by: Pavithra R <quic_pavir@quicinc.com>
+---
+ net/openvswitch/datapath.c  | 3 ++-
+ net/openvswitch/datapath.h  | 1 +
+ net/openvswitch/dp_notify.c | 1 +
+ 3 files changed, 4 insertions(+), 1 deletion(-)
+
+--- a/net/openvswitch/datapath.c
++++ b/net/openvswitch/datapath.c
+@@ -288,7 +288,7 @@ static void ovs_dp_port_add_notify(struc
+ }
+ 
+ /* Notify datapath port delete event to acceleration callback */
+-static void ovs_dp_port_del_notify(struct datapath *dp, struct vport *vp)
++void ovs_dp_port_del_notify(struct datapath *dp, struct vport *vp)
+ {
+ 	struct ovs_accel_callback *ovs_cb;
+ 
+@@ -2822,6 +2822,7 @@ struct net_device *ovs_accel_egress_dev_
+ 			}
+ 
+ 			dev = vport->dev;
++			dev_hold(dev);
+ 			rcu_read_unlock();
+ 			return dev;
+ 		}
+--- a/net/openvswitch/datapath.h
++++ b/net/openvswitch/datapath.h
+@@ -289,6 +289,7 @@ void ovs_dp_detach_port(struct vport *);
+ int ovs_dp_upcall(struct datapath *, struct sk_buff *,
+ 		  const struct sw_flow_key *, const struct dp_upcall_info *,
+ 		  uint32_t cutlen);
++void ovs_dp_port_del_notify(struct datapath *dp, struct vport *vp);
+ 
+ u32 ovs_dp_get_upcall_portid(const struct datapath *dp, uint32_t cpu_id);
+ 
+--- a/net/openvswitch/dp_notify.c
++++ b/net/openvswitch/dp_notify.c
+@@ -19,6 +19,7 @@ static void dp_detach_port_notify(struct
+ 	dp = vport->dp;
+ 	notify = ovs_vport_cmd_build_info(vport, ovs_dp_get_net(dp),
+ 					  0, 0, OVS_VPORT_CMD_DEL);
++	ovs_dp_port_del_notify(vport->dp, vport);
+ 	ovs_dp_detach_port(vport);
+ 	if (IS_ERR(notify)) {
+ 		genl_set_err(&dp_vport_genl_family, ovs_dp_get_net(dp), 0,
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960289-net-OVS-Avoid-egress-port-return-during-learning.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,63 @@
+From 1b137fb6c601c1e75a95cd04f290cef4f6b9f6bc Mon Sep 17 00:00:00 2001
+From: Subhash Kumar Katnapally <quic_skatnapa@quicinc.com>
+Date: Thu, 19 Jan 2023 20:23:27 +0530
+Subject: [PATCH 288/500] net: OVS: Avoid egress port return during learning
+
+When ecm queries for egress port, make sure the flow
+rule has only single interface as actions. If the destination
+mac address is not learnt or existing port goes away, ovs would
+add try forwarding the flow on all ports and hence has multiple
+actions. This patch returns NULL if there are more than one
+device.
+
+Change-Id: Iebe7dfe893e2823a30d4a68ffb55cd2816452624
+Signed-off-by: Subhash Kumar Katnapally <quic_skatnapa@quicinc.com>
+Signed-off-by: Pavithra R <quic_pavir@quicinc.com>
+---
+ net/openvswitch/datapath.c | 22 ++++++++++++++++++----
+ 1 file changed, 18 insertions(+), 4 deletions(-)
+
+--- a/net/openvswitch/datapath.c
++++ b/net/openvswitch/datapath.c
+@@ -2801,6 +2801,7 @@ struct net_device *ovs_accel_egress_dev_
+ 	struct net_device *dev;
+ 	const struct nlattr *a;
+ 	int rem;
++	int egress_cnt = 0;
+ 
+ 	rcu_read_lock();
+ 	flow = ovs_accel_flow_find(dp_inst, key);
+@@ -2817,16 +2818,29 @@ struct net_device *ovs_accel_egress_dev_
+ 		case OVS_ACTION_ATTR_OUTPUT:
+ 			port_no = nla_get_u32(a);
+ 			vport = ovs_vport_ovsl_rcu(dp, port_no);
+-			if (!vport) {
++
++			/*
++			 * Avoid offloading flows with internal port as egress port
++			 */
++			if (!vport || (vport->ops->type == OVS_VPORT_TYPE_INTERNAL)) {
+ 				goto done;
+ 			}
+ 
+ 			dev = vport->dev;
+-			dev_hold(dev);
+-			rcu_read_unlock();
+-			return dev;
++			egress_cnt++;
+ 		}
+ 	}
++
++	/*
++	 * Return dev only if flow is not a broadcast i.e.
++	 * there is only one egress interface for the flow
++	 */
++	if (egress_cnt == 1) {
++		dev_hold(dev);
++		rcu_read_unlock();
++		return dev;
++	}
++
+ done:
+ 	rcu_read_unlock();
+ 	return NULL;
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960302-l2tp-Add-support-for-l2tpv3.patch	2024-12-13 18:14:14.979309587 +0800
@@ -0,0 +1,53 @@
+From 529cb4df6a33a762b2f08ce42aafe19d727da44e Mon Sep 17 00:00:00 2001
+From: Karthik T S <quic_kartikts@quicinc.com>
+Date: Wed, 25 Oct 2023 20:48:04 +0530
+Subject: [PATCH 334/500] l2tp: Add support for l2tpv3
+
+1. Add "IFF_EXT_ETH_L2TPV3" flag in netdev to identify l2tp ethernet dev type.
+2. IFF_EXT_ETH_L2TPV3 is set in "priv_flags_ext" field of netdev structure during netdevice intiialization.
+3. Update the skb->skb->iif to copy interface index for all packets sent out on l2tpv3  ethernetinterface
+
+Change-Id: I6ea7acae47fae8eac30f45bd7dbeb72e907df469
+Signed-off-by: Karthik T S <quic_kartikts@quicinc.com>
+---
+ include/linux/netdevice.h | 2 ++
+ net/l2tp/l2tp_eth.c       | 3 +++
+ 2 files changed, 5 insertions(+)
+
+--- a/include/linux/netdevice.h
++++ b/include/linux/netdevice.h
+@@ -1775,6 +1775,7 @@ enum netdev_priv_flags {
+  * @IFF_EXT_GRE_V6_TAP: device is a GRE IPv6 TAP device
+  * @IFF_EXT_IFB: device is an IFB device
+  * @IFF_EXT_MAPT: device is an MAPT device
++ * @IFF_EXT_L2TPV3: device is a L2TPV3 Ethernet device
+  */
+ enum netdev_priv_flags_ext {
+ 	IFF_EXT_TUN_TAP			= 1<<0,
+@@ -1786,6 +1787,7 @@ enum netdev_priv_flags_ext {
+ 	IFF_EXT_IFB				= 1<<6,
+ 	IFF_EXT_MAPT			= 1<<7,
+ 	IFF_EXT_HW_NO_OFFLOAD		= 1<<8,
++	IFF_EXT_ETH_L2TPV3		= 1<<9,
+ };
+ 
+ #define IFF_802_1Q_VLAN			IFF_802_1Q_VLAN
+--- a/net/l2tp/l2tp_eth.c
++++ b/net/l2tp/l2tp_eth.c
+@@ -76,6 +76,8 @@ static netdev_tx_t l2tp_eth_dev_xmit(str
+ 	struct l2tp_eth *priv = netdev_priv(dev);
+ 	struct l2tp_session *session = priv->session;
+ 	unsigned int len = skb->len;
++
++	skb->skb_iif = dev->ifindex;
+ 	int ret = l2tp_xmit_skb(session, skb);
+ 
+ 	if (likely(ret == NET_XMIT_SUCCESS)) {
+@@ -117,6 +119,7 @@ static void l2tp_eth_dev_setup(struct ne
+ 	SET_NETDEV_DEVTYPE(dev, &l2tpeth_type);
+ 	ether_setup(dev);
+ 	dev->priv_flags		&= ~IFF_TX_SKB_SHARING;
++	dev->priv_flags_ext     |= IFF_EXT_ETH_L2TPV3;
+ 	dev->features		|= NETIF_F_LLTX;
+ 	dev->netdev_ops		= &l2tp_eth_netdev_ops;
+ 	dev->needs_free_netdev	= true;
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960315-vxlan-Get-the-remote-IP-address-of-the-given-client.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,63 @@
+From d0e5729c16c85ec731c9e1fbc49d072380680bc3 Mon Sep 17 00:00:00 2001
+From: Sachin Kohli <quic_sachkohl@quicinc.com>
+Date: Tue, 19 Dec 2023 10:11:20 +0530
+Subject: [PATCH 351/500] vxlan: Get the remote IP address of the given client.
+
+Given a mac address of the client and the netdevice,
+return the remote IP address used by the client.
+
+Change-Id: I3b241ea0faec61205054d8a41ed45bc10c706031
+Signed-off-by: Sneha Maganahalli <quic_smaganah@quicinc.com>
+Signed-off-by: Vishnu Vardhan Bantanahal <quic_vishvard@quicinc.com>
+---
+ drivers/net/vxlan/vxlan_core.c | 25 +++++++++++++++++++++++++
+ include/net/vxlan.h            |  4 ++++
+ 2 files changed, 29 insertions(+)
+
+--- a/drivers/net/vxlan/vxlan_core.c
++++ b/drivers/net/vxlan/vxlan_core.c
+@@ -460,6 +460,31 @@ static struct vxlan_fdb *vxlan_find_mac(
+ 	return f;
+ }
+ 
++/* Get the remote IP address of the given client */
++int vxlan_find_remote_ip(struct vxlan_dev *vxlan,
++				const u8 *mac, __be32 vni, union vxlan_addr *rip)
++{
++	struct vxlan_fdb *f = NULL;
++	struct vxlan_rdst *rd = NULL;
++
++	rcu_read_lock();
++	f = __vxlan_find_mac(vxlan, mac, vni);
++	if (!f) {
++		rcu_read_unlock();
++		return -1;
++	}
++	list_for_each_entry(rd, &f->remotes, list) {
++		if (rd->remote_vni == vni) {
++			memcpy(rip, &rd->remote_ip, sizeof(union vxlan_addr));
++			rcu_read_unlock();
++			return 0;
++		}
++	}
++	rcu_read_unlock();
++	return -1;
++}
++EXPORT_SYMBOL_GPL(vxlan_find_remote_ip);
++
+ /* Find and update age of fdb entry corresponding to MAC. */
+ void vxlan_fdb_update_mac(struct vxlan_dev *vxlan, const u8 *mac, uint32_t vni)
+ {
+--- a/include/net/vxlan.h
++++ b/include/net/vxlan.h
+@@ -363,6 +363,10 @@ struct vxlan_fdb_event {
+ 
+ extern void vxlan_fdb_register_notify(struct notifier_block *nb);
+ extern void vxlan_fdb_unregister_notify(struct notifier_block *nb);
++
++extern int vxlan_find_remote_ip(struct vxlan_dev *vxlan, const u8 *mac, __be32 vni,
++		                union vxlan_addr *rip);
++
+ extern void vxlan_fdb_update_mac(struct vxlan_dev *vxlan, const u8 *mac, uint32_t vni);
+ 
+ struct net_device *vxlan_dev_create(struct net *net, const char *name,
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960316-net-Add-DSCP-remarking-feature-for-HW-acceleration.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,143 @@
+From 9e984fe0cbc5e1ec616f52f1964cc0b4e158138a Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <quic_msezgin@quicinc.com>
+Date: Thu, 11 May 2023 11:54:05 -0700
+Subject: [PATCH 352/500] net: Add DSCP remarking feature for HW acceleration.
+
+DSCP remarking is an advanced QoS feature of acceleration
+engine. With this feature it is possible to set the accelerated
+eggress packets' DSCP values with iptables command.
+
+Change-Id: I7fa8d8a2a87b66b262d54e25f22e9eedd665c456
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+Signed-off-by: Murat Sezgin <quic_msezgin@quicinc.com>
+---
+ include/net/netfilter/nf_conntrack_extend.h |  3 +++
+ net/netfilter/Kconfig                       |  7 ++++++
+ net/netfilter/Makefile                      |  1 +
+ net/netfilter/nf_conntrack_core.c           |  6 +++++
+ net/netfilter/xt_DSCP.c                     | 27 ++++++++++++++++++++-
+ 5 files changed, 43 insertions(+), 1 deletion(-)
+
+--- a/include/net/netfilter/nf_conntrack_extend.h
++++ b/include/net/netfilter/nf_conntrack_extend.h
+@@ -31,6 +31,9 @@ enum nf_ct_ext_id {
+ #if IS_ENABLED(CONFIG_NET_ACT_CT)
+ 	NF_CT_EXT_ACT_CT,
+ #endif
++#ifdef CONFIG_NF_CONNTRACK_DSCPREMARK_EXT
++	NF_CT_EXT_DSCPREMARK,
++#endif
+ 	NF_CT_EXT_NUM,
+ };
+ 
+--- a/net/netfilter/Kconfig
++++ b/net/netfilter/Kconfig
+@@ -174,6 +174,13 @@ config NF_CONNTRACK_TIMEOUT
+ 
+ 	  If unsure, say `N'.
+ 
++config NF_CONNTRACK_DSCPREMARK_EXT
++	bool  'Connection tracking extension for dscp remark target'
++	depends on NETFILTER_ADVANCED
++	help
++	  This option enables support for connection tracking extension
++	  for dscp remark.
++
+ config NF_CONNTRACK_TIMESTAMP
+ 	bool  'Connection tracking timestamping'
+ 	depends on NETFILTER_ADVANCED
+--- a/net/netfilter/Makefile
++++ b/net/netfilter/Makefile
+@@ -20,6 +20,7 @@ nf_conntrack-$(CONFIG_DEBUG_INFO_BTF_MOD
+ else ifeq ($(CONFIG_NF_CONNTRACK),y)
+ nf_conntrack-$(CONFIG_DEBUG_INFO_BTF) += nf_conntrack_bpf.o
+ endif
++nf_conntrack-$(CONFIG_NF_CONNTRACK_DSCPREMARK_EXT) += nf_conntrack_dscpremark_ext.o
+ 
+ obj-$(CONFIG_NETFILTER) = netfilter.o
+ obj-$(CONFIG_NETFILTER_BPF_LINK) += nf_bpf_link.o
+--- a/net/netfilter/nf_conntrack_core.c
++++ b/net/netfilter/nf_conntrack_core.c
+@@ -45,6 +45,9 @@
+ #include <net/netfilter/nf_conntrack_zones.h>
+ #include <net/netfilter/nf_conntrack_timestamp.h>
+ #include <net/netfilter/nf_conntrack_timeout.h>
++#ifdef CONFIG_NF_CONNTRACK_DSCPREMARK_EXT
++#include <net/netfilter/nf_conntrack_dscpremark_ext.h>
++#endif
+ #include <net/netfilter/nf_conntrack_labels.h>
+ #include <net/netfilter/nf_conntrack_synproxy.h>
+ #include <net/netfilter/nf_nat.h>
+@@ -1740,6 +1743,9 @@ init_conntrack(struct net *net, struct n
+ 	nf_ct_acct_ext_add(ct, GFP_ATOMIC);
+ 	nf_ct_tstamp_ext_add(ct, GFP_ATOMIC);
+ 	nf_ct_labels_ext_add(ct);
++#ifdef CONFIG_NF_CONNTRACK_DSCPREMARK_EXT
++	nf_ct_dscpremark_ext_add(ct, GFP_ATOMIC);
++#endif
+ 
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
+ 	ecache = tmpl ? nf_ct_ecache_find(tmpl) : NULL;
+--- a/net/netfilter/xt_DSCP.c
++++ b/net/netfilter/xt_DSCP.c
+@@ -15,6 +15,9 @@
+ 
+ #include <linux/netfilter/x_tables.h>
+ #include <linux/netfilter/xt_DSCP.h>
++#ifdef CONFIG_NF_CONNTRACK_DSCPREMARK_EXT
++#include <net/netfilter/nf_conntrack_dscpremark_ext.h>
++#endif
+ 
+ MODULE_AUTHOR("Harald Welte <laforge@netfilter.org>");
+ MODULE_DESCRIPTION("Xtables: DSCP/TOS field modification");
+@@ -31,6 +34,10 @@ dscp_tg(struct sk_buff *skb, const struc
+ {
+ 	const struct xt_DSCP_info *dinfo = par->targinfo;
+ 	u_int8_t dscp = ipv4_get_dsfield(ip_hdr(skb)) >> XT_DSCP_SHIFT;
++#ifdef CONFIG_NF_CONNTRACK_DSCPREMARK_EXT
++	struct nf_conn *ct;
++	enum ip_conntrack_info ctinfo;
++#endif
+ 
+ 	if (dscp != dinfo->dscp) {
+ 		if (skb_ensure_writable(skb, sizeof(struct iphdr)))
+@@ -39,6 +46,13 @@ dscp_tg(struct sk_buff *skb, const struc
+ 		ipv4_change_dsfield(ip_hdr(skb), XT_DSCP_ECN_MASK,
+ 				    dinfo->dscp << XT_DSCP_SHIFT);
+ 
++#ifdef CONFIG_NF_CONNTRACK_DSCPREMARK_EXT
++		ct = nf_ct_get(skb, &ctinfo);
++		if (!ct)
++			return XT_CONTINUE;
++
++		nf_conntrack_dscpremark_ext_set_dscp_rule_valid(ct);
++#endif
+ 	}
+ 	return XT_CONTINUE;
+ }
+@@ -48,13 +62,24 @@ dscp_tg6(struct sk_buff *skb, const stru
+ {
+ 	const struct xt_DSCP_info *dinfo = par->targinfo;
+ 	u_int8_t dscp = ipv6_get_dsfield(ipv6_hdr(skb)) >> XT_DSCP_SHIFT;
+-
++#ifdef CONFIG_NF_CONNTRACK_DSCPREMARK_EXT
++	struct nf_conn *ct;
++	enum ip_conntrack_info ctinfo;
++#endif
+ 	if (dscp != dinfo->dscp) {
+ 		if (skb_ensure_writable(skb, sizeof(struct ipv6hdr)))
+ 			return NF_DROP;
+ 
+ 		ipv6_change_dsfield(ipv6_hdr(skb), XT_DSCP_ECN_MASK,
+ 				    dinfo->dscp << XT_DSCP_SHIFT);
++
++#ifdef CONFIG_NF_CONNTRACK_DSCPREMARK_EXT
++		ct = nf_ct_get(skb, &ctinfo);
++		if (!ct)
++			return XT_CONTINUE;
++
++		nf_conntrack_dscpremark_ext_set_dscp_rule_valid(ct);
++#endif
+ 	}
+ 	return XT_CONTINUE;
+ }
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960336-net-conntrack-events-support-multiple-registrant.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,339 @@
+From 0d05596ba18a44aca87082b75989bb4114f896d8 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Tue, 18 Apr 2017 15:48:01 -0700
+Subject: [PATCH 353/500] net: conntrack events, support multiple registrant
+
+Change-Id: Iebfb254590fb594f5baf232f849d1b7ae45ef757
+Signed-off-by: Zhi Chen <zhichen@codeaurora.org>
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ include/net/netfilter/nf_conntrack_ecache.h | 45 +++++++++++++-
+ include/net/netns/conntrack.h               |  3 +
+ net/netfilter/Kconfig                       |  8 +++
+ net/netfilter/nf_conntrack_core.c           |  3 +
+ net/netfilter/nf_conntrack_ecache.c         | 67 +++++++++++++++++++++
+ net/netfilter/nf_conntrack_netlink.c        | 25 +++++++-
+ 6 files changed, 148 insertions(+), 3 deletions(-)
+
+--- a/include/net/netfilter/nf_conntrack_ecache.h
++++ b/include/net/netfilter/nf_conntrack_ecache.h
+@@ -65,13 +65,52 @@ struct nf_ct_event_notifier {
+ 	int (*exp_event)(unsigned int events, const struct nf_exp_event *item);
+ };
+ 
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++extern int nf_conntrack_register_notifier(struct net *net,
++					  struct notifier_block *nb);
++extern int nf_conntrack_unregister_notifier(struct net *net,
++					    struct notifier_block *nb);
++static inline int
++nf_conntrack_eventmask_report(unsigned int eventmask,
++			      struct nf_conn *ct,
++			      u32 portid,
++			      int report)
++{
++	struct nf_conntrack_ecache *e;
++	struct net *net = nf_ct_net(ct);
++
++	e = nf_ct_ecache_find(ct);
++	if (e == NULL)
++		return 0;
++
++	if (nf_ct_is_confirmed(ct)) {
++		struct nf_ct_event item = {
++			.ct = ct,
++			.portid = e->portid ? e->portid : portid,
++			.report = report
++		};
++		/* This is a resent of a destroy event? If so, skip missed */
++		unsigned long missed = e->portid ? 0 : e->missed;
++
++		if (!((eventmask | missed) & e->ctmask))
++			return 0;
++
++		atomic_notifier_call_chain(&net->ct.nf_conntrack_chain,
++					   eventmask | missed, &item);
++	}
++
++	return 0;
++}
++#else
+ void nf_conntrack_register_notifier(struct net *net,
+ 				   const struct nf_ct_event_notifier *nb);
+ void nf_conntrack_unregister_notifier(struct net *net);
+ 
+-void nf_ct_deliver_cached_events(struct nf_conn *ct);
+ int nf_conntrack_eventmask_report(unsigned int eventmask, struct nf_conn *ct,
+ 				  u32 portid, int report);
++#endif
++
++void nf_ct_deliver_cached_events(struct nf_conn *ct);
+ 
+ bool nf_ct_ecache_ext_add(struct nf_conn *ct, u16 ctmask, u16 expmask, gfp_t gfp);
+ #else
+@@ -98,11 +137,13 @@ static inline void
+ nf_conntrack_event_cache(enum ip_conntrack_events event, struct nf_conn *ct)
+ {
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
+-	struct net *net = nf_ct_net(ct);
+ 	struct nf_conntrack_ecache *e;
++#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	struct net *net = nf_ct_net(ct);
+ 
+ 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
+ 		return;
++#endif
+ 
+ 	e = nf_ct_ecache_find(ct);
+ 	if (e == NULL)
+--- a/include/net/netns/conntrack.h
++++ b/include/net/netns/conntrack.h
+@@ -104,6 +104,9 @@ struct netns_ct {
+ 	u8			sysctl_checksum;
+ 
+ 	struct ip_conntrack_stat __percpu *stat;
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	struct atomic_notifier_head nf_conntrack_chain;
++#endif
+ 	struct nf_ct_event_notifier __rcu *nf_conntrack_event_cb;
+ 	struct nf_ip_net	nf_ct_proto;
+ #if defined(CONFIG_NF_CONNTRACK_LABELS)
+--- a/net/netfilter/Kconfig
++++ b/net/netfilter/Kconfig
+@@ -181,6 +181,14 @@ config NF_CONNTRACK_DSCPREMARK_EXT
+ 	  This option enables support for connection tracking extension
+ 	  for dscp remark.
+ 
++config NF_CONNTRACK_CHAIN_EVENTS
++	bool "Register multiple callbacks to ct events"
++	depends on NF_CONNTRACK_EVENTS
++	help
++	  Support multiple registrations.
++
++	  If unsure, say `N'.
++
+ config NF_CONNTRACK_TIMESTAMP
+ 	bool  'Connection tracking timestamping'
+ 	depends on NETFILTER_ADVANCED
+--- a/net/netfilter/nf_conntrack_core.c
++++ b/net/netfilter/nf_conntrack_core.c
+@@ -2804,6 +2804,9 @@ int nf_conntrack_init_net(struct net *ne
+ 	nf_conntrack_ecache_pernet_init(net);
+ 	nf_conntrack_proto_pernet_init(net);
+ 
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	ATOMIC_INIT_NOTIFIER_HEAD(&net->ct.nf_conntrack_chain);
++#endif
+ 	return 0;
+ 
+ err_expect:
+--- a/net/netfilter/nf_conntrack_ecache.c
++++ b/net/netfilter/nf_conntrack_ecache.c
+@@ -16,6 +16,9 @@
+ #include <linux/vmalloc.h>
+ #include <linux/stddef.h>
+ #include <linux/err.h>
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++#include <linux/notifier.h>
++#endif
+ #include <linux/kernel.h>
+ #include <linux/netdevice.h>
+ #include <linux/slab.h>
+@@ -124,6 +127,7 @@ static void ecache_work(struct work_stru
+ 		schedule_delayed_work(&cnet->ecache.dwork, delay);
+ }
+ 
++#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
+ static int __nf_conntrack_eventmask_report(struct nf_conntrack_ecache *e,
+ 					   const u32 events,
+ 					   const u32 missed,
+@@ -198,9 +202,56 @@ int nf_conntrack_eventmask_report(unsign
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(nf_conntrack_eventmask_report);
++#endif
+ 
+ /* deliver cached events and clear cache entry - must be called with locally
+  * disabled softirqs */
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++void nf_ct_deliver_cached_events(struct nf_conn *ct)
++{
++	unsigned long events, missed;
++	struct nf_conntrack_ecache *e;
++	struct nf_ct_event item;
++	struct net *net = nf_ct_net(ct);
++	int ret = 0;
++
++	e = nf_ct_ecache_find(ct);
++	if (!e)
++		return;
++
++	events = xchg(&e->cache, 0);
++
++	if (!nf_ct_is_confirmed(ct) || nf_ct_is_dying(ct) || !events)
++		return;
++
++	/*
++	 * We make a copy of the missed event cache without taking
++	 * the lock, thus we may send missed events twice. However,
++	 * this does not harm and it happens very rarely.
++	 */
++	missed = e->missed;
++
++	if (!((events | missed) & e->ctmask))
++		return;
++
++	item.ct = ct;
++	item.portid = 0;
++	item.report = 0;
++
++	atomic_notifier_call_chain(&net->ct.nf_conntrack_chain,
++				   events | missed, &item);
++
++	if (likely(ret >= 0 && !missed))
++		return;
++
++	spin_lock_bh(&ct->lock);
++	if (ret < 0)
++		e->missed |= events;
++	else
++		e->missed &= ~missed;
++	spin_unlock_bh(&ct->lock);
++}
++#else
+ void nf_ct_deliver_cached_events(struct nf_conn *ct)
+ {
+ 	struct nf_conntrack_ecache *e;
+@@ -226,6 +277,7 @@ void nf_ct_deliver_cached_events(struct
+ 	 */
+ 	__nf_conntrack_eventmask_report(e, events, e->missed, &item);
+ }
++#endif
+ EXPORT_SYMBOL_GPL(nf_ct_deliver_cached_events);
+ 
+ void nf_ct_expect_event_report(enum ip_conntrack_expect_events event,
+@@ -258,6 +310,12 @@ out_unlock:
+ 	rcu_read_unlock();
+ }
+ 
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++int nf_conntrack_register_notifier(struct net *net, struct notifier_block *nb)
++{
++	return atomic_notifier_chain_register(&net->ct.nf_conntrack_chain, nb);
++}
++#else
+ void nf_conntrack_register_notifier(struct net *net,
+ 				    const struct nf_ct_event_notifier *new)
+ {
+@@ -270,8 +328,16 @@ void nf_conntrack_register_notifier(stru
+ 	rcu_assign_pointer(net->ct.nf_conntrack_event_cb, new);
+ 	mutex_unlock(&nf_ct_ecache_mutex);
+ }
++#endif
+ EXPORT_SYMBOL_GPL(nf_conntrack_register_notifier);
+ 
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++int nf_conntrack_unregister_notifier(struct net *net, struct notifier_block *nb)
++{
++	return atomic_notifier_chain_unregister(&net->ct.nf_conntrack_chain,
++						nb);
++}
++#else
+ void nf_conntrack_unregister_notifier(struct net *net)
+ {
+ 	mutex_lock(&nf_ct_ecache_mutex);
+@@ -279,6 +345,7 @@ void nf_conntrack_unregister_notifier(st
+ 	mutex_unlock(&nf_ct_ecache_mutex);
+ 	/* synchronize_rcu() is called after netns pre_exit */
+ }
++#endif
+ EXPORT_SYMBOL_GPL(nf_conntrack_unregister_notifier);
+ 
+ void nf_conntrack_ecache_work(struct net *net, enum nf_ct_ecache_state state)
+--- a/net/netfilter/nf_conntrack_netlink.c
++++ b/net/netfilter/nf_conntrack_netlink.c
+@@ -28,6 +28,9 @@
+ #include <linux/netlink.h>
+ #include <linux/spinlock.h>
+ #include <linux/interrupt.h>
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++#include <linux/notifier.h>
++#endif
+ #include <linux/slab.h>
+ #include <linux/siphash.h>
+ 
+@@ -719,18 +722,26 @@ static size_t ctnetlink_nlmsg_size(const
+ 	       ;
+ }
+ 
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++static int ctnetlink_conntrack_event(struct notifier_block *this,
++				     unsigned long events, void *ptr)
++#else
+ static int
+ ctnetlink_conntrack_event(unsigned int events, const struct nf_ct_event *item)
++#endif
+ {
+ 	const struct nf_conntrack_zone *zone;
+ 	struct net *net;
+ 	struct nlmsghdr *nlh;
+ 	struct nlattr *nest_parms;
+-	struct nf_conn *ct = item->ct;
+ 	struct sk_buff *skb;
+ 	unsigned int type;
+ 	unsigned int flags = 0, group;
+ 	int err;
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	struct nf_ct_event *item = (struct nf_ct_event *)ptr;
++#endif
++	struct nf_conn *ct = item->ct;
+ 
+ 	if (events & (1 << IPCT_DESTROY)) {
+ 		type = IPCTNL_MSG_CT_DELETE;
+@@ -3089,6 +3100,7 @@ nla_put_failure:
+ }
+ 
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
++#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
+ static int
+ ctnetlink_expect_event(unsigned int events, const struct nf_exp_event *item)
+ {
+@@ -3138,6 +3150,7 @@ errout:
+ 	return 0;
+ }
+ #endif
++#endif
+ static int ctnetlink_exp_done(struct netlink_callback *cb)
+ {
+ 	if (cb->args[1])
+@@ -3748,11 +3761,17 @@ static int ctnetlink_stat_exp_cpu(struct
+ }
+ 
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++static struct notifier_block ctnl_notifier = {
++	.notifier_call = ctnetlink_conntrack_event,
++};
++#else
+ static struct nf_ct_event_notifier ctnl_notifier = {
+ 	.ct_event = ctnetlink_conntrack_event,
+ 	.exp_event = ctnetlink_expect_event,
+ };
+ #endif
++#endif
+ 
+ static const struct nfnl_callback ctnl_cb[IPCTNL_MSG_MAX] = {
+ 	[IPCTNL_MSG_CT_NEW]	= {
+@@ -3851,8 +3870,12 @@ static int __net_init ctnetlink_net_init
+ static void ctnetlink_net_pre_exit(struct net *net)
+ {
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	nf_conntrack_unregister_notifier(net, &ctnl_notifier);
++#else
+ 	nf_conntrack_unregister_notifier(net);
+ #endif
++#endif
+ }
+ 
+ static struct pernet_operations ctnetlink_net_ops = {
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960337-net-Move-skb_vlan_untag-skb-after-sfe-hook.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,79 @@
+From 5fcf20d94d49ec2b8a0fae1b2119e3fae91c4fdc Mon Sep 17 00:00:00 2001
+From: Ratheesh Kannoth <quic_rkannoth@quicinc.com>
+Date: Fri, 17 Dec 2021 19:17:58 +0530
+Subject: [PATCH 356/500] net: Move skb_vlan_untag(skb) after sfe hook
+
+Change-Id: I5a019761f363dd81bf5e52eea606b9076f22e6af
+Signed-off-by: Ratheesh Kannoth <quic_rkannoth@quicinc.com>
+---
+ net/core/dev.c | 18 ++++++------------
+ 1 file changed, 6 insertions(+), 12 deletions(-)
+
+--- a/net/core/dev.c
++++ b/net/core/dev.c
+@@ -559,7 +559,6 @@ static inline void netdev_set_addr_lockd
+  *
+  *******************************************************************************/
+ 
+-
+ /*
+  *	Add a protocol ID to the list. Now that the input handler is
+  *	smarter we can dispense with all the messy stuff that used to be
+@@ -661,7 +660,6 @@ void dev_remove_pack(struct packet_type
+ }
+ EXPORT_SYMBOL(dev_remove_pack);
+ 
+-
+ /*******************************************************************************
+  *
+  *			    Device Interface Subroutines
+@@ -1639,7 +1637,6 @@ void dev_close(struct net_device *dev)
+ }
+ EXPORT_SYMBOL(dev_close);
+ 
+-
+ /**
+  *	dev_disable_lro - disable Large Receive Offload on a device
+  *	@dev: device
+@@ -3228,7 +3225,6 @@ void dev_kfree_skb_any_reason(struct sk_
+ }
+ EXPORT_SYMBOL(dev_kfree_skb_any_reason);
+ 
+-
+ /**
+  * netif_device_detach - mark device as removed
+  * @dev: network device
+@@ -5606,12 +5602,6 @@ another_round:
+ 		}
+ 	}
+ 
+-	if (eth_type_vlan(skb->protocol)) {
+-		skb = skb_vlan_untag(skb);
+-		if (unlikely(!skb))
+-			goto out;
+-	}
+-
+ 	if (likely(!fast_tc_filter)) {
+ 		fast_recv = rcu_dereference(athrs_fast_nat_recv);
+ 		if (fast_recv) {
+@@ -5622,6 +5612,12 @@ another_round:
+ 		}
+ 	}
+ 
++	if (eth_type_vlan(skb->protocol)) {
++		skb = skb_vlan_untag(skb);
++		if (unlikely(!skb))
++			goto out;
++	}
++
+ 	if (skb_skip_tc_classify(skb))
+ 		goto skip_classify;
+ 
+@@ -8624,7 +8620,6 @@ void *netdev_lower_dev_get_private(struc
+ }
+ EXPORT_SYMBOL(netdev_lower_dev_get_private);
+ 
+-
+ /**
+  * netdev_lower_state_changed - Dispatch event about lower device state change
+  * @lower_dev: device
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960338-net-gre-adding-API-to-check-GRE-net-device.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,41 @@
+From 9d5acd39ef0579f27dcd2ce44316f3a4df973fa1 Mon Sep 17 00:00:00 2001
+From: Nitin Shetty <quic_nitinsj@quicinc.com>
+Date: Wed, 12 Jan 2022 00:06:57 +0530
+Subject: [PATCH 299/500] net: gre: adding API to check GRE net device
+
+adding support to check if the net device
+is GRE.
+
+Change-Id: Ic50f41299b19939fb8313667e4b8c9c571432235
+Signed-off-by: Nitin Shetty <quic_nitinsj@quicinc.com>
+---
+ include/net/gre.h | 12 ++++++++++++
+ 1 file changed, 12 insertions(+)
+
+--- a/include/net/gre.h
++++ b/include/net/gre.h
+@@ -43,12 +43,24 @@ static inline bool netif_is_gretap(const
+ 	       !strcmp(dev->rtnl_link_ops->kind, "gretap");
+ }
+ 
++static inline bool netif_is_gre(const struct net_device *dev)
++{
++	return dev->rtnl_link_ops &&
++	       !strcmp(dev->rtnl_link_ops->kind, "gre");
++}
++
+ static inline bool netif_is_ip6gretap(const struct net_device *dev)
+ {
+ 	return dev->rtnl_link_ops &&
+ 	       !strcmp(dev->rtnl_link_ops->kind, "ip6gretap");
+ }
+ 
++static inline bool netif_is_ip6gre(const struct net_device *dev)
++{
++	return dev->rtnl_link_ops &&
++	       !strcmp(dev->rtnl_link_ops->kind, "ip6gre");
++}
++
+ static inline int gre_calc_hlen(__be16 o_flags)
+ {
+ 	int addend = 4;
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960339-net-gre-Adding-support-to-detect-fb-netdev.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,96 @@
+From 512681ea05f185d80a6511407ccefacda94cfe21 Mon Sep 17 00:00:00 2001
+From: Swati Singh <quic_swasing@quicinc.com>
+Date: Wed, 24 Aug 2022 09:37:33 -0700
+Subject: [PATCH 300/500] net:gre: Adding support to detect fb netdev
+
+adding support to detect whether the
+given netdevice is fallback device
+for gretap and ipv6 tunnel.
+
+Change-Id: Idf275af604ea56061e48f45c89154ef1d20c902a
+Signed-off-by: Swati Singh <quic_swasing@quicinc.com>
+---
+ include/net/gre.h        |  1 +
+ include/net/ip_tunnels.h |  3 +++
+ net/ipv4/ip_gre.c        | 20 ++++++++++++++++++++
+ net/ipv6/ip6_tunnel.c    | 20 ++++++++++++++++++++
+ 4 files changed, 44 insertions(+)
+
+--- a/include/net/gre.h
++++ b/include/net/gre.h
+@@ -31,6 +31,7 @@ struct gre_protocol {
+ 
+ int gre_add_protocol(const struct gre_protocol *proto, u8 version);
+ int gre_del_protocol(const struct gre_protocol *proto, u8 version);
++bool gre_tunnel_is_fallback_dev(struct net_device *dev);
+ 
+ struct net_device *gretap_fb_dev_create(struct net *net, const char *name,
+ 				       u8 name_assign_type);
+--- a/include/net/ip_tunnels.h
++++ b/include/net/ip_tunnels.h
+@@ -592,4 +592,7 @@ static inline void ip_tunnel_info_opts_s
+ 
+ #endif /* CONFIG_INET */
+ 
++void ipip6_update_offload_stats(struct net_device *dev, void *ptr);
++void ip6_update_offload_stats(struct net_device *dev, void *ptr);
++bool ip6_tunnel_is_fallback_dev(struct net_device *dev);
+ #endif /* __NET_IP_TUNNELS_H */
+--- a/net/ipv4/ip_gre.c
++++ b/net/ipv4/ip_gre.c
+@@ -459,6 +459,26 @@ drop:
+ 	return 0;
+ }
+ 
++bool gre_tunnel_is_fallback_dev(struct net_device *dev)
++{
++	struct net *net;
++	struct ip_tunnel_net *itn;
++	struct net_device *fb_tunnel_dev;
++
++	net = dev_net(dev);
++	if (!net)
++		return false;
++
++	itn  = net_generic(net, gre_tap_net_id);
++	if (!itn)
++		return false;
++
++	fb_tunnel_dev = itn->fb_tunnel_dev;
++
++	return (fb_tunnel_dev == dev);
++}
++EXPORT_SYMBOL(gre_tunnel_is_fallback_dev);
++
+ static void __gre_xmit(struct sk_buff *skb, struct net_device *dev,
+ 		       const struct iphdr *tnl_params,
+ 		       __be16 proto)
+--- a/net/ipv6/ip6_tunnel.c
++++ b/net/ipv6/ip6_tunnel.c
+@@ -2424,6 +2424,26 @@ struct net *ip6_tnl_get_link_net(const s
+ }
+ EXPORT_SYMBOL(ip6_tnl_get_link_net);
+ 
++bool ip6_tunnel_is_fallback_dev(struct net_device *dev)
++{
++	struct net *net;
++	struct ip6_tnl_net *ip6n;
++	struct net_device *fb_tnl_dev;
++
++	net = dev_net(dev);
++	if (!net)
++		return false;
++
++	ip6n = net_generic(net, ip6_tnl_net_id);
++	if (!ip6n)
++		return false;
++
++	fb_tnl_dev = ip6n->fb_tnl_dev;
++
++	return (fb_tnl_dev == dev);
++}
++EXPORT_SYMBOL(ip6_tunnel_is_fallback_dev);
++
+ static const struct nla_policy ip6_tnl_policy[IFLA_IPTUN_MAX + 1] = {
+ 	[IFLA_IPTUN_LINK]		= { .type = NLA_U32 },
+ 	[IFLA_IPTUN_LOCAL]		= { .len = sizeof(struct in6_addr) },
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960340-ppp-Add-PPP-channel-specific-methods-for-PPTP-and-L2.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,104 @@
+From 7d3846d95a5b5fa800031411d53078f2d775d2e6 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Fri, 16 Jan 2015 16:54:08 -0800
+Subject: [PATCH 301/500] ppp: Add PPP channel specific methods for PPTP and
+ L2TP types.
+
+These methods are required for handling these types of PPP protocols
+in the acceleration subsystem.
+
+Change-Id: I7967573ee440a96af3f842300e2f021465a0a62c
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ drivers/net/ppp/pptp.c | 27 +++++++++++++++++++++++++++
+ net/l2tp/l2tp_ppp.c    | 30 ++++++++++++++++++++++++++++++
+ 2 files changed, 57 insertions(+)
+
+--- a/drivers/net/ppp/pptp.c
++++ b/drivers/net/ppp/pptp.c
+@@ -603,9 +603,36 @@ static int pptp_ppp_ioctl(struct ppp_cha
+ 	return err;
+ }
+ 
++/* pptp_hold_chan() */
++static void pptp_hold_chan(struct ppp_channel *chan)
++{
++	struct sock *sk = (struct sock *)chan->private;
++
++	sock_hold(sk);
++}
++
++/* pptp_release_chan() */
++static void pptp_release_chan(struct ppp_channel *chan)
++{
++	struct sock *sk = (struct sock *)chan->private;
++
++	sock_put(sk);
++}
++
++/* pptp_get_channel_protocol()
++ *     Return the protocol type of the PPTP over PPP protocol
++ */
++static int pptp_get_channel_protocol(struct ppp_channel *chan)
++{
++	return PX_PROTO_PPTP;
++}
++
+ static const struct ppp_channel_ops pptp_chan_ops = {
+ 	.start_xmit = pptp_xmit,
+ 	.ioctl      = pptp_ppp_ioctl,
++	.get_channel_protocol = pptp_get_channel_protocol,
++	.hold = pptp_hold_chan,
++	.release = pptp_release_chan,
+ };
+ 
+ static struct proto pptp_sk_proto __read_mostly = {
+--- a/net/l2tp/l2tp_ppp.c
++++ b/net/l2tp/l2tp_ppp.c
+@@ -123,9 +123,15 @@ struct pppol2tp_session {
+ };
+ 
+ static int pppol2tp_xmit(struct ppp_channel *chan, struct sk_buff *skb);
++static int pppol2tp_get_channel_protocol(struct ppp_channel *);
++static void pppol2tp_hold_chan(struct ppp_channel *);
++static void pppol2tp_release_chan(struct ppp_channel *);
+ 
+ static const struct ppp_channel_ops pppol2tp_chan_ops = {
+ 	.start_xmit =  pppol2tp_xmit,
++	.get_channel_protocol = pppol2tp_get_channel_protocol,
++	.hold = pppol2tp_hold_chan,
++	.release = pppol2tp_release_chan,
+ };
+ 
+ static const struct proto_ops pppol2tp_ops;
+@@ -328,6 +334,30 @@ error:
+ 	return error;
+ }
+ 
++/* pppol2tp_hold_chan() */
++static void pppol2tp_hold_chan(struct ppp_channel *chan)
++{
++	struct sock *sk = (struct sock *)chan->private;
++
++	sock_hold(sk);
++}
++
++/* pppol2tp_release_chan() */
++static void pppol2tp_release_chan(struct ppp_channel *chan)
++{
++	struct sock *sk = (struct sock *)chan->private;
++
++	sock_put(sk);
++}
++
++/* pppol2tp_get_channel_protocol()
++ * Return the protocol type of the L2TP over PPP protocol
++ */
++static int pppol2tp_get_channel_protocol(struct ppp_channel *chan)
++{
++	return PX_PROTO_OL2TP;
++}
++
+ /* Transmit function called by generic PPP driver.  Sends PPP frame
+  * over PPPoL2TP socket.
+  *
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960341-ppp-PPPoE-acceleration-support.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,608 @@
+From 16de3e75ec92f88a454725c2e33e22b501c1a873 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <quic_msezgin@quicinc.com>
+Date: Wed, 10 May 2023 13:16:09 -0700
+Subject: [PATCH 183/500] ppp: PPPoE acceleration support.
+
+pppoe: Add return value to pppoe addressing get function
+
+If the addressing doesn't have a netdevice, this should be
+handled as a failure, so that the caller considers that
+the get function failed.
+
+Change-Id: Ia9a6b0e0f036a3434519d9f2194763486ca04583
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+
+Added some new APIs to the PPP/PPPoE kernel modules
+for using from the hardware acceleration connection managers.
+
+Change-Id: I2c16c6d6ccba8ffa14aec077c8dad1681535ae0b
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+
+net: ppp: rx/tx error and dropped pkt stats support
+
+ppp_update_stats functions accepts rx/tx errors and dropped
+pkt stats args.
+
+Change-Id: Iba2f6ea2114d8a4678254332fec0ef7bc35bed2c
+Signed-off-by: ratheesh kannoth <rkannoth@codeaurora.org>
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+
+ppp: Update the last_recv and last_xmit times.
+
+These need to be updated for accelerated connections, so that
+on demand mode will recognize the active traffic.
+
+Change-Id: I3c0ee4e8f4c3bc4c7ce221e6109bfd82046d11b4
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+
+ppp: Add channel connect/disconnect notifier.
+
+When a channel is connected or disconnected to a PPP
+unit, a notification will be sent to the kernel subsystems
+which are registered to this notifier. Notifier sends
+the event type (connect or disconnect) along with the
+PPP netdevice pointer.
+
+Change-Id: I0d592084744c86e1c114ac66da68b214ddff5b5a
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+Signed-off-by: Murat Sezgin <quic_msezgin@quicinc.com>
+---
+ drivers/net/ppp/ppp_generic.c | 220 ++++++++++++++++++++++++++++++++++
+ drivers/net/ppp/pppoe.c       |  83 ++++++++++++-
+ include/linux/if_pppox.h      |  16 ++-
+ include/linux/ppp_channel.h   |  52 ++++++++
+ net/l2tp/l2tp_core.c          |  24 ++++
+ net/l2tp/l2tp_core.h          |   2 +
+ 6 files changed, 391 insertions(+), 6 deletions(-)
+
+--- a/drivers/net/ppp/ppp_generic.c
++++ b/drivers/net/ppp/ppp_generic.c
+@@ -255,6 +255,24 @@ struct ppp_net {
+ #define seq_before(a, b)	((s32)((a) - (b)) < 0)
+ #define seq_after(a, b)		((s32)((a) - (b)) > 0)
+ 
++/*
++ * Registration/Unregistration methods
++ * for PPP channel connect and disconnect event notifications.
++ */
++RAW_NOTIFIER_HEAD(ppp_channel_connection_notifier_list);
++
++void ppp_channel_connection_register_notify(struct notifier_block *nb)
++{
++	raw_notifier_chain_register(&ppp_channel_connection_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(ppp_channel_connection_register_notify);
++
++void ppp_channel_connection_unregister_notify(struct notifier_block *nb)
++{
++	raw_notifier_chain_unregister(&ppp_channel_connection_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(ppp_channel_connection_unregister_notify);
++
+ /* Prototypes. */
+ static int ppp_unattached_ioctl(struct net *net, struct ppp_file *pf,
+ 			struct file *file, unsigned int cmd, unsigned long arg);
+@@ -3468,6 +3486,7 @@ ppp_connect_channel(struct channel *pch,
+ 	struct ppp_net *pn;
+ 	int ret = -ENXIO;
+ 	int hdrlen;
++	int notify = 0;
+ 
+ 	pn = ppp_pernet(pch->chan_net);
+ 
+@@ -3500,6 +3519,8 @@ ppp_connect_channel(struct channel *pch,
+ 	++ppp->n_channels;
+ 	pch->ppp = ppp;
+ 	refcount_inc(&ppp->file.refcnt);
++	notify = 1;
++
+ 	ppp_unlock(ppp);
+ 	ret = 0;
+ 
+@@ -3507,6 +3528,14 @@ ppp_connect_channel(struct channel *pch,
+ 	write_unlock_bh(&pch->upl);
+  out:
+ 	mutex_unlock(&pn->all_ppp_mutex);
++
++	if (notify && ppp && ppp->dev) {
++		dev_hold(ppp->dev);
++		raw_notifier_call_chain(&ppp_channel_connection_notifier_list,
++					   PPP_CHANNEL_CONNECT, ppp->dev);
++		dev_put(ppp->dev);
++	}
++
+ 	return ret;
+ }
+ 
+@@ -3524,6 +3553,13 @@ ppp_disconnect_channel(struct channel *p
+ 	pch->ppp = NULL;
+ 	write_unlock_bh(&pch->upl);
+ 	if (ppp) {
++		if (ppp->dev) {
++			dev_hold(ppp->dev);
++			raw_notifier_call_chain(&ppp_channel_connection_notifier_list,
++					   PPP_CHANNEL_DISCONNECT, ppp->dev);
++			dev_put(ppp->dev);
++		}
++
+ 		/* remove it from the ppp unit's list */
+ 		ppp_lock(ppp);
+ 		list_del(&pch->clist);
+@@ -3603,6 +3639,188 @@ static void *unit_find(struct idr *p, in
+ 	return idr_find(p, n);
+ }
+ 
++/* Updates the PPP interface statistics. */
++void ppp_update_stats(struct net_device *dev, unsigned long rx_packets,
++		      unsigned long rx_bytes, unsigned long tx_packets,
++		      unsigned long tx_bytes, unsigned long rx_errors,
++		      unsigned long tx_errors, unsigned long rx_dropped,
++		      unsigned long tx_dropped)
++{
++	struct ppp *ppp;
++
++	if (!dev)
++		return;
++
++	if (dev->type != ARPHRD_PPP)
++		return;
++
++	ppp = netdev_priv(dev);
++
++	ppp_xmit_lock(ppp);
++	ppp->stats64.tx_packets += tx_packets;
++	ppp->stats64.tx_bytes += tx_bytes;
++	ppp->dev->stats.tx_errors += tx_errors;
++	ppp->dev->stats.tx_dropped += tx_dropped;
++	if (tx_packets)
++		ppp->last_xmit = jiffies;
++	ppp_xmit_unlock(ppp);
++
++	ppp_recv_lock(ppp);
++	ppp->stats64.rx_packets += rx_packets;
++	ppp->stats64.rx_bytes += rx_bytes;
++	ppp->dev->stats.rx_errors += rx_errors;
++	ppp->dev->stats.rx_dropped += rx_dropped;
++	if (rx_packets)
++		ppp->last_recv = jiffies;
++	ppp_recv_unlock(ppp);
++}
++
++/* Returns >0 if the device is a multilink PPP netdevice, 0 if not or < 0 if
++ * the device is not PPP.
++ */
++int ppp_is_multilink(struct net_device *dev)
++{
++	struct ppp *ppp;
++	unsigned int flags;
++
++	if (!dev)
++		return -1;
++
++	if (dev->type != ARPHRD_PPP)
++		return -1;
++
++	ppp = netdev_priv(dev);
++	ppp_lock(ppp);
++	flags = ppp->flags;
++	ppp_unlock(ppp);
++
++	if (flags & SC_MULTILINK)
++		return 1;
++
++	return 0;
++}
++EXPORT_SYMBOL(ppp_is_multilink);
++
++/* ppp_channel_get_protocol()
++ *	Call this to obtain the underlying protocol of the PPP channel,
++ *	e.g. PX_PROTO_OE
++ *
++ * NOTE: Some channels do not use PX sockets so the protocol value may be very
++ * different for them.
++ * NOTE: -1 indicates failure.
++ * NOTE: Once you know the channel protocol you may then either cast 'chan' to
++ * its sub-class or use the channel protocol specific API's as provided by that
++ * channel sub type.
++ */
++int ppp_channel_get_protocol(struct ppp_channel *chan)
++{
++	if (!chan->ops->get_channel_protocol)
++		return -1;
++
++	return chan->ops->get_channel_protocol(chan);
++}
++EXPORT_SYMBOL(ppp_channel_get_protocol);
++
++/* ppp_channel_hold()
++ *	Call this to hold a channel.
++ *
++ * Returns true on success or false if the hold could not happen.
++ *
++ * NOTE: chan must be protected against destruction during this call -
++ * either by correct locking etc. or because you already have an implicit
++ * or explicit hold to the channel already and this is an additional hold.
++ */
++bool ppp_channel_hold(struct ppp_channel *chan)
++{
++	if (!chan->ops->hold)
++		return false;
++
++	chan->ops->hold(chan);
++	return true;
++}
++EXPORT_SYMBOL(ppp_channel_hold);
++
++/* ppp_channel_release()
++ *	Call this to release a hold you have upon a channel
++ */
++void ppp_channel_release(struct ppp_channel *chan)
++{
++	chan->ops->release(chan);
++}
++EXPORT_SYMBOL(ppp_channel_release);
++
++/* ppp_hold_channels()
++ *	Returns the PPP channels of the PPP device, storing each one into
++ *	channels[].
++ *
++ * channels[] has chan_sz elements.
++ * This function returns the number of channels stored, up to chan_sz.
++ * It will return < 0 if the device is not PPP.
++ *
++ * You MUST release the channels using ppp_release_channels().
++ */
++int ppp_hold_channels(struct net_device *dev, struct ppp_channel *channels[],
++		      unsigned int chan_sz)
++{
++	struct ppp *ppp;
++	int c;
++	struct channel *pch;
++
++	if (!dev)
++		return -1;
++
++	if (dev->type != ARPHRD_PPP)
++		return -1;
++
++	ppp = netdev_priv(dev);
++
++	c = 0;
++	ppp_lock(ppp);
++	list_for_each_entry(pch, &ppp->channels, clist) {
++		struct ppp_channel *chan;
++
++		if (!pch->chan) {
++			/* Channel is going / gone away */
++			continue;
++		}
++
++		if (c == chan_sz) {
++			/* No space to record channel */
++			ppp_unlock(ppp);
++			return c;
++		}
++
++		/* Hold the channel, if supported */
++		chan = pch->chan;
++		if (!chan->ops->hold)
++			continue;
++
++		chan->ops->hold(chan);
++
++		 /* Record the channel */
++		channels[c++] = chan;
++	}
++	ppp_unlock(ppp);
++	return c;
++}
++EXPORT_SYMBOL(ppp_hold_channels);
++
++/* ppp_release_channels()
++ *	Releases channels
++ */
++void ppp_release_channels(struct ppp_channel *channels[], unsigned int chan_sz)
++{
++	unsigned int c;
++
++	for (c = 0; c < chan_sz; ++c) {
++		struct ppp_channel *chan;
++
++		chan = channels[c];
++		chan->ops->release(chan);
++	}
++}
++EXPORT_SYMBOL(ppp_release_channels);
++
+ /* Module/initialization stuff */
+ 
+ module_init(ppp_init);
+@@ -3619,6 +3837,8 @@ EXPORT_SYMBOL(ppp_input_error);
+ EXPORT_SYMBOL(ppp_output_wakeup);
+ EXPORT_SYMBOL(ppp_register_compressor);
+ EXPORT_SYMBOL(ppp_unregister_compressor);
++EXPORT_SYMBOL(ppp_update_stats);
++
+ MODULE_LICENSE("GPL");
+ MODULE_ALIAS_CHARDEV(PPP_MAJOR, 0);
+ MODULE_ALIAS_RTNL_LINK("ppp");
+--- a/drivers/net/ppp/pppoe.c
++++ b/drivers/net/ppp/pppoe.c
+@@ -62,6 +62,7 @@
+ #include <linux/inetdevice.h>
+ #include <linux/etherdevice.h>
+ #include <linux/skbuff.h>
++#include <linux/if_arp.h>
+ #include <linux/init.h>
+ #include <linux/if_ether.h>
+ #include <linux/if_pppox.h>
+@@ -87,7 +88,7 @@
+ static int __pppoe_xmit(struct sock *sk, struct sk_buff *skb);
+ 
+ static const struct proto_ops pppoe_ops;
+-static const struct ppp_channel_ops pppoe_chan_ops;
++static const struct pppoe_channel_ops pppoe_chan_ops;
+ 
+ /* per-net private data for this module */
+ static unsigned int pppoe_net_id __read_mostly;
+@@ -645,6 +646,7 @@ static int pppoe_connect(struct socket *
+ 	if (stage_session(po->pppoe_pa.sid)) {
+ 		pppox_unbind_sock(sk);
+ 		pn = pppoe_pernet(sock_net(sk));
++
+ 		delete_item(pn, po->pppoe_pa.sid,
+ 			    po->pppoe_pa.remote, po->pppoe_ifindex);
+ 		if (po->pppoe_dev) {
+@@ -692,7 +694,7 @@ static int pppoe_connect(struct socket *
+ 
+ 		po->chan.mtu = dev->mtu - sizeof(struct pppoe_hdr) - 2;
+ 		po->chan.private = sk;
+-		po->chan.ops = &pppoe_chan_ops;
++		po->chan.ops = (struct ppp_channel_ops *)&pppoe_chan_ops;
+ 
+ 		error = ppp_register_net_channel(dev_net(dev), &po->chan);
+ 		if (error) {
+@@ -995,9 +997,80 @@ static int pppoe_fill_forward_path(struc
+ 	return 0;
+ }
+ 
+-static const struct ppp_channel_ops pppoe_chan_ops = {
+-	.start_xmit = pppoe_xmit,
+-	.fill_forward_path = pppoe_fill_forward_path,
++/************************************************************************
++ *
++ * function called by generic PPP driver to hold channel
++ *
++ ***********************************************************************/
++static void pppoe_hold_chan(struct ppp_channel *chan)
++{
++	struct sock *sk = (struct sock *)chan->private;
++
++	sock_hold(sk);
++}
++
++/************************************************************************
++ *
++ * function called by generic PPP driver to release channel
++ *
++ ***********************************************************************/
++static void pppoe_release_chan(struct ppp_channel *chan)
++{
++	struct sock *sk = (struct sock *)chan->private;
++
++	sock_put(sk);
++}
++
++/************************************************************************
++ *
++ * function called to get the channel protocol type
++ *
++ ***********************************************************************/
++static int pppoe_get_channel_protocol(struct ppp_channel *chan)
++{
++	return PX_PROTO_OE;
++}
++
++/************************************************************************
++ *
++ * function called to get the PPPoE channel addressing
++ * NOTE: This function returns a HOLD to the netdevice
++ *
++ ***********************************************************************/
++static int pppoe_get_addressing(struct ppp_channel *chan,
++				 struct pppoe_opt *addressing)
++{
++	struct sock *sk = (struct sock *)chan->private;
++	struct pppox_sock *po = pppox_sk(sk);
++	int err = 0;
++
++	*addressing = po->proto.pppoe;
++	if (!addressing->dev)
++		return -ENODEV;
++
++	dev_hold(addressing->dev);
++	return err;
++}
++
++/* pppoe_channel_addressing_get()
++ *	Return PPPoE channel specific addressing information.
++ */
++int pppoe_channel_addressing_get(struct ppp_channel *chan,
++				  struct pppoe_opt *addressing)
++{
++	return pppoe_get_addressing(chan, addressing);
++}
++EXPORT_SYMBOL(pppoe_channel_addressing_get);
++
++static const struct pppoe_channel_ops pppoe_chan_ops = {
++	/* PPPoE specific channel ops */
++	.get_addressing = pppoe_get_addressing,
++	/* General ppp channel ops */
++	.ops.start_xmit = pppoe_xmit,
++	.ops.fill_forward_path = pppoe_fill_forward_path,
++	.ops.get_channel_protocol = pppoe_get_channel_protocol,
++	.ops.hold = pppoe_hold_chan,
++	.ops.release = pppoe_release_chan,
+ };
+ 
+ static int pppoe_recvmsg(struct socket *sock, struct msghdr *m,
+--- a/include/linux/if_pppox.h
++++ b/include/linux/if_pppox.h
+@@ -1,11 +1,12 @@
+ /* SPDX-License-Identifier: GPL-2.0-or-later */
+ /***************************************************************************
+  * Linux PPP over X - Generic PPP transport layer sockets
+- * Linux PPP over Ethernet (PPPoE) Socket Implementation (RFC 2516) 
++ * Linux PPP over Ethernet (PPPoE) Socket Implementation (RFC 2516)
+  *
+  * This file supplies definitions required by the PPP over Ethernet driver
+  * (pppox.c).  All version information wrt this file is located in pppox.c
+  */
++
+ #ifndef __LINUX_IF_PPPOX_H
+ #define __LINUX_IF_PPPOX_H
+ 
+@@ -91,4 +92,17 @@ enum {
+     PPPOX_DEAD		= 16  /* dead, useless, please clean me up!*/
+ };
+ 
++/*
++ * PPPoE Channel specific operations
++ */
++struct pppoe_channel_ops {
++	/* Must be first - general to all PPP channels */
++	struct ppp_channel_ops ops;
++	int (*get_addressing)(struct ppp_channel *, struct pppoe_opt *);
++};
++
++/* Return PPPoE channel specific addressing information */
++extern int pppoe_channel_addressing_get(struct ppp_channel *chan,
++					 struct pppoe_opt *addressing);
++
+ #endif /* !(__LINUX_IF_PPPOX_H) */
+--- a/include/linux/ppp_channel.h
++++ b/include/linux/ppp_channel.h
+@@ -19,6 +19,11 @@
+ #include <linux/skbuff.h>
+ #include <linux/poll.h>
+ #include <net/net_namespace.h>
++#include <linux/notifier.h>
++
++/* PPP channel connection event types */
++#define PPP_CHANNEL_DISCONNECT	0
++#define PPP_CHANNEL_CONNECT	1
+ 
+ struct net_device_path;
+ struct net_device_path_ctx;
+@@ -33,6 +38,15 @@ struct ppp_channel_ops {
+ 	int	(*fill_forward_path)(struct net_device_path_ctx *,
+ 				     struct net_device_path *,
+ 				     const struct ppp_channel *);
++
++	/* Get channel protocol type, one of PX_PROTO_XYZ or specific to
++	 * the channel subtype
++	 */
++	int (*get_channel_protocol)(struct ppp_channel *);
++	/* Hold the channel from being destroyed */
++	void (*hold)(struct ppp_channel *);
++	/* Release hold on the channel */
++	void (*release)(struct ppp_channel *);
+ };
+ 
+ struct ppp_channel {
+@@ -47,6 +61,38 @@ struct ppp_channel {
+ };
+ 
+ #ifdef __KERNEL__
++/* Call this to obtain the underlying protocol of the PPP channel,
++ * e.g. PX_PROTO_OE
++ */
++extern int ppp_channel_get_protocol(struct ppp_channel *);
++
++/* Call this to hold a channel */
++extern bool ppp_channel_hold(struct ppp_channel *);
++
++/* Call this to release a hold you have upon a channel */
++extern void ppp_channel_release(struct ppp_channel *);
++
++/* Release hold on PPP channels */
++extern void ppp_release_channels(struct ppp_channel *channels[],
++				 unsigned int chan_sz);
++
++/* Hold PPP channels for the PPP device */
++extern int ppp_hold_channels(struct net_device *dev,
++			     struct ppp_channel *channels[],
++			     unsigned int chan_sz);
++
++/* Test if the ppp device is a multi-link ppp device */
++extern int ppp_is_multilink(struct net_device *dev);
++
++/* Update statistics of the PPP net_device by incrementing related
++ * statistics field value with corresponding parameter
++ */
++extern void ppp_update_stats(struct net_device *dev, unsigned long rx_packets,
++			     unsigned long rx_bytes, unsigned long tx_packets,
++			     unsigned long tx_bytes, unsigned long rx_errors,
++			     unsigned long tx_errors, unsigned long rx_dropped,
++			     unsigned long tx_dropped);
++
+ /* Called by the channel when it can send some more data. */
+ extern void ppp_output_wakeup(struct ppp_channel *);
+ 
+@@ -76,6 +122,12 @@ extern int ppp_unit_number(struct ppp_ch
+ /* Get the device name associated with a channel, or NULL if none */
+ extern char *ppp_dev_name(struct ppp_channel *);
+ 
++/* Register the PPP channel connect notifier */
++extern void ppp_channel_connection_register_notify(struct notifier_block *nb);
++
++/* Unregister the PPP channel connect notifier */
++extern void ppp_channel_connection_unregister_notify(struct notifier_block *nb);
++
+ /*
+  * SMP locking notes:
+  * The channel code must ensure that when it calls ppp_unregister_channel,
+--- a/net/l2tp/l2tp_core.c
++++ b/net/l2tp/l2tp_core.c
+@@ -403,6 +403,30 @@ err_tlock:
+ }
+ EXPORT_SYMBOL_GPL(l2tp_session_register);
+ 
++void l2tp_stats_update(struct l2tp_tunnel *tunnel,
++		       struct l2tp_session *session,
++		       struct l2tp_stats *stats)
++{
++	atomic_long_add(atomic_long_read(&stats->rx_packets),
++			&tunnel->stats.rx_packets);
++	atomic_long_add(atomic_long_read(&stats->rx_bytes),
++			&tunnel->stats.rx_bytes);
++	atomic_long_add(atomic_long_read(&stats->tx_packets),
++			&tunnel->stats.tx_packets);
++	atomic_long_add(atomic_long_read(&stats->tx_bytes),
++			&tunnel->stats.tx_bytes);
++
++	atomic_long_add(atomic_long_read(&stats->rx_packets),
++			&session->stats.rx_packets);
++	atomic_long_add(atomic_long_read(&stats->rx_bytes),
++			&session->stats.rx_bytes);
++	atomic_long_add(atomic_long_read(&stats->tx_packets),
++			&session->stats.tx_packets);
++	atomic_long_add(atomic_long_read(&stats->tx_bytes),
++			&session->stats.tx_bytes);
++}
++EXPORT_SYMBOL_GPL(l2tp_stats_update);
++
+ /*****************************************************************************
+  * Receive data handling
+  *****************************************************************************/
+--- a/net/l2tp/l2tp_core.h
++++ b/net/l2tp/l2tp_core.h
+@@ -231,6 +231,8 @@ struct l2tp_session *l2tp_session_get(co
+ struct l2tp_session *l2tp_session_get_nth(struct l2tp_tunnel *tunnel, int nth);
+ struct l2tp_session *l2tp_session_get_by_ifname(const struct net *net,
+ 						const char *ifname);
++void l2tp_stats_update(struct l2tp_tunnel *tunnel, struct l2tp_session *session,
++		       struct l2tp_stats *stats);
+ 
+ /* Tunnel and session lifetime management.
+  * Creation of a new instance is a two-step process: create, then register.
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960342-inet-pptp-Added-API-to-get-PPTP-session-info-for-NSS.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,139 @@
+From bd2254aed96e33fc84c24d54894fe606f474360d Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Fri, 26 Feb 2016 15:26:07 -0800
+Subject: [PATCH 302/500] inet: pptp: Added API to get PPTP session info for
+ NSS acceleration
+
+The API are needed by NSS modules to query PPTP session information
+using the PPTP channel or session ID. The information is needed for
+accelerating PPTP flows by NSS
+
+Change-Id: I27408e9bee58f186a4ab99fa360bbef26b02c81b
+Signed-off-by: Shyam Sunder <ssunde@codeaurora.org>
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ drivers/net/ppp/pptp.c   | 75 ++++++++++++++++++++++++++++++++++++++++
+ include/linux/if_pppox.h |  8 +++++
+ 2 files changed, 83 insertions(+)
+
+--- a/drivers/net/ppp/pptp.c
++++ b/drivers/net/ppp/pptp.c
+@@ -91,6 +91,31 @@ static int lookup_chan_dst(u16 call_id,
+ 	return i < MAX_CALLID;
+ }
+ 
++/* Search a pptp session based on peer call id and peer ip address */
++static int lookup_session_dst(struct pptp_opt *opt, u16 call_id, __be32 d_addr)
++{
++	struct pppox_sock *sock;
++	int i = 1;
++
++	rcu_read_lock();
++	for_each_set_bit_from(i, callid_bitmap, MAX_CALLID) {
++		sock = rcu_dereference(callid_sock[i]);
++		if (!sock)
++			continue;
++
++		if (sock->proto.pptp.dst_addr.call_id == call_id &&
++		    sock->proto.pptp.dst_addr.sin_addr.s_addr == d_addr) {
++			sock_hold(sk_pppox(sock));
++			memcpy(opt, &sock->proto.pptp, sizeof(struct pptp_opt));
++			sock_put(sk_pppox(sock));
++			rcu_read_unlock();
++			return 0;
++		}
++	}
++	rcu_read_unlock();
++	return -EINVAL;
++}
++
+ static int add_chan(struct pppox_sock *sock,
+ 		    struct pptp_addr *sa)
+ {
+@@ -258,7 +283,12 @@ static int pptp_xmit(struct ppp_channel
+ 	ip_select_ident(net, skb, NULL);
+ 	ip_send_check(iph);
+ 
++	/* set incoming interface as the ppp interface */
++	if (skb->skb_iif)
++		skb->skb_iif = ppp_dev_index(chan);
++
+ 	ip_local_out(net, skb->sk, skb);
++
+ 	return 1;
+ 
+ tx_error:
+@@ -371,6 +401,7 @@ static int pptp_rcv(struct sk_buff *skb)
+ 	if (po) {
+ 		skb_dst_drop(skb);
+ 		nf_reset_ct(skb);
++		skb->skb_iif = ppp_dev_index(&po->chan);
+ 		return sk_receive_skb(sk_pppox(po), skb, 0);
+ 	}
+ drop:
+@@ -603,6 +634,50 @@ static int pptp_ppp_ioctl(struct ppp_cha
+ 	return err;
+ }
+ 
++/* pptp_channel_addressing_get()
++ *	Return PPTP channel specific addressing information.
++ */
++void pptp_channel_addressing_get(struct pptp_opt *opt, struct ppp_channel *chan)
++{
++	struct sock *sk;
++	struct pppox_sock *po;
++
++	if (!opt)
++		return;
++
++	sk = (struct sock *)chan->private;
++	if (!sk)
++		return;
++
++	sock_hold(sk);
++
++	/* This is very unlikely, but check the socket is connected state */
++	if (unlikely(sock_flag(sk, SOCK_DEAD) ||
++		     !(sk->sk_state & PPPOX_CONNECTED))) {
++		sock_put(sk);
++		return;
++	}
++
++	po = pppox_sk(sk);
++	memcpy(opt, &po->proto.pptp, sizeof(struct pptp_opt));
++	sock_put(sk);
++}
++EXPORT_SYMBOL(pptp_channel_addressing_get);
++
++/* pptp_session_find()
++ *	Search and return a PPTP session info based on peer callid and IP
++ *	address. The function accepts the parameters in network byte order.
++ */
++int pptp_session_find(struct pptp_opt *opt, __be16 peer_call_id,
++		      __be32 peer_ip_addr)
++{
++	if (!opt)
++		return -EINVAL;
++
++	return lookup_session_dst(opt, ntohs(peer_call_id), peer_ip_addr);
++}
++EXPORT_SYMBOL(pptp_session_find);
++
+ /* pptp_hold_chan() */
+ static void pptp_hold_chan(struct ppp_channel *chan)
+ {
+--- a/include/linux/if_pppox.h
++++ b/include/linux/if_pppox.h
+@@ -105,4 +105,12 @@ struct pppoe_channel_ops {
+ extern int pppoe_channel_addressing_get(struct ppp_channel *chan,
+ 					 struct pppoe_opt *addressing);
+ 
++/* Lookup PPTP session info and return PPTP session */
++extern int pptp_session_find(struct pptp_opt *opt, __be16 peer_call_id,
++			     __be32 peer_ip_addr);
++
++/* Return PPTP session information given the channel */
++extern void pptp_channel_addressing_get(struct pptp_opt *opt,
++					struct ppp_channel *chan);
++
+ #endif /* !(__LINUX_IF_PPPOX_H) */
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960343-net-gre-Set-skb-skb_iif-number.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,36 @@
+From fb2393132ddf7af47b6b5dd67b57048f4b914faa Mon Sep 17 00:00:00 2001
+From: ratheesh kannoth <rkannoth@codeaurora.org>
+Date: Mon, 13 Nov 2017 15:10:10 +0530
+Subject: [PATCH 298/500] net :gre : Set skb->skb_iif number
+
+skb->skb_iif should be set to GRE netdevice to accelerate
+packet
+
+Change-Id: I0af542d2fa64b87c51b9bf3803bb874299299026
+Signed-off-by: ratheesh kannoth <rkannoth@codeaurora.org>
+Signed-off-by: Subhash Kumar Katnpally <skatnapa@codeaurora.org>
+Signed-off-by: Pavithra R <pavir@codeaurora.org>
+---
+ net/ipv4/ip_gre.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+--- a/net/ipv4/ip_gre.c
++++ b/net/ipv4/ip_gre.c
+@@ -687,6 +687,8 @@ static netdev_tx_t ipgre_xmit(struct sk_
+ 	if (gre_handle_offloads(skb, !!(tunnel->parms.o_flags & TUNNEL_CSUM)))
+ 		goto free_skb;
+ 
++	skb->skb_iif = dev->ifindex;
++
+ 	__gre_xmit(skb, dev, tnl_params, skb->protocol);
+ 	return NETDEV_TX_OK;
+ 
+@@ -770,6 +772,8 @@ static netdev_tx_t gre_tap_xmit(struct s
+ 	if (skb_cow_head(skb, dev->needed_headroom))
+ 		goto free_skb;
+ 
++	skb->skb_iif = dev->ifindex;
++
+ 	__gre_xmit(skb, dev, &tunnel->parms.iph, htons(ETH_P_TEB));
+ 	return NETDEV_TX_OK;
+ 
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960344-net-ppp-API-to-check-compression-enabled-on-PPP-devi.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,56 @@
+From cad2cc2ca7c6cb9b4428a0333c46713f82d2424d Mon Sep 17 00:00:00 2001
+From: Ratheesh Kannoth <rkannoth@codeaurora.org>
+Date: Fri, 6 Nov 2020 12:56:12 +0530
+Subject: [PATCH 244/500] net: ppp: API to check compression enabled on PPP
+ device
+
+Change-Id: I574c688a9299531263061534a51cc88fef5e069f
+Signed-off-by: Ratheesh Kannoth <rkannoth@codeaurora.org>
+Signed-off-by: Pavithra R <quic_pavir@quicinc.com>
+---
+ drivers/net/ppp/ppp_generic.c | 22 ++++++++++++++++++++++
+ include/linux/ppp_channel.h   |  2 ++
+ 2 files changed, 24 insertions(+)
+
+--- a/drivers/net/ppp/ppp_generic.c
++++ b/drivers/net/ppp/ppp_generic.c
+@@ -3675,6 +3675,28 @@ void ppp_update_stats(struct net_device
+ 	ppp_recv_unlock(ppp);
+ }
+ 
++/* Returns true if Compression is enabled on PPP device
++ */
++bool ppp_is_cp_enabled(struct net_device *dev)
++{
++	struct ppp *ppp;
++	bool flag = false;
++
++	if (!dev)
++		return false;
++
++	if (dev->type != ARPHRD_PPP)
++		return false;
++
++	ppp = netdev_priv(dev);
++	ppp_lock(ppp);
++	flag = !!ppp->xcomp || !!ppp->rcomp;
++	ppp_unlock(ppp);
++
++	return flag;
++}
++EXPORT_SYMBOL(ppp_is_cp_enabled);
++
+ /* Returns >0 if the device is a multilink PPP netdevice, 0 if not or < 0 if
+  * the device is not PPP.
+  */
+--- a/include/linux/ppp_channel.h
++++ b/include/linux/ppp_channel.h
+@@ -81,6 +81,8 @@ extern int ppp_hold_channels(struct net_
+ 			     struct ppp_channel *channels[],
+ 			     unsigned int chan_sz);
+ 
++bool ppp_is_cp_enabled(struct net_device *dev);
++
+ /* Test if the ppp device is a multi-link ppp device */
+ extern int ppp_is_multilink(struct net_device *dev);
+ 
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960345-net-ppp-Use-flag-to-detect-TX-RX-compression.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,23 @@
+From 74702bfe2627baa572303a4d4281bafa2cfa2464 Mon Sep 17 00:00:00 2001
+From: Ratheesh Kannoth <rkannoth@codeaurora.org>
+Date: Mon, 16 Nov 2020 17:34:25 +0530
+Subject: [PATCH 264/500] net: ppp: Use flag to detect TX/RX compression
+
+Change-Id: I3068377565fe172b2771b7878a6c933322f6c69e
+Signed-off-by: Ratheesh Kannoth <rkannoth@codeaurora.org>
+Signed-off-by: Pavithra R <quic_pavir@quicinc.com>
+---
+ drivers/net/ppp/ppp_generic.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/ppp/ppp_generic.c
++++ b/drivers/net/ppp/ppp_generic.c
+@@ -3690,7 +3690,7 @@ bool ppp_is_cp_enabled(struct net_device
+ 
+ 	ppp = netdev_priv(dev);
+ 	ppp_lock(ppp);
+-	flag = !!ppp->xcomp || !!ppp->rcomp;
++	flag = !!(ppp->xstate & SC_COMP_RUN) || !!(ppp->rstate & SC_DECOMP_RUN);
+ 	ppp_unlock(ppp);
+ 
+ 	return flag;
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960346-net-l2tp-set-skb-iif-for-pkt-thru-l2tp-interface.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,85 @@
+From a7f74f20856f3076d57cb2a986cfbe1d26cead41 Mon Sep 17 00:00:00 2001
+From: ratheesh kannoth <rkannoth@codeaurora.org>
+Date: Wed, 8 Jul 2015 11:13:57 +0530
+Subject: [PATCH 306/500] net: l2tp: set skb->iif for pkt thru l2tp interface
+
+Change-Id: I20eed270083ba9ac167d9672928483396e488133
+Signed-off-by: ratheesh kannoth <rkannoth@codeaurora.org>
+---
+ drivers/net/ppp/ppp_generic.c | 15 +++++++++++++++
+ include/linux/ppp_channel.h   |  4 ++++
+ net/l2tp/l2tp_ppp.c           |  4 ++++
+ 3 files changed, 23 insertions(+)
+
+--- a/drivers/net/ppp/ppp_generic.c
++++ b/drivers/net/ppp/ppp_generic.c
+@@ -2970,6 +2970,21 @@ int ppp_unit_number(struct ppp_channel *
+ 	return unit;
+ }
+ 
++/* Return the PPP net device index */
++int ppp_dev_index(struct ppp_channel *chan)
++{
++	struct channel *pch = chan->ppp;
++	int ifindex = 0;
++
++	if (pch) {
++		read_lock_bh(&pch->upl);
++		if (pch->ppp && pch->ppp->dev)
++			ifindex = pch->ppp->dev->ifindex;
++		read_unlock_bh(&pch->upl);
++	}
++	return ifindex;
++}
++
+ /*
+  * Return the PPP device interface name of a channel.
+  */
+@@ -3854,6 +3868,7 @@ EXPORT_SYMBOL(ppp_unregister_channel);
++EXPORT_SYMBOL(ppp_dev_index);
+ EXPORT_SYMBOL(ppp_channel_index);
+ EXPORT_SYMBOL(ppp_unit_number);
+ EXPORT_SYMBOL(ppp_dev_name);
+ EXPORT_SYMBOL(ppp_input);
+ EXPORT_SYMBOL(ppp_input_error);
+ EXPORT_SYMBOL(ppp_output_wakeup);
+--- a/include/linux/ppp_channel.h
++++ b/include/linux/ppp_channel.h
+@@ -19,6 +19,7 @@
+ #include <linux/skbuff.h>
+ #include <linux/poll.h>
+ #include <net/net_namespace.h>
++#include <linux/ppp_defs.h>
+ #include <linux/notifier.h>
+ 
+ /* PPP channel connection event types */
+@@ -118,6 +119,9 @@ extern void ppp_unregister_channel(struc
+ /* Get the channel number for a channel */
+ extern int ppp_channel_index(struct ppp_channel *);
+ 
++/* Get the device index  associated with a channel, or 0, if none */
++extern int ppp_dev_index(struct ppp_channel *);
++
+ /* Get the unit number associated with a channel, or -1 if none */
+ extern int ppp_unit_number(struct ppp_channel *);
+ 
+--- a/net/l2tp/l2tp_ppp.c
++++ b/net/l2tp/l2tp_ppp.c
+@@ -243,6 +243,7 @@ static void pppol2tp_recv(struct l2tp_se
+ 		struct pppox_sock *po;
+ 
+ 		po = pppox_sk(sk);
++		skb->skb_iif = ppp_dev_index(&po->chan);
+ 		ppp_input(&po->chan, skb);
+ 	} else {
+ 		if (sock_queue_rcv_skb(sk, skb) < 0) {
+@@ -402,6 +403,9 @@ static int pppol2tp_xmit(struct ppp_chan
+ 	__skb_push(skb, 2);
+ 	skb->data[0] = PPP_ALLSTATIONS;
+ 	skb->data[1] = PPP_UI;
++	/* set incoming interface as the ppp interface */
++	if (skb->skb_iif)
++		skb->skb_iif = ppp_dev_index(chan);
+ 
+ 	local_bh_disable();
+ 	l2tp_xmit_skb(session, skb);
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960347-net-l2tp-l2tp-chan-ops-support-get_addressing.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,239 @@
+From 974e8f230c2294f54d5151fe0dbbc68a3aecb347 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Fri, 26 Feb 2016 15:18:08 -0800
+Subject: [PATCH 307/500] net :l2tp: l2tp chan ops support get_addressing
+
+l2tp channel ops support get_addressing() function. This
+function can get l2tp tunnel/session/ip/port info.
+
+Change-Id: Ica87438505c20376478092b95faaa3ecb8251596
+Signed-off-by: ratheesh kannoth <rkannoth@codeaurora.org>
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ drivers/net/ppp/ppp_generic.c | 79 +++++++++++++++++++++++++++++++++++
+ include/linux/if_pppol2tp.h   | 23 ++++++++++
+ include/linux/ppp_channel.h   |  7 ++++
+ net/l2tp/l2tp_ppp.c           | 53 +++++++++++++++++++----
+ 4 files changed, 155 insertions(+), 7 deletions(-)
+
+--- a/drivers/net/ppp/ppp_generic.c
++++ b/drivers/net/ppp/ppp_generic.c
+@@ -3737,6 +3737,32 @@ int ppp_is_multilink(struct net_device *
+ }
+ EXPORT_SYMBOL(ppp_is_multilink);
+ 
++/* __ppp_is_multilink()
++ *	Returns >0 if the device is a multilink PPP netdevice, 0 if not or < 0
++ *	if the device is not PPP. Caller should acquire ppp_lock before calling
++ *	this function
++ */
++int __ppp_is_multilink(struct net_device *dev)
++{
++	struct ppp *ppp;
++	unsigned int flags;
++
++	if (!dev)
++		return -1;
++
++	if (dev->type != ARPHRD_PPP)
++		return -1;
++
++	ppp = netdev_priv(dev);
++	flags = ppp->flags;
++
++	if (flags & SC_MULTILINK)
++		return 1;
++
++	return 0;
++}
++EXPORT_SYMBOL(__ppp_is_multilink);
++
+ /* ppp_channel_get_protocol()
+  *	Call this to obtain the underlying protocol of the PPP channel,
+  *	e.g. PX_PROTO_OE
+@@ -3841,6 +3867,59 @@ int ppp_hold_channels(struct net_device
+ }
+ EXPORT_SYMBOL(ppp_hold_channels);
+ 
++/* __ppp_hold_channels()
++ *	Returns the PPP channels of the PPP device, storing each one
++ *	into channels[].
++ *
++ * channels[] has chan_sz elements.
++ * This function returns the number of channels stored, up to chan_sz.
++ * It will return < 0 if the device is not PPP.
++ *
++ * You MUST acquire ppp_lock and  release the channels using
++ * ppp_release_channels().
++ */
++int __ppp_hold_channels(struct net_device *dev, struct ppp_channel *channels[],
++			unsigned int chan_sz)
++{
++	struct ppp *ppp;
++	int c;
++	struct channel *pch;
++
++	if (!dev)
++		return -1;
++
++	if (dev->type != ARPHRD_PPP)
++		return -1;
++
++	ppp = netdev_priv(dev);
++
++	c = 0;
++	list_for_each_entry(pch, &ppp->channels, clist) {
++		struct ppp_channel *chan;
++
++		if (!pch->chan) {
++			/* Channel is going / gone away*/
++			continue;
++		}
++		if (c == chan_sz) {
++			/* No space to record channel */
++			return c;
++		}
++
++		/* Hold the channel, if supported */
++		chan = pch->chan;
++		if (!chan->ops->hold)
++			continue;
++
++		chan->ops->hold(chan);
++
++		/* Record the channel */
++		channels[c++] = chan;
++	}
++	return c;
++}
++EXPORT_SYMBOL(__ppp_hold_channels);
++
+ /* ppp_release_channels()
+  *	Releases channels
+  */
+--- a/include/linux/if_pppol2tp.h
++++ b/include/linux/if_pppol2tp.h
+@@ -12,4 +12,27 @@
+ #include <linux/in6.h>
+ #include <uapi/linux/if_pppol2tp.h>
+ 
++/*
++ * Holds L2TP channel info
++ */
++struct  pppol2tp_common_addr {
++	int tunnel_version;				/* v2 or v3 */
++	__u32 local_tunnel_id, remote_tunnel_id;	/* tunnel id */
++	__u32 local_session_id, remote_session_id;	/* session id */
++	struct sockaddr_in local_addr, remote_addr; /* ip address and port */
++};
++
++/*
++ * L2TP channel operations
++ */
++struct pppol2tp_channel_ops {
++	struct ppp_channel_ops ops; /* ppp channel ops */
++};
++
++/*
++ * exported function which calls pppol2tp channel's get addressing
++ * function
++ */
++extern int pppol2tp_channel_addressing_get(struct ppp_channel *,
++					   struct pppol2tp_common_addr *);
+ #endif
+--- a/include/linux/ppp_channel.h
++++ b/include/linux/ppp_channel.h
+@@ -83,10 +83,17 @@ extern int ppp_hold_channels(struct net_
+ 			     unsigned int chan_sz);
+ 
+ bool ppp_is_cp_enabled(struct net_device *dev);
++/* Hold PPP channels for the PPP device */
++extern int __ppp_hold_channels(struct net_device *dev,
++			       struct ppp_channel *channels[],
++			       unsigned int chan_sz);
+ 
+ /* Test if the ppp device is a multi-link ppp device */
+ extern int ppp_is_multilink(struct net_device *dev);
+ 
++/* Test if the ppp device is a multi-link ppp device */
++extern int __ppp_is_multilink(struct net_device *dev);
++
+ /* Update statistics of the PPP net_device by incrementing related
+  * statistics field value with corresponding parameter
+  */
+--- a/net/l2tp/l2tp_ppp.c
++++ b/net/l2tp/l2tp_ppp.c
+@@ -126,12 +126,11 @@ static int pppol2tp_xmit(struct ppp_chan
+ static int pppol2tp_get_channel_protocol(struct ppp_channel *);
+ static void pppol2tp_hold_chan(struct ppp_channel *);
+ static void pppol2tp_release_chan(struct ppp_channel *);
+-
+-static const struct ppp_channel_ops pppol2tp_chan_ops = {
+-	.start_xmit =  pppol2tp_xmit,
+-	.get_channel_protocol = pppol2tp_get_channel_protocol,
+-	.hold = pppol2tp_hold_chan,
+-	.release = pppol2tp_release_chan,
++static const struct pppol2tp_channel_ops pppol2tp_chan_ops = {
++	.ops.start_xmit =  pppol2tp_xmit,
++	.ops.get_channel_protocol = pppol2tp_get_channel_protocol,
++	.ops.hold = pppol2tp_hold_chan,
++	.ops.release = pppol2tp_release_chan,
+ };
+ 
+ static const struct proto_ops pppol2tp_ops;
+@@ -359,6 +358,46 @@ static int pppol2tp_get_channel_protocol
+ 	return PX_PROTO_OL2TP;
+ }
+ 
++/* pppol2tp_get_addressing() */
++static int pppol2tp_get_addressing(struct ppp_channel *chan,
++				   struct pppol2tp_common_addr *addr)
++{
++	struct sock *sk = (struct sock *)chan->private;
++	struct l2tp_session *session;
++	struct l2tp_tunnel *tunnel;
++	struct inet_sock *isk = NULL;
++	int err = -ENXIO;
++
++	/* Get session and tunnel contexts from the socket */
++	session = pppol2tp_sock_to_session(sk);
++	if (!session)
++		return err;
++
++	tunnel = session->tunnel;
++	isk = inet_sk(tunnel->sock);
++
++	addr->local_tunnel_id = tunnel->tunnel_id;
++	addr->remote_tunnel_id = tunnel->peer_tunnel_id;
++	addr->local_session_id = session->session_id;
++	addr->remote_session_id = session->peer_session_id;
++
++	addr->local_addr.sin_port = isk->inet_sport;
++	addr->remote_addr.sin_port = isk->inet_dport;
++	addr->local_addr.sin_addr.s_addr = isk->inet_saddr;
++	addr->remote_addr.sin_addr.s_addr = isk->inet_daddr;
++
++	sock_put(sk);
++	return 0;
++}
++
++/* pppol2tp_channel_addressing_get() */
++int pppol2tp_channel_addressing_get(struct ppp_channel *chan,
++				    struct pppol2tp_common_addr *addr)
++{
++	return pppol2tp_get_addressing(chan, addr);
++}
++EXPORT_SYMBOL(pppol2tp_channel_addressing_get);
++
+ /* Transmit function called by generic PPP driver.  Sends PPP frame
+  * over PPPoL2TP socket.
+  *
+@@ -852,7 +891,7 @@ static int pppol2tp_connect(struct socke
+ 	po->chan.hdrlen = PPPOL2TP_L2TP_HDR_SIZE_NOSEQ;
+ 
+ 	po->chan.private = sk;
+-	po->chan.ops	 = &pppol2tp_chan_ops;
++	po->chan.ops	 = &pppol2tp_chan_ops.ops;
+ 	po->chan.mtu	 = pppol2tp_tunnel_mtu(tunnel);
+ 
+ 	error = ppp_register_net_channel(sock_net(sk), &po->chan);
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960348-net-l2tp-ppp_channel_proto_version-API.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,241 @@
+From 98f71e72955490c9a1dcdb0f290e4a874a92ae4e Mon Sep 17 00:00:00 2001
+From: pavir <pavir@codeaurora.org>
+Date: Mon, 26 Dec 2016 14:41:20 +0530
+Subject: [PATCH 308/500] net: l2tp: ppp_channel_proto_version API
+
+New API added to retrieve channel version info
+
+Change-Id: Ia4fd236c7cf6170a5034609e75de8c6e4ef79f7b
+Signed-off-by: Shyam Sunder <ssunde@codeaurora.org>
+Signed-off-by: pavir <pavir@codeaurora.org>
+
+ppp: Fix ppp_connect_channel function's return value
+
+The function should return 0 after all the successful
+checks. The patch fixes failed PPPoE connections.
+
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+Change-Id: I6c4755b0b158ca9bd75403e01cb3c0dda193e9e0
+Signed-off-by: Amruth S <quic_amrus@quicinc.com>
+---
+ drivers/net/ppp/ppp_generic.c | 61 +++++++++++++++++++++++++++++++++++
+ include/linux/netdevice.h     |  1 -
+ include/linux/ppp_channel.h   |  9 ++++++
+ net/l2tp/l2tp_ppp.c           | 40 ++++++++++++++++++++++-
+ 4 files changed, 109 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/ppp/ppp_generic.c
++++ b/drivers/net/ppp/ppp_generic.c
+@@ -48,6 +48,7 @@
+ #include <net/slhc_vj.h>
+ #include <linux/atomic.h>
+ #include <linux/refcount.h>
++#include <linux/if_pppox.h>
+ 
+ #include <linux/nsproxy.h>
+ #include <net/net_namespace.h>
+@@ -3500,6 +3501,8 @@ ppp_connect_channel(struct channel *pch,
+ 	struct ppp_net *pn;
+ 	int ret = -ENXIO;
+ 	int hdrlen;
++	int ppp_proto;
++	int version;
+ 	int notify = 0;
+ 
+ 	pn = ppp_pernet(pch->chan_net);
+@@ -3533,6 +3536,30 @@ ppp_connect_channel(struct channel *pch,
+ 	++ppp->n_channels;
+ 	pch->ppp = ppp;
+ 	refcount_inc(&ppp->file.refcnt);
++
++	ppp_proto = ppp_channel_get_protocol(pch->chan);
++	switch (ppp_proto) {
++	case PX_PROTO_OL2TP:
++		version = ppp_channel_get_proto_version(pch->chan);
++		switch (version) {
++		case 2:
++			ppp->dev->priv_flags_ext |= IFF_EXT_PPP_L2TPV2;
++			break;
++		case 3:
++			ppp->dev->priv_flags_ext |= IFF_EXT_PPP_L2TPV3;
++			break;
++		}
++
++		break;
++
++	case PX_PROTO_PPTP:
++		ppp->dev->priv_flags_ext |= IFF_EXT_PPP_PPTP;
++		break;
++
++	default:
++		break;
++	}
++
+ 	notify = 1;
+ 
+ 	ppp_unlock(ppp);
+@@ -3783,6 +3810,18 @@ int ppp_channel_get_protocol(struct ppp_
+ }
+ EXPORT_SYMBOL(ppp_channel_get_protocol);
+ 
++/* ppp_channel_get_proto_version()
++ *	Call this to get channel protocol version
++ */
++int ppp_channel_get_proto_version(struct ppp_channel *chan)
++{
++	if (!chan->ops->get_channel_protocol_ver)
++		return -1;
++
++	return chan->ops->get_channel_protocol_ver(chan);
++}
++EXPORT_SYMBOL(ppp_channel_get_proto_version);
++
+ /* ppp_channel_hold()
+  *	Call this to hold a channel.
+  *
+@@ -3936,6 +3975,28 @@ void ppp_release_channels(struct ppp_cha
+ }
+ EXPORT_SYMBOL(ppp_release_channels);
+ 
++/* Check if ppp xmit lock is on hold */
++bool ppp_is_xmit_locked(struct net_device *dev)
++{
++	struct ppp *ppp;
++
++	if (!dev)
++		return false;
++
++	if (dev->type != ARPHRD_PPP)
++		return false;
++
++	ppp = netdev_priv(dev);
++	if (!ppp)
++		return false;
++
++	if (spin_is_locked(&(ppp)->wlock))
++		return true;
++
++	return false;
++}
++EXPORT_SYMBOL(ppp_is_xmit_locked);
++
+ /* Module/initialization stuff */
+ 
+ module_init(ppp_init);
+--- a/include/linux/netdevice.h
++++ b/include/linux/netdevice.h
+@@ -2262,7 +2262,6 @@ struct net_device {
+ 	unsigned char		nested_level;
+ #endif
+ 
+-
+ 	/* Protocol-specific pointers */
+ 
+ 	struct in_device __rcu	*ip_ptr;
+--- a/include/linux/ppp_channel.h
++++ b/include/linux/ppp_channel.h
+@@ -44,6 +44,8 @@ struct ppp_channel_ops {
+ 	 * the channel subtype
+ 	 */
+ 	int (*get_channel_protocol)(struct ppp_channel *);
++	/* Get channel protocol version */
++	int (*get_channel_protocol_ver)(struct ppp_channel *);
+ 	/* Hold the channel from being destroyed */
+ 	void (*hold)(struct ppp_channel *);
+ 	/* Release hold on the channel */
+@@ -67,6 +69,9 @@ struct ppp_channel {
+  */
+ extern int ppp_channel_get_protocol(struct ppp_channel *);
+ 
++/* Call this get protocol version */
++extern int ppp_channel_get_proto_version(struct ppp_channel *);
++
+ /* Call this to hold a channel */
+ extern bool ppp_channel_hold(struct ppp_channel *);
+ 
+@@ -83,6 +88,10 @@ extern int ppp_hold_channels(struct net_
+ 			     unsigned int chan_sz);
+ 
+ bool ppp_is_cp_enabled(struct net_device *dev);
++
++/* Test if ppp xmit lock is locked */
++extern bool ppp_is_xmit_locked(struct net_device *dev);
++
+ /* Hold PPP channels for the PPP device */
+ extern int __ppp_hold_channels(struct net_device *dev,
+ 			       struct ppp_channel *channels[],
+--- a/net/l2tp/l2tp_ppp.c
++++ b/net/l2tp/l2tp_ppp.c
+@@ -92,6 +92,7 @@
+ #include <net/ip.h>
+ #include <net/udp.h>
+ #include <net/inet_common.h>
++#include <linux/if_pppox.h>
+ 
+ #include <asm/byteorder.h>
+ #include <linux/atomic.h>
+@@ -124,11 +125,13 @@ struct pppol2tp_session {
+ 
+ static int pppol2tp_xmit(struct ppp_channel *chan, struct sk_buff *skb);
+ static int pppol2tp_get_channel_protocol(struct ppp_channel *);
++static int pppol2tp_get_channel_protocol_ver(struct ppp_channel *);
+ static void pppol2tp_hold_chan(struct ppp_channel *);
+ static void pppol2tp_release_chan(struct ppp_channel *);
+ static const struct pppol2tp_channel_ops pppol2tp_chan_ops = {
+ 	.ops.start_xmit =  pppol2tp_xmit,
+ 	.ops.get_channel_protocol = pppol2tp_get_channel_protocol,
++	.ops.get_channel_protocol_ver = pppol2tp_get_channel_protocol_ver,
+ 	.ops.hold = pppol2tp_hold_chan,
+ 	.ops.release = pppol2tp_release_chan,
+ };
+@@ -358,6 +361,40 @@ static int pppol2tp_get_channel_protocol
+ 	return PX_PROTO_OL2TP;
+ }
+ 
++/* pppol2tp_get_channel_protocol_ver()
++ * Return the protocol version of the L2TP over PPP protocol
++ */
++static int pppol2tp_get_channel_protocol_ver(struct ppp_channel *chan)
++{
++	struct sock *sk;
++	struct l2tp_session *session;
++	struct l2tp_tunnel *tunnel;
++	int version = 0;
++
++	if (!(chan && chan->private)) {
++		return -1;
++	}
++
++	sk = (struct sock *)chan->private;
++
++	/* Get session and tunnel contexts from the socket */
++	session = pppol2tp_sock_to_session(sk);
++	if (!session) {
++		return -1;
++	}
++
++	tunnel = session->tunnel;
++	if (!tunnel) {
++		sock_put(sk);
++		return -1;
++	}
++
++	version = tunnel->version;
++
++	sock_put(sk);
++	return version;
++}
++
+ /* pppol2tp_get_addressing() */
+ static int pppol2tp_get_addressing(struct ppp_channel *chan,
+ 				   struct pppol2tp_common_addr *addr)
+@@ -443,7 +480,8 @@ static int pppol2tp_xmit(struct ppp_chan
+ 	skb->data[0] = PPP_ALLSTATIONS;
+ 	skb->data[1] = PPP_UI;
+ 	/* set incoming interface as the ppp interface */
+-	if (skb->skb_iif)
++	if ((skb->protocol == htons(ETH_P_IP)) ||
++	    (skb->protocol == htons(ETH_P_IPV6)))
+ 		skb->skb_iif = ppp_dev_index(chan);
+ 
+ 	local_bh_disable();
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960349-inet-pptp-Enable-offload-mode-for-PPTP-GRE-sequence-.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,254 @@
+From 8b2fc28f1a1280663d30466c788ae80774fa1f29 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Fri, 24 Apr 2020 11:00:19 -0700
+Subject: [PATCH 303/500] inet: pptp: Enable offload mode for PPTP GRE sequence
+ number handling
+
+Changes in this patch will allow all PPTP Data and LCP packets
+to go via packet acceleration hardware. The hardware will take
+care of Seq/Ack numbers update.
+
+Change-Id: Ia5cd7893d9fda180174f78c3468279678422794d
+Signed-off-by: Shyam Sunder <ssunde@codeaurora.org>
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ drivers/net/ppp/pptp.c   | 136 +++++++++++++++++++++++++++++++++++++--
+ include/linux/if_pppox.h |  21 ++++++
+ 2 files changed, 153 insertions(+), 4 deletions(-)
+
+--- a/drivers/net/ppp/pptp.c
++++ b/drivers/net/ppp/pptp.c
+@@ -50,6 +50,8 @@ static struct proto pptp_sk_proto __read
+ static const struct ppp_channel_ops pptp_chan_ops;
+ static const struct proto_ops pptp_ops;
+ 
++static pptp_gre_seq_offload_callback_t __rcu pptp_gre_offload_xmit_cb;
++
+ static struct pppox_sock *lookup_chan(u16 call_id, __be32 s_addr)
+ {
+ 	struct pppox_sock *sock;
+@@ -116,6 +118,28 @@ static int lookup_session_dst(struct ppt
+ 	return -EINVAL;
+ }
+ 
++/* If offload mode set then this function sends all packets to
++ * offload module instead of network stack
++ */
++static int pptp_client_skb_xmit(struct sk_buff *skb,
++				struct net_device *pptp_dev)
++{
++	pptp_gre_seq_offload_callback_t pptp_gre_offload_cb_f;
++	int ret;
++
++	rcu_read_lock();
++	pptp_gre_offload_cb_f = rcu_dereference(pptp_gre_offload_xmit_cb);
++
++	if (!pptp_gre_offload_cb_f) {
++		rcu_read_unlock();
++		return -1;
++	}
++
++	ret = pptp_gre_offload_cb_f(skb, pptp_dev);
++	rcu_read_unlock();
++	return ret;
++}
++
+ static int add_chan(struct pppox_sock *sock,
+ 		    struct pptp_addr *sa)
+ {
+@@ -188,8 +212,11 @@ static int pptp_xmit(struct ppp_channel
+ 
+ 	struct rtable *rt;
+ 	struct net_device *tdev;
++	struct net_device *pptp_dev;
+ 	struct iphdr  *iph;
+ 	int    max_headroom;
++	int    pptp_ifindex;
++	int ret;
+ 
+ 	if (sk_pppox(po)->sk_state & PPPOX_DEAD)
+ 		goto tx_error;
+@@ -283,14 +310,33 @@ static int pptp_xmit(struct ppp_channel
+ 	ip_select_ident(net, skb, NULL);
+ 	ip_send_check(iph);
+ 
++	pptp_ifindex = ppp_dev_index(chan);
++
+ 	/* set incoming interface as the ppp interface */
+ 	if (skb->skb_iif)
+-		skb->skb_iif = ppp_dev_index(chan);
++		skb->skb_iif = pptp_ifindex;
+ 
+-	ip_local_out(net, skb->sk, skb);
++	/* If the PPTP GRE seq number offload module is not enabled yet
++	 * then sends all PPTP GRE packets through linux network stack
++	 */
++	if (!opt->pptp_offload_mode) {
++		ip_local_out(net, skb->sk, skb);
++		return 1;
++	}
+ 
+-	return 1;
++	pptp_dev = dev_get_by_index(&init_net, pptp_ifindex);
++	if (!pptp_dev)
++		goto tx_error;
+ 
++	 /* If PPTP offload module is enabled then forward all PPTP GRE
++	  * packets to PPTP GRE offload module
++	  */
++	ret = pptp_client_skb_xmit(skb, pptp_dev);
++	dev_put(pptp_dev);
++	if (ret < 0)
++		goto tx_error;
++
++	return 1;
+ tx_error:
+ 	kfree_skb(skb);
+ 	return 1;
+@@ -344,6 +390,13 @@ static int pptp_rcv_core(struct sock *sk
+ 		goto drop;
+ 
+ 	payload = skb->data + headersize;
++
++	 /* If offload is enabled, we expect the offload module
++	  * to handle PPTP GRE sequence number checks
++	  */
++	if (opt->pptp_offload_mode)
++		goto allow_packet;
++
+ 	/* check for expected sequence number */
+ 	if (seq < opt->seq_recv + 1 || WRAPPED(opt->seq_recv, seq)) {
+ 		if ((payload[0] == PPP_ALLSTATIONS) && (payload[1] == PPP_UI) &&
+@@ -504,7 +557,7 @@ static int pptp_connect(struct socket *s
+ 
+ 	opt->dst_addr = sp->sa_addr.pptp;
+ 	sk->sk_state |= PPPOX_CONNECTED;
+-
++	opt->pptp_offload_mode = false;
+  end:
+ 	release_sock(sk);
+ 	return error;
+@@ -678,6 +731,81 @@ int pptp_session_find(struct pptp_opt *o
+ }
+ EXPORT_SYMBOL(pptp_session_find);
+ 
++ /* Function to change the offload mode true/false for a PPTP session */
++static int pptp_set_offload_mode(bool accel_mode,
++				 __be16 peer_call_id, __be32 peer_ip_addr)
++{
++	struct pppox_sock *sock;
++	int i = 1;
++
++	rcu_read_lock();
++	for_each_set_bit_from(i, callid_bitmap, MAX_CALLID) {
++		sock = rcu_dereference(callid_sock[i]);
++		if (!sock)
++			continue;
++
++		if (sock->proto.pptp.dst_addr.call_id == peer_call_id &&
++		    sock->proto.pptp.dst_addr.sin_addr.s_addr == peer_ip_addr) {
++			sock_hold(sk_pppox(sock));
++			sock->proto.pptp.pptp_offload_mode = accel_mode;
++			sock_put(sk_pppox(sock));
++			rcu_read_unlock();
++			return 0;
++		}
++	}
++	rcu_read_unlock();
++	return -EINVAL;
++}
++
++/* Enable the PPTP session offload flag */
++int pptp_session_enable_offload_mode(__be16 peer_call_id, __be32 peer_ip_addr)
++{
++	return pptp_set_offload_mode(true, peer_call_id, peer_ip_addr);
++}
++EXPORT_SYMBOL(pptp_session_enable_offload_mode);
++
++/* Disable the PPTP session offload flag */
++int pptp_session_disable_offload_mode(__be16 peer_call_id, __be32 peer_ip_addr)
++{
++	return pptp_set_offload_mode(false, peer_call_id, peer_ip_addr);
++}
++EXPORT_SYMBOL(pptp_session_disable_offload_mode);
++
++/* Register the offload callback function on behalf of the module which
++ * will own the sequence and acknowledgment number updates for all
++ * PPTP GRE packets. All PPTP GRE packets are then transmitted to this
++ * module after encapsulation in order to ensure the correct seq/ack
++ * fields are set in the packets before transmission. This is required
++ * when PPTP flows are offloaded to acceleration engines, in-order to
++ * ensure consistency in sequence and ack numbers between PPTP control
++ * (PPP LCP) and data packets
++ */
++int pptp_register_gre_seq_offload_callback(pptp_gre_seq_offload_callback_t
++					   pptp_gre_offload_cb)
++{
++	pptp_gre_seq_offload_callback_t pptp_gre_offload_cb_f;
++
++	rcu_read_lock();
++	pptp_gre_offload_cb_f = rcu_dereference(pptp_gre_offload_xmit_cb);
++
++	if (pptp_gre_offload_cb_f) {
++		rcu_read_unlock();
++		return -1;
++	}
++
++	rcu_assign_pointer(pptp_gre_offload_xmit_cb, pptp_gre_offload_cb);
++	rcu_read_unlock();
++	return 0;
++}
++EXPORT_SYMBOL(pptp_register_gre_seq_offload_callback);
++
++/* Unregister the PPTP GRE packets sequence number offload callback */
++void pptp_unregister_gre_seq_offload_callback(void)
++{
++	rcu_assign_pointer(pptp_gre_offload_xmit_cb, NULL);
++}
++EXPORT_SYMBOL(pptp_unregister_gre_seq_offload_callback);
++
+ /* pptp_hold_chan() */
+ static void pptp_hold_chan(struct ppp_channel *chan)
+ {
+--- a/include/linux/if_pppox.h
++++ b/include/linux/if_pppox.h
+@@ -37,6 +37,7 @@ struct pptp_opt {
+ 	u32 ack_sent, ack_recv;
+ 	u32 seq_sent, seq_recv;
+ 	int ppp_flags;
++	bool pptp_offload_mode;
+ };
+ #include <net/sock.h>
+ 
+@@ -101,6 +102,10 @@ struct pppoe_channel_ops {
+ 	int (*get_addressing)(struct ppp_channel *, struct pppoe_opt *);
+ };
+ 
++/* PPTP client callback */
++typedef int (*pptp_gre_seq_offload_callback_t)(struct sk_buff *skb,
++					       struct net_device *pptp_dev);
++
+ /* Return PPPoE channel specific addressing information */
+ extern int pppoe_channel_addressing_get(struct ppp_channel *chan,
+ 					 struct pppoe_opt *addressing);
+@@ -113,4 +118,20 @@ extern int pptp_session_find(struct pptp
+ extern void pptp_channel_addressing_get(struct pptp_opt *opt,
+ 					struct ppp_channel *chan);
+ 
++/* Enable the PPTP session offload flag */
++extern int pptp_session_enable_offload_mode(__be16 peer_call_id,
++					    __be32 peer_ip_addr);
++
++/* Disable the PPTP session offload flag */
++extern int pptp_session_disable_offload_mode(__be16 peer_call_id,
++					     __be32 peer_ip_addr);
++
++/* Register the PPTP GRE packets sequence number offload callback */
++extern int
++pptp_register_gre_seq_offload_callback(pptp_gre_seq_offload_callback_t
++				       pptp_client_cb);
++
++/* Unregister the PPTP GRE packets sequence number offload callback */
++extern void pptp_unregister_gre_seq_offload_callback(void);
++
+ #endif /* !(__LINUX_IF_PPPOX_H) */
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960350-anet-pptp-Fill-in-src-key-for-tuple.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,198 @@
+From 8d18026875074002312875cb570065e411688029 Mon Sep 17 00:00:00 2001
+From: Ratheesh Kannoth <rkannoth@codeaurora.org>
+Date: Wed, 16 Dec 2020 15:24:02 +0530
+Subject: [PATCH 305/500] net: pptp: Fill in src key for tuple.
+
+ PPTP gre conntrack is installed during OUT_CALL_REPLY or
+ IN_CALL_CONNECT. if conntrack is destroyed, gre conntrack
+ installs a conntrack in each direction (two conntrack in total)
+ with src call id as 0. This prevents updates of packet stats
+ from AE engine and result in timing out conntrack and leads to
+ flushing of AE flow. This change populates correct src call id.
+
+Signed-off-by: Ratheesh Kannoth <rkannoth@codeaurora.org>
+Change-Id: Ic7861d1e8dc61969194d17793a9d1d546029d29c
+---
+ drivers/net/ppp/pptp.c                 | 41 +++++++++++++++++-
+ include/linux/if_pppox.h               |  6 ++-
+ net/netfilter/nf_conntrack_proto_gre.c | 58 +++++++++++++++++++++++++-
+ 3 files changed, 101 insertions(+), 4 deletions(-)
+
+--- a/drivers/net/ppp/pptp.c
++++ b/drivers/net/ppp/pptp.c
+@@ -93,6 +93,32 @@ static int lookup_chan_dst(u16 call_id,
+ 	return i < MAX_CALLID;
+ }
+ 
++/* Search a pptp session based on local call id, local and remote ip address */
++static int lookup_session_src(struct pptp_opt *opt, u16 call_id, __be32 daddr, __be32 saddr)
++{
++	struct pppox_sock *sock;
++	int i = 1;
++
++	rcu_read_lock();
++	for_each_set_bit_from(i, callid_bitmap, MAX_CALLID) {
++		sock = rcu_dereference(callid_sock[i]);
++		if (!sock)
++			continue;
++
++		if (sock->proto.pptp.src_addr.call_id == call_id &&
++		    sock->proto.pptp.dst_addr.sin_addr.s_addr == daddr &&
++		    sock->proto.pptp.src_addr.sin_addr.s_addr == saddr) {
++			sock_hold(sk_pppox(sock));
++			memcpy(opt, &sock->proto.pptp, sizeof(struct pptp_opt));
++			sock_put(sk_pppox(sock));
++			rcu_read_unlock();
++			return 0;
++		}
++	}
++	rcu_read_unlock();
++	return -EINVAL;
++}
++
+ /* Search a pptp session based on peer call id and peer ip address */
+ static int lookup_session_dst(struct pptp_opt *opt, u16 call_id, __be32 d_addr)
+ {
+@@ -209,7 +235,6 @@ static int pptp_xmit(struct ppp_channel
+ 	unsigned char *data;
+ 	__u32 seq_recv;
+ 
+-
+ 	struct rtable *rt;
+ 	struct net_device *tdev;
+ 	struct net_device *pptp_dev;
+@@ -731,6 +756,20 @@ int pptp_session_find(struct pptp_opt *o
+ }
+ EXPORT_SYMBOL(pptp_session_find);
+ 
++/* pptp_session_find_by_src_callid()
++ *	Search and return a PPTP session info based on src callid and IP
++ *	address. The function accepts the parameters in network byte order.
++ */
++int pptp_session_find_by_src_callid(struct pptp_opt *opt, __be16 src_call_id,
++		      __be32 daddr, __be32 saddr)
++{
++	if (!opt)
++		return -EINVAL;
++
++	return lookup_session_src(opt, ntohs(src_call_id), daddr, saddr);
++}
++EXPORT_SYMBOL(pptp_session_find_by_src_callid);
++
+  /* Function to change the offload mode true/false for a PPTP session */
+ static int pptp_set_offload_mode(bool accel_mode,
+ 				 __be16 peer_call_id, __be32 peer_ip_addr)
+--- a/include/linux/if_pppox.h
++++ b/include/linux/if_pppox.h
+@@ -110,7 +110,11 @@ typedef int (*pptp_gre_seq_offload_callb
+ extern int pppoe_channel_addressing_get(struct ppp_channel *chan,
+ 					 struct pppoe_opt *addressing);
+ 
+-/* Lookup PPTP session info and return PPTP session */
++/* Lookup PPTP session info and return PPTP session using sip, dip and local call id */
++extern int pptp_session_find_by_src_callid(struct pptp_opt *opt, __be16 src_call_id,
++			 __be32 daddr, __be32 saddr);
++
++/* Lookup PPTP session info and return PPTP session using dip and peer call id */
+ extern int pptp_session_find(struct pptp_opt *opt, __be16 peer_call_id,
+ 			     __be32 peer_ip_addr);
+ 
+--- a/net/netfilter/nf_conntrack_proto_gre.c
++++ b/net/netfilter/nf_conntrack_proto_gre.c
+@@ -41,6 +41,8 @@
+ #include <net/netfilter/nf_conntrack_timeout.h>
+ #include <linux/netfilter/nf_conntrack_proto_gre.h>
+ #include <linux/netfilter/nf_conntrack_pptp.h>
++#include <linux/ip.h>
++#include <linux/if_pppox.h>
+ 
+ static const unsigned int gre_timeouts[GRE_CT_MAX] = {
+ 	[GRE_CT_UNREPLIED]	= 30*HZ,
+@@ -66,15 +68,17 @@ static inline int gre_key_cmpfn(const st
+ }
+ 
+ /* look up the source key for a given tuple */
+-static __be16 gre_keymap_lookup(struct net *net, struct nf_conntrack_tuple *t)
++static __be16 gre_keymap_lookup(struct net *net, struct nf_conntrack_tuple *t, bool *found)
+ {
+ 	struct nf_gre_net *net_gre = gre_pernet(net);
+ 	struct nf_ct_gre_keymap *km;
+ 	__be16 key = 0;
++	*found = false;
+ 
+ 	list_for_each_entry_rcu(km, &net_gre->keymap_list, list) {
+ 		if (gre_key_cmpfn(km, t)) {
+ 			key = km->tuple.src.u.gre.key;
++			*found = true;
+ 			break;
+ 		}
+ 	}
+@@ -156,6 +160,12 @@ bool gre_pkt_to_tuple(const struct sk_bu
+ 	__be16 srckey;
+ 	const struct gre_base_hdr *grehdr;
+ 	struct gre_base_hdr _grehdr;
++#if IS_ENABLED(CONFIG_PPTP)
++	struct pptp_opt opt;
++	struct iphdr *v4_hdr;
++	int ret;
++#endif
++	bool found;
+ 
+ 	/* first only delinearize old RFC1701 GRE header */
+ 	grehdr = skb_header_pointer(skb, dataoff, sizeof(_grehdr), &_grehdr);
+@@ -177,10 +187,54 @@ bool gre_pkt_to_tuple(const struct sk_bu
+ 	}
+ 
+ 	tuple->dst.u.gre.key = pgrehdr->call_id;
+-	srckey = gre_keymap_lookup(net, tuple);
++	srckey = gre_keymap_lookup(net, tuple, &found);
+ 	tuple->src.u.gre.key = srckey;
+ 
++#if !IS_ENABLED(CONFIG_PPTP)
+ 	return true;
++#else
++
++	/* Return if src key is found */
++	if (found) {
++		pr_debug("key map entry found (srckey=0x%x dstkey=0x%x)\n", ntohs(srckey),
++			 ntohs(tuple->dst.u.gre.key));
++		return true;
++	}
++
++	/* Key map was not found. Return for IPv6 packet */
++	v4_hdr = ip_hdr(skb);
++	if (v4_hdr->version != IPVERSION) {
++		pr_debug("PPTP IP version is %d\n", v4_hdr->version);
++		return true;
++	}
++
++	/* Lookup the call-id based on dest callID. This is needed for packet originated from the system */
++	ret = pptp_session_find(&opt, pgrehdr->call_id, v4_hdr->daddr);
++	if (!ret) {
++		tuple->src.u.gre.key = htons(opt.src_addr.call_id);
++		pr_debug("PPTP session found by dest callid sip=0x%x srckey=0x%x dip=0x%x destkey=0x%x\n",
++			 ntohl(opt.src_addr.sin_addr.s_addr), opt.src_addr.call_id,
++			 ntohl(opt.dst_addr.sin_addr.s_addr), opt.dst_addr.call_id);
++		return true;
++	}
++
++	/* Lookup the call-id based on source callID. This is needed for packets received */
++	ret =  pptp_session_find_by_src_callid(&opt, pgrehdr->call_id, v4_hdr->saddr, v4_hdr->daddr);
++	if (!ret) {
++		tuple->src.u.gre.key = htons(opt.dst_addr.call_id);
++		pr_debug("PPTP session found by src callid sip=0x%x srckey=0x%x dip=0x%x destkey=0x%x\n",
++				ntohl(opt.dst_addr.sin_addr.s_addr), opt.dst_addr.call_id,
++				ntohl(opt.src_addr.sin_addr.s_addr), opt.src_addr.call_id);
++		return true;
++	}
++
++	/* Do not create conntrack entry */
++	pr_debug("Could not find PPTP session (sip=0x%x srckey=0x%x dip=0x%x dstkey=0x%x)\n",
++				ntohl(v4_hdr->saddr), ntohs(srckey),
++				ntohl(v4_hdr->daddr), ntohs(tuple->dst.u.gre.key));
++	return false;
++#endif
++
+ }
+ 
+ #ifdef CONFIG_NF_CONNTRACK_PROCFS
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960351-net-pptp-set-pptp-interface-in-SKB.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,39 @@
+From 099629a70efcda3df03acddb45f7bc6bf83f2804 Mon Sep 17 00:00:00 2001
+From: Nitin Shetty <quic_nitinsj@quicinc.com>
+Date: Mon, 29 Nov 2021 16:25:37 +0530
+Subject: [PATCH 304/500] net: pptp: set pptp interface in SKB
+
+during pptp encap set incoming interface as pptp
+in SKB.
+
+Change-Id: Ia8a90285070f13f8a7cd94c6781905eea783d0cf
+Signed-off-by: Nitin Shetty <quic_nitinsj@quicinc.com>
+---
+ drivers/net/ppp/pptp.c | 12 ++++++++----
+ 1 file changed, 8 insertions(+), 4 deletions(-)
+
+--- a/drivers/net/ppp/pptp.c
++++ b/drivers/net/ppp/pptp.c
+@@ -337,14 +337,18 @@ static int pptp_xmit(struct ppp_channel
+ 
+ 	pptp_ifindex = ppp_dev_index(chan);
+ 
+-	/* set incoming interface as the ppp interface */
+-	if (skb->skb_iif)
+-		skb->skb_iif = pptp_ifindex;
+-
+ 	/* If the PPTP GRE seq number offload module is not enabled yet
+ 	 * then sends all PPTP GRE packets through linux network stack
+ 	 */
+ 	if (!opt->pptp_offload_mode) {
++		/* set incoming interface as the ppp interface */
++		pptp_dev = dev_get_by_index(&init_net, pptp_ifindex);
++		if (pptp_dev) {
++			skb->dev = pptp_dev;
++			skb->skb_iif = pptp_ifindex;
++			dev_put(pptp_dev);
++		}
++
+ 		ip_local_out(net, skb->sk, skb);
+ 		return 1;
+ 	}
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960353-net-Enable-fast-path-support-for-6RD-DS-Lite.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,125 @@
+From 365bac798ea16e3eb34d8c164b94bc3a4c1fcc51 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <quic_msezgin@quicinc.com>
+Date: Tue, 20 Jun 2023 13:19:29 -0700
+Subject: [PATCH 274/500] net: Enable fast path support for 6RD, DS-Lite
+
+1). Added stats update function
+2). Added changes to set the skb->skb_iif to tunnel dev
+
+Change-Id: I7f43746436b4f6483952997fdf91180096d3ed62
+Signed-off-by: Shyam Sunder <ssunde@codeaurora.org>
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+Signed-off-by: John Sanli <quic_jsanli@quicinc.com>
+Signed-off-by: Pavithra R <quic_pavir@quicinc.com>
+---
+ net/ipv4/ip_tunnel_core.c |  2 +-
+ net/ipv6/ip6_tunnel.c     | 24 +++++++++++++++++++++++-
+ net/ipv6/sit.c            | 18 ++++++++++++++++++
+ 3 files changed, 42 insertions(+), 2 deletions(-)
+
+--- a/net/ipv4/ip_tunnel_core.c
++++ b/net/ipv4/ip_tunnel_core.c
+@@ -61,7 +61,7 @@ void iptunnel_xmit(struct sock *sk, stru
+ 	int skb_iif;
+ 
+ 	/* Save input interface index */
+-        skb_iif = skb->skb_iif;
++	skb_iif = skb->skb_iif;
+ 
+ 	skb_scrub_packet(skb, xnet);
+ 
+--- a/net/ipv6/ip6_tunnel.c
++++ b/net/ipv6/ip6_tunnel.c
+@@ -100,6 +100,23 @@ static inline int ip6_tnl_mpls_supported
+ #define for_each_ip6_tunnel_rcu(start) \
+ 	for (t = rcu_dereference(start); t; t = rcu_dereference(t->next))
+ 
++/*
++ * Update offload stats
++ */
++void ip6_update_offload_stats(struct net_device *dev, void *ptr)
++{
++	struct pcpu_sw_netstats *tstats = per_cpu_ptr(dev->tstats, 0);
++	const struct pcpu_sw_netstats *offload_stats =
++					(struct pcpu_sw_netstats *)ptr;
++
++	u64_stats_update_begin(&tstats->syncp);
++	u64_stats_add(&tstats->tx_packets, u64_stats_read(&offload_stats->tx_packets));
++	u64_stats_add(&tstats->tx_bytes, u64_stats_read(&offload_stats->tx_bytes));
++	u64_stats_add(&tstats->rx_packets, u64_stats_read(&offload_stats->rx_packets));
++	u64_stats_add(&tstats->rx_bytes, u64_stats_read(&offload_stats->rx_bytes));
++	u64_stats_update_end(&tstats->syncp);
++}
++
+ /**
+  * ip6_tnl_lookup - fetch tunnel matching the end-point addresses
+  *   @net: network namespace
+@@ -1024,6 +1041,9 @@ static int __ip6_tnl_rcv(struct ip6_tnl
+ 	if (tun_dst)
+ 		skb_dst_set(skb, (struct dst_entry *)tun_dst);
+ 
++	/* Reset the skb_iif to Tunnels interface index */
++	skb->skb_iif = tunnel->dev->ifindex;
++
+ 	gro_cells_receive(&tunnel->gro_cells, skb);
+ 	return 0;
+ 
+@@ -1105,7 +1125,6 @@ static int ipxip6_rcv(struct sk_buff *sk
+ 	rcu_read_unlock();
+ 
+ 	return ret;
+-
+ drop:
+ 	rcu_read_unlock();
+ 	kfree_skb(skb);
+@@ -1424,6 +1443,9 @@ route_lookup:
+ 	ipv6h->nexthdr = proto;
+ 	ipv6h->saddr = fl6->saddr;
+ 	ipv6h->daddr = fl6->daddr;
++
++	/* Reset the skb_iif to Tunnels interface index */
++	skb->skb_iif = dev->ifindex;
+ 	ip6tunnel_xmit(NULL, skb, dev);
+ 	return 0;
+ tx_err_link_failure:
+--- a/net/ipv6/sit.c
++++ b/net/ipv6/sit.c
+@@ -90,6 +90,20 @@ static inline struct sit_net *dev_to_sit
+ 	return net_generic(t->net, sit_net_id);
+ }
+ 
++void ipip6_update_offload_stats(struct net_device *dev, void *ptr)
++{
++	struct pcpu_sw_netstats *tstats = per_cpu_ptr(dev->tstats, 0);
++	const struct pcpu_sw_netstats *offload_stats =
++					(struct pcpu_sw_netstats *)ptr;
++
++	u64_stats_update_begin(&tstats->syncp);
++	u64_stats_add(&tstats->tx_packets, u64_stats_read(&offload_stats->tx_packets));
++	u64_stats_add(&tstats->tx_bytes, u64_stats_read(&offload_stats->tx_bytes));
++	u64_stats_add(&tstats->rx_packets, u64_stats_read(&offload_stats->rx_packets));
++	u64_stats_add(&tstats->rx_bytes, u64_stats_read(&offload_stats->rx_bytes));
++	u64_stats_update_end(&tstats->syncp);
++}
++
+ /*
+  * Must be invoked with rcu_read_lock
+  */
+@@ -722,6 +736,8 @@ static int ipip6_rcv(struct sk_buff *skb
+ 
+ 		dev_sw_netstats_rx_add(tunnel->dev, skb->len);
+ 
++		/* Reset the skb_iif to Tunnels interface index */
++		skb->skb_iif = tunnel->dev->ifindex;
+ 		netif_rx(skb);
+ 
+ 		return 0;
+@@ -1031,6 +1047,8 @@ static netdev_tx_t ipip6_tunnel_xmit(str
+ 
+ 	skb_set_inner_ipproto(skb, IPPROTO_IPV6);
+ 
++	/* Reset the skb_iif to Tunnels interface index */
++	skb->skb_iif = tunnel->dev->ifindex;
+ 	iptunnel_xmit(NULL, rt, skb, fl4.saddr, fl4.daddr, protocol, tos, ttl,
+ 		      df, !net_eq(tunnel->net, dev_net(dev)));
+ 	return NETDEV_TX_OK;
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960354-net-added-a-new-netdevice-priv-flag-for-soft-tunnel.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,28 @@
+From e3e9167247b3e234d915e25a4692ed6c6ec11935 Mon Sep 17 00:00:00 2001
+From: Vishnu Vardhan Bantanahal <quic_vishvard@quicinc.com>
+Date: Thu, 1 Jun 2023 17:55:00 +0530
+Subject: [PATCH 271/500] net: added a new netdevice priv flag for soft tunnel
+
+This flag can be used by flow acceleration managers
+to identify whether a flow is originated from or
+destined to a tun/tap device
+
+Change-Id: I9631a13f083f5096be2c0046eedd277b9971c72d
+Signed-off-by: Amit Gupta <amitgupt@codeaurora.org>
+Signed-off-by: Pavithra R <pavir@codeaurora.org>
+Signed-off-by: Vishnu Vardhan Bantanahal <quic_vishvard@quicinc.com>
+Signed-off-by: Pavithra R <quic_pavir@quicinc.com>
+---
+ drivers/net/tun.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/net/tun.c
++++ b/drivers/net/tun.c
+@@ -999,6 +999,7 @@ static int tun_net_init(struct net_devic
+ 	dev->vlan_features = dev->features &
+ 			     ~(NETIF_F_HW_VLAN_CTAG_TX |
+ 			       NETIF_F_HW_VLAN_STAG_TX);
++	dev->priv_flags_ext |= IFF_EXT_TUN_TAP;
+ 
+ 	tun->flags = (tun->flags & ~TUN_FEATURES) |
+ 		      (ifr->ifr_flags & TUN_FEATURES);
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960355-Squashed-commit-of-the-following.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,126 @@
+From 926028b718c2a79b02365698fbac658b2ec5d297 Mon Sep 17 00:00:00 2001
+From: Ramkishan Gurjar <quic_rgurjar@quicinc.com>
+Date: Tue, 3 Oct 2023 09:42:20 +0530
+Subject: [PATCH 240/500] Squashed commit of the following:
+
+commit cde5e3757488b6753036c3e31a124b25f50a93fd
+Author: Ken Zhu <guigenz@codeaurora.org>
+Date:   Mon Mar 12 11:21:31 2018 -0700
+
+    linux: fix the memory is not clean after memmove
+
+    the memory won't be set to zero after memmove, set it
+    to zero.
+
+    Change-Id: I9996aa5fa56a41967e31ec4df9820932feec6256
+    Signed-off-by: Ken Zhu <guigenz@codeaurora.org>
+
+commit a81e33134a7d14a8fb9e1f636b946affb2c8fc80
+Author: Himanshu Joshi <himajosh@codeaurora.org>
+Date:   Fri Apr 24 12:12:10 2020 +0530
+
+    net: add draft03 specification support for tunipip6
+
+    draft03 of map-e is used in some environment, we add this supported
+
+    Change-Id: I81462632f0e6f2b5af0b1f8229c42572892c5972
+    Signed-off-by: Zhu Ken <guigenz@codeaurora.org>
+
+Change-Id: I3569082ddbdf3f30b8ab273cb7dc9ab2bfbc886c
+---
+ include/net/ip6_tunnel.h       |  1 +
+ include/uapi/linux/if_tunnel.h |  1 +
+ net/ipv6/ip6_tunnel.c          | 31 +++++++++++++++++++++++++++----
+ 3 files changed, 29 insertions(+), 4 deletions(-)
+
+--- a/include/net/ip6_tunnel.h
++++ b/include/net/ip6_tunnel.h
+@@ -37,6 +37,7 @@ struct __ip6_tnl_parm {
+ 	__u8 encap_limit;	/* encapsulation limit for tunnel */
+ 	__u8 hop_limit;		/* hop limit for tunnel */
+ 	bool collect_md;
++	__u8 draft03;		/* FMR using draft03 of map-e */
+ 	__be32 flowinfo;	/* traffic class and flowlabel for tunnel */
+ 	__u32 flags;		/* tunnel flags */
+ 	struct in6_addr laddr;	/* local tunnel end-point address */
+--- a/include/uapi/linux/if_tunnel.h
++++ b/include/uapi/linux/if_tunnel.h
+@@ -78,6 +78,7 @@ enum {
+ 	IFLA_IPTUN_COLLECT_METADATA,
+ 	IFLA_IPTUN_FWMARK,
+ 	IFLA_IPTUN_FMRS,
++	IFLA_IPTUN_DRAFT03,
+ 	__IFLA_IPTUN_MAX,
+ };
+ #define IFLA_IPTUN_MAX	(__IFLA_IPTUN_MAX - 1)
+--- a/net/ipv6/ip6_tunnel.c
++++ b/net/ipv6/ip6_tunnel.c
+@@ -839,7 +839,7 @@ EXPORT_SYMBOL_GPL(ip6_tnl_rcv_ctl);
+  **/
+ static void ip4ip6_fmr_calc(struct in6_addr *dest,
+ 		const struct iphdr *iph, const uint8_t *end,
+-		const struct __ip6_tnl_fmr *fmr, bool xmit)
++		const struct __ip6_tnl_fmr *fmr, bool xmit, bool draft03)
+ {
+ 	int psidlen = fmr->ea_len - (32 - fmr->ip4_prefix_len);
+ 	u8 *portp = NULL;
+@@ -927,10 +927,28 @@ static void ip4ip6_fmr_calc(struct in6_a
+ 			<< (64 - fmr->ea_len - fromrem));
+ 		t = cpu_to_be64(t | (eabits >> fromrem));
+ 		memcpy(&dest->s6_addr[frombyte], &t, bytes);
++		if (draft03) {
++			/**
++			 * Draft03 IPv6 address format
++			 * +--+---+---+---+---+---+---+---+---+
++			 * |PL|   8  16  24  32   40  48  56  |
++			 * +--+---+---+---+---+---+---+---+---+
++			 * |64| u | IPv4 address  |PSID   |0  |
++			 * +--+---+---+---+---+---+---+---+---+
++			 * Final specification IPv6 address format
++			 * +--+---+---+---+---+---+---+---+---+
++			 * |PL|   8  16  24  32   40  48  56  |
++			 * +--+---+---+---+---+---+---+---+---+
++			 * |64|   0   | IPv4 address  |PSID   |
++			 * +--+---+---+---+---+---+---+---+---+
++			 * We need move last six Bytes 1 byte forward
++			 */
++			memmove(&dest->s6_addr[9], &dest->s6_addr[10], 6);
++			dest->s6_addr[15] = 0;
++		}
+ 	}
+ }
+ 
+-
+ static int __ip6_tnl_rcv(struct ip6_tnl *tunnel, struct sk_buff *skb,
+ 			 const struct tnl_ptk_info *tpi,
+ 			 struct metadata_dst *tun_dst,
+@@ -1011,7 +1029,8 @@ static int __ip6_tnl_rcv(struct ip6_tnl
+ 			/* Check that IPv6 matches IPv4 source to prevent spoofing */
+ 			if (fmr)
+ 				ip4ip6_fmr_calc(&expected, ip_hdr(skb),
+-						skb_tail_pointer(skb), fmr, false);
++						skb_tail_pointer(skb), fmr, false,
++						tunnel->parms.draft03);
+ 
+ 			if (!ipv6_addr_equal(&ipv6h->saddr, &expected)) {
+ 				rcu_read_unlock();
+@@ -1573,7 +1592,8 @@ ipxip6_tnl_xmit(struct sk_buff *skb, str
+ 
+ 		/* change dstaddr according to FMR */
+ 		if (fmr)
+-			ip4ip6_fmr_calc(&fl6.daddr, ip_hdr(skb), skb_tail_pointer(skb), fmr, true);
++			ip4ip6_fmr_calc(&fl6.daddr, ip_hdr(skb), skb_tail_pointer(skb), fmr,
++					true, t->parms.draft03);
+ 	}
+ 
+ 	if (iptunnel_handle_offloads(skb, SKB_GSO_IPXIP6))
+@@ -2207,6 +2227,9 @@ static void ip6_tnl_netlink_parms(struct
+ 	if (data[IFLA_IPTUN_FWMARK])
+ 		parms->fwmark = nla_get_u32(data[IFLA_IPTUN_FWMARK]);
+ 
++	if (data[IFLA_IPTUN_DRAFT03])
++		parms->draft03 = nla_get_u8(data[IFLA_IPTUN_DRAFT03]);
++
+ 	if (data[IFLA_IPTUN_FMRS]) {
+ 		unsigned rem;
+ 		struct nlattr *fmr;
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960357-net-Add-support-for-qdisc-fast.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,284 @@
+From 763a7b3e372482e19efaed02c25ce9e60e61b8b3 Mon Sep 17 00:00:00 2001
+From: Sourav Poddar <quic_souravp@quicinc.com>
+Date: Fri, 18 Nov 2022 09:45:57 +0530
+Subject: [PATCH 368/500] net: Add support for qdisc fast
+
+Add API to process qdisc on a given virtual interface
+and directly transmit to a given underlying interface
+after the qdisc is run
+
+Change-Id: Ia7ebc94ef5c612ca85964d82eea6036dcce0b5c7
+Signed-off-by: Sourav Poddar <quic_souravp@quicinc.com>
+Signed-off-by: Tushar Ganatra <quic_tganatra@quicinc.com>
+---
+ include/linux/netdevice.h |   1 +
+ net/core/dev.c            | 122 +++++++++++++++++++++++++++++++++++++-
+ net/sched/sch_generic.c   |  94 ++++++++++++++++++++++++++++-
+ 3 files changed, 213 insertions(+), 4 deletions(-)
+
+--- a/include/linux/netdevice.h
++++ b/include/linux/netdevice.h
+@@ -3191,6 +3191,7 @@ static inline int dev_direct_xmit(struct
+ bool dev_fast_xmit_vp(struct sk_buff *skb, struct net_device *dev);
+ bool dev_fast_xmit(struct sk_buff *skb, struct net_device *dev,
+ 		   netdev_features_t features);
++bool dev_fast_xmit_qdisc(struct sk_buff *skb, struct net_device *top_qdisc_dev, struct net_device *bottom_dev);
+ int register_netdevice(struct net_device *dev);
+ void unregister_netdevice_queue(struct net_device *dev, struct list_head *head);
+ void unregister_netdevice_many(struct list_head *head);
+--- a/net/core/dev.c
++++ b/net/core/dev.c
+@@ -3623,7 +3623,6 @@ struct sk_buff *dev_hard_start_xmit(stru
+ 
+ 	while (skb) {
+ 		struct sk_buff *next = skb->next;
+-
+ 		skb_mark_not_on_list(skb);
+ 		rc = xmit_one(skb, dev, txq, next != NULL);
+ 		if (unlikely(!dev_xmit_complete(rc))) {
+@@ -3818,6 +3817,60 @@ static int dev_qdisc_enqueue(struct sk_b
+ 	return rc;
+ }
+ 
++static inline int __dev_xmit_skb_qdisc(struct sk_buff *skb, struct Qdisc *q,
++				 struct net_device *top_qdisc_dev,
++				 struct netdev_queue *top_txq)
++{
++	spinlock_t *root_lock = qdisc_lock(q);
++	struct sk_buff *to_free = NULL;
++	bool contended;
++	int rc;
++
++	qdisc_calculate_pkt_len(skb, q);
++
++	if (q->flags & TCQ_F_NOLOCK) {
++		rc = q->enqueue(skb, q, &to_free) & NET_XMIT_MASK;
++		if (likely(!netif_xmit_frozen_or_stopped(top_txq)))
++			qdisc_run(q);
++
++		if (unlikely(to_free))
++			kfree_skb_list(to_free);
++		return rc;
++	}
++
++	/*
++	 * Heuristic to force contended enqueues to serialize on a
++	 * separate lock before trying to get qdisc main lock.
++	 * This permits qdisc->running owner to get the lock more
++	 * often and dequeue packets faster.
++	 */
++	contended = qdisc_is_running(q);
++	if (unlikely(contended))
++		spin_lock(&q->busylock);
++
++	spin_lock(root_lock);
++	if (unlikely(test_bit(__QDISC_STATE_DEACTIVATED, &q->state))) {
++		__qdisc_drop(skb, &to_free);
++		rc = NET_XMIT_DROP;
++	} else {
++		rc = q->enqueue(skb, q, &to_free) & NET_XMIT_MASK;
++		if (qdisc_run_begin(q)) {
++			if (unlikely(contended)) {
++				spin_unlock(&q->busylock);
++				contended = false;
++			}
++			__qdisc_run(q);
++			qdisc_run_end(q);
++		}
++	}
++	spin_unlock(root_lock);
++	if (unlikely(to_free))
++		kfree_skb_list(to_free);
++	if (unlikely(contended))
++		spin_unlock(&q->busylock);
++	return rc;
++}
++
+ static inline int __dev_xmit_skb(struct sk_buff *skb, struct Qdisc *q,
+ 				 struct net_device *dev,
+ 				 struct netdev_queue *txq)
+@@ -4361,6 +4414,73 @@ q_xmit:
+ EXPORT_SYMBOL(dev_fast_xmit_vp);
+ 
+ /**
++ *	dev_fast_xmit_qdisc - fast xmit the skb along with qdisc processing
++ *	@skb:buffer to transmit
++ *	@top_qdisc_dev: the top device on which qdisc is enabled.
++ *	@bottom_dev: the device on which transmission should happen after qdisc processing.
++ *	sucessful return true
++ *	failed return false
++ */
++bool dev_fast_xmit_qdisc(struct sk_buff *skb, struct net_device *top_qdisc_dev, struct net_device *bottom_dev)
++{
++        struct netdev_queue *txq;
++	struct Qdisc *q;
++	int rc = -ENOMEM;
++
++	if (unlikely(!(top_qdisc_dev->flags & IFF_UP))) {
++		return false;
++	}
++
++	skb_reset_mac_header(skb);
++
++	/* Disable soft irqs for various locks below. Also
++	 * stops preemption for RCU.
++	 */
++	rcu_read_lock_bh();
++
++	txq = netdev_core_pick_tx(top_qdisc_dev, skb, NULL);
++	q = rcu_dereference_bh(txq->qdisc);
++	if (unlikely(!q->enqueue)) {
++		rcu_read_unlock_bh();
++		return false;
++	}
++
++	skb_update_prio(skb);
++
++	qdisc_pkt_len_init(skb);
++#ifdef CONFIG_NET_CLS_ACT
++	skb->tc_at_ingress = 0;
++#ifdef CONFIG_NET_EGRESS
++	if (static_branch_unlikely(&egress_needed_key)) {
++		skb = sch_handle_egress(skb, &rc, top_qdisc_dev);
++		if (!skb) {
++			rcu_read_unlock_bh();
++			return true;
++		}
++	}
++#endif
++#endif
++	/* If device/qdisc don't need skb->dst, release it right now while
++	 * its hot in this cpu cache.
++	 * TODO: do we need this ?
++	 */
++	if (top_qdisc_dev->priv_flags & IFF_XMIT_DST_RELEASE)
++		skb_dst_drop(skb);
++	else
++		skb_dst_force(skb);
++
++	trace_net_dev_queue(skb);
++
++	/* Update the dev so that we can transmit to bottom device after qdisc */
++	skb->dev = bottom_dev;
++	rc = __dev_xmit_skb_qdisc(skb, q, top_qdisc_dev, txq);
++
++	rcu_read_unlock_bh();
++	return true;
++}
++EXPORT_SYMBOL(dev_fast_xmit_qdisc);
++
++/**
+  *	dev_fast_xmit - fast xmit the skb
+  *	@skb:buffer to transmit
+  *	@dev: the device to be transmited to
+--- a/net/sched/sch_generic.c
++++ b/net/sched/sch_generic.c
+@@ -311,6 +311,68 @@ trace:
+  *				false  - hardware queue frozen backoff
+  *				true   - feel free to send more pkts
+  */
++bool sch_direct_xmit_fast(struct sk_buff *first, struct Qdisc *q, struct net_device *dev, spinlock_t *root_lock)
++{
++	struct sk_buff *skb = first;
++	int rc = NETDEV_TX_OK;
++	struct netdev_queue *txq;
++	int cpu;
++
++	if (unlikely(!(dev->flags & IFF_UP))) {
++		dev_kfree_skb_any(skb);
++		return true;
++	}
++
++	/*
++	 * If GSO is enabled then handle segmentation through dev_queue_xmit
++	 */
++	if (unlikely(skb_is_gso(skb))) {
++		if (root_lock)
++			spin_unlock(root_lock);
++		dev_queue_xmit(first);
++		if (root_lock)
++			spin_lock(root_lock);
++		return true;
++	}
++
++	cpu = smp_processor_id();
++
++	txq = netdev_core_pick_tx(dev, skb, NULL);
++
++	if (likely(txq->xmit_lock_owner != cpu)) {
++		HARD_TX_LOCK(dev, txq, smp_processor_id());
++		if (likely(!netif_xmit_stopped(txq))) {
++			rc = netdev_start_xmit(skb, dev, txq, 0);
++			if (unlikely(!dev_xmit_complete(rc))) {
++				HARD_TX_UNLOCK(dev, txq);
++				/*
++				 * If we dont able to enqueue this to bottom interface, then we
++				 * cannot requeue the packet back, as qdisc was enabled on different
++				 * interface and transmit interface is different
++				 */
++				dev_kfree_skb_any(skb);
++				return true;
++			}
++		} else {
++			dev_kfree_skb_any(skb);
++		}
++		HARD_TX_UNLOCK(dev, txq);
++	} else {
++		dev_kfree_skb_any(skb);
++	}
++
++	return true;
++}
++
++/*
++ * Transmit possibly several skbs, and handle the return status as
++ * required. Owning running seqcount bit guarantees that
++ * only one CPU can execute this function.
++ *
++ * Returns to the caller:
++ *				false  - hardware queue frozen backoff
++ *				true   - feel free to send more pkts
++ */
+ bool sch_direct_xmit(struct sk_buff *skb, struct Qdisc *q,
+ 		     struct net_device *dev, struct netdev_queue *txq,
+ 		     spinlock_t *root_lock, bool validate)
+@@ -401,10 +463,36 @@ static inline bool qdisc_restart(struct
+ 	if (!(q->flags & TCQ_F_NOLOCK))
+ 		root_lock = qdisc_lock(q);
+ 
+-	dev = qdisc_dev(q);
+-	txq = skb_get_tx_queue(dev, skb);
++	while (skb) {
++		struct sk_buff *next = skb->next;
++		skb->next = NULL;
++
++		if (likely(skb->fast_forwarded)) {
++			/*
++			 * For SFE fast forwarded packets, we send packets directly
++			 * to physical interface pointed to by skb->dev
++			 */
++			if (!sch_direct_xmit_fast(skb, q, skb->dev, root_lock)) {
++				return false;
++			}
++		} else {
++			dev = qdisc_dev(q);
++			txq = skb_get_tx_queue(dev, skb);
++
++			if (!sch_direct_xmit(skb, q, dev, txq, root_lock, validate)) {
++				if (next) {
++					skb = next;
++					dev_requeue_skb(skb, q);
++				}
++
++				return false;
++			}
++		}
+ 
+-	return sch_direct_xmit(skb, q, dev, txq, root_lock, validate);
++		skb = next;
++	}
++
++	return true;
+ }
+ 
+ void __qdisc_run(struct Qdisc *q)
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960358-net-qdisc_fast-Fix-gso-handling-when-qdisc-in-enable.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,66 @@
+From 3ce452bf25b6a09de843b394acfe88614608e959 Mon Sep 17 00:00:00 2001
+From: Sourav Poddar <quic_souravp@quicinc.com>
+Date: Tue, 17 Jan 2023 14:27:49 +0530
+Subject: [PATCH 369/500] net: qdisc_fast: Fix gso handling when qdisc in
+ enabled on bottom interface with TSO enabled
+
+Change-Id: Ia12e5becebe96b0628a111e4db825fd335aba867
+Signed-off-by: Sourav Poddar <quic_souravp@quicinc.com>
+Signed-off-by: Tushar Ganatra <quic_tganatra@quicinc.com>
+---
+ include/linux/skbuff.h  | 2 ++
+ net/core/dev.c          | 1 +
+ net/core/skbuff.c       | 1 +
+ net/sched/sch_generic.c | 7 +++++--
+ 4 files changed, 9 insertions(+), 2 deletions(-)
+
+--- a/include/linux/skbuff.h
++++ b/include/linux/skbuff.h
+@@ -994,6 +994,8 @@ struct sk_buff {
+ 	__u8			fast_recycled:1;
+ 	/* Flag for recycle in PPE DS */
+ 	__u8			recycled_for_ds:1;
++	__u8			fast_qdisc:1;
++	/* Packets processed in dev_fast_xmit_qdisc() path */
+ 
+ #if defined(CONFIG_NET_SCHED) || defined(CONFIG_NET_XGRESS)
+ 	__u16			tc_index;	/* traffic control index */
+--- a/net/core/dev.c
++++ b/net/core/dev.c
+@@ -4473,6 +4473,7 @@ bool dev_fast_xmit_qdisc(struct sk_buff
+ 
+ 	/* Update the dev so that we can transmit to bottom device after qdisc */
+ 	skb->dev = bottom_dev;
++	skb->fast_qdisc = 1;
+ 	rc = __dev_xmit_skb_qdisc(skb, q, top_qdisc_dev, txq);
+ 
+ 	rcu_read_unlock_bh();
+--- a/net/core/skbuff.c
++++ b/net/core/skbuff.c
+@@ -861,6 +861,7 @@ struct sk_buff *__netdev_alloc_skb_no_sk
+ 		*/
+ 		skb->truesize = SKB_TRUESIZE(SKB_DATA_ALIGN(len + NET_SKB_PAD));
+ 		skb->fast_recycled = 0;
++		skb->fast_qdisc = 0;
+ 		return skb;
+ 	}
+ 
+--- a/net/sched/sch_generic.c
++++ b/net/sched/sch_generic.c
+@@ -467,11 +467,14 @@ static inline bool qdisc_restart(struct
+ 		struct sk_buff *next = skb->next;
+ 		skb->next = NULL;
+ 
+-		if (likely(skb->fast_forwarded)) {
++		if (likely(skb->fast_qdisc)) {
+ 			/*
+-			 * For SFE fast forwarded packets, we send packets directly
++			 * For SFE fast_qdisc marked packets, we send packets directly
+ 			 * to physical interface pointed to by skb->dev
++			 * We can clear fast_qdisc since we will not re-enqueue packet in this
++			 * path
+ 			 */
++			skb->fast_qdisc = 0;
+ 			if (!sch_direct_xmit_fast(skb, q, skb->dev, root_lock)) {
+ 				return false;
+ 			}
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960359-skbuff-Add-int_pri-field-to-skb.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,49 @@
+From d6b853dcd8897dea1afcbd857b3c5ea7a89e761c Mon Sep 17 00:00:00 2001
+From: Amruth S <quic_amrus@quicinc.com>
+Date: Thu, 9 Feb 2023 23:08:18 -0800
+Subject: [PATCH 370/500] skbuff: Add int_pri field to skb.
+
+Change-Id: Ib13cd56fc5d8afe66b74935b6f8b0665eafdd298
+Signed-off-by: Amruth S <quic_amrus@quicinc.com>
+Signed-off-by: Tushar Ganatra <quic_tganatra@quicinc.com>
+---
+ include/linux/skbuff.h | 21 +++++++++++++++++++++
+ 1 file changed, 21 insertions(+)
+
+--- a/include/linux/skbuff.h
++++ b/include/linux/skbuff.h
+@@ -996,6 +996,8 @@ struct sk_buff {
+ 	__u8			recycled_for_ds:1;
+ 	__u8			fast_qdisc:1;
+ 	/* Packets processed in dev_fast_xmit_qdisc() path */
++	__u8			int_pri:4;
++	/* Priority info for hardware qdiscs */
+ 
+ #if defined(CONFIG_NET_SCHED) || defined(CONFIG_NET_XGRESS)
+ 	__u16			tc_index;	/* traffic control index */
+@@ -2724,6 +2726,25 @@ static inline void *pskb_pull(struct sk_
+ void skb_condense(struct sk_buff *skb);
+ 
+ /**
++ *	skb_set_int_pri - sets the int_pri field in skb with given value.
++ *	@skb: buffer to fill
++ *	@int_pri: value that is to be filled
++ */
++static inline void skb_set_int_pri(struct sk_buff *skb, uint8_t int_pri)
++{
++	skb->int_pri = int_pri;
++}
++
++/**
++ *	skb_get_int_pri - gets the int_pri value from the given skb.
++ *	@skb: buffer to check
++ */
++static inline uint8_t skb_get_int_pri(struct sk_buff *skb)
++{
++	return skb->int_pri;
++}
++
++/**
+  *	skb_headroom - bytes at buffer head
+  *	@skb: buffer to check
+  *
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960361-net-sch-Add-Qdisc-flag-for-NSS.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,34 @@
+From b70b0f29e7bb585d8290d46e0a583517b3d3865a Mon Sep 17 00:00:00 2001
+From: Suruchi Agarwal <suruchia@codeaurora.org>
+Date: Fri, 12 Apr 2019 15:08:18 +0530
+Subject: [PATCH 373/500] net sch: Add Qdisc flag for NSS.
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+There is no check in nss qdisc clients to ensure if qdisc is allocated
+by nss or not. It simply type cast the private structure of qdisc to nss
+qdisc. If the private area of a non-nss qdisc is accessed and there is a
+size mismatch, then it can cause out of boundary memory access. This is
+what happens at boot time since by default qdisc is configured as
+“noqueue” whose private size is 0. So there is a need to add flag in
+qdisc structure to check the type of qdisc without accessing it's private
+area.
+
+Change-Id: I421b78b2868dd58689f5ea4c6523528ac2335763
+Signed-off-by: Suruchi Agarwal <suruchia@codeaurora.org>
+Signed-off-by: Tushar Ganatra <quic_tganatra@quicinc.com>
+---
+ include/net/sch_generic.h | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/include/net/sch_generic.h
++++ b/include/net/sch_generic.h
+@@ -94,6 +94,7 @@ struct Qdisc {
+ #define TCQ_F_INVISIBLE		0x80 /* invisible by default in dump */
+ #define TCQ_F_NOLOCK		0x100 /* qdisc does not require locking */
+ #define TCQ_F_OFFLOADED		0x200 /* qdisc is offloaded to HW */
++#define TCQ_F_NSS		0x1000 /* NSS qdisc flag. */
+ 	u32			limit;
+ 	const struct Qdisc_ops	*ops;
+ 	struct qdisc_size_table	__rcu *stab;
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960362-net-sched-Export-qdisc-API.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,22 @@
+From 7ceef6369f55ecaa5a402912f51f755ef80f8b2f Mon Sep 17 00:00:00 2001
+From: Suruchi Agarwal <suruchia@codeaurora.org>
+Date: Fri, 21 Jul 2017 10:14:19 -0700
+Subject: [PATCH 372/500] net: sched: Export qdisc API
+
+Change-Id: I3fa187214c97c7813aaa0f386ea14cb3209c5d3b
+Signed-off-by: Suruchi Agarwal <suruchia@codeaurora.org>
+Signed-off-by: Tushar Ganatra <quic_tganatra@quicinc.com>
+---
+ net/sched/sch_api.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/net/sched/sch_api.c
++++ b/net/sched/sch_api.c
+@@ -314,6 +314,7 @@ struct Qdisc *qdisc_lookup(struct net_de
+ out:
+ 	return q;
+ }
++EXPORT_SYMBOL(qdisc_lookup);
+ 
+ struct Qdisc *qdisc_lookup_rcu(struct net_device *dev, u32 handle)
+ {
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960363-include-Add-support-for-PPE-Qdisc.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,155 @@
+From 212d398d0beff4677aa3263a6a071e6364077974 Mon Sep 17 00:00:00 2001
+From: Amruth S <quic_amrus@quicinc.com>
+Date: Thu, 29 Sep 2022 09:07:46 -0700
+Subject: [PATCH 374/500] include: Add support for PPE Qdisc.
+
+Change-Id: I8e7f07962be26a7562a944f71ee327f377a85635
+Signed-off-by: Amruth S <quic_amrus@quicinc.com>
+Signed-off-by: Tushar Ganatra <quic_tganatra@quicinc.com>
+---
+ include/uapi/linux/pkt_sched.h | 134 +++++++++++++++++++++++++++++++++
+ 1 file changed, 134 insertions(+)
+
+--- a/include/uapi/linux/pkt_sched.h
++++ b/include/uapi/linux/pkt_sched.h
+@@ -119,6 +119,140 @@ enum {
+ 
+ #define TCA_STAB_MAX (__TCA_STAB_MAX - 1)
+ 
++
++/* PPEFIFO section */
++
++enum {
++        TCA_PPEFIFO_UNSPEC,
++        TCA_PPEFIFO_PARMS,
++        __TCA_PPEFIFO_MAX
++};
++
++#define TCA_PPEFIFO_MAX (__TCA_PPEFIFO_MAX - 1)
++
++struct tc_ppefifo_qopt {
++        __u32   limit;		/* Queue length: bytes for bfifo, packets for pfifo */
++        __u8    set_default;	/* Sets qdisc to be the default qdisc for enqueue */
++};
++
++/* PPERED section */
++
++enum {
++        TCA_PPERED_UNSPEC,
++        TCA_PPERED_PARMS,
++        __TCA_PPERED_MAX
++};
++
++#define TCA_PPERED_MAX (__TCA_PPERED_MAX - 1)
++
++struct tc_red_alg_parameter {
++    __u32   min;    /* qlen_avg < min: pkts are all enqueued */
++    __u32   max;    /* qlen_avg > max: pkts are all dropped */
++    __u32   probability;/* Drop probability at qlen_avg = max */
++    __u32   exp_weight_factor;/* exp_weight_factor for calculate qlen_avg */
++};
++
++struct tc_ppered_qopt {
++	__u32	limit;				/* Queue length */
++	struct	tc_red_alg_parameter rap;	/* RED algorithm parameters */
++	__u8	ecn;				/* Setting ECN bit or dropping */
++	__u8	set_default;			/* Sets qdisc to be the default for enqueue */
++};
++
++/* PPETBL section */
++
++enum {
++        TCA_PPETBL_UNSPEC,
++        TCA_PPETBL_PARMS,
++        __TCA_PPETBL_MAX
++};
++
++#define TCA_PPETBL_MAX  (__TCA_PPETBL_MAX - 1)
++
++struct tc_ppetbl_qopt {
++       __u32	rate;	/* Limiting rate of TBF */
++       __u32	burst;	/* Maximum burst size */
++       __u32	mtu;	/* Max size of packet, or minumim burst size */
++};
++
++/* PPEPRIO section */
++
++#define TCA_PPEPRIO_MAX_BANDS 4
++
++enum {
++        TCA_PPEPRIO_UNSPEC,
++        TCA_PPEPRIO_PARMS,
++        __TCA_PPEPRIO_MAX
++};
++
++#define TCA_PPEPRIO_MAX (__TCA_PPEPRIO_MAX - 1)
++
++struct tc_ppeprio_qopt {
++	int	bands;		/* Number of bands */
++};
++
++/* PPEWRR section */
++
++enum {
++        TCA_PPEWRR_UNSPEC,
++        TCA_PPEWRR_CLASS_PARMS,
++        TCA_PPEWRR_QDISC_PARMS,
++        __TCA_PPEWRR_MAX
++};
++
++#define TCA_PPEWRR_MAX  (__TCA_PPEWRR_MAX - 1)
++
++struct tc_ppewrr_class_qopt {
++        __u32   quantum;        /* Weight associated to this class */
++};
++
++struct tc_ppewrr_qopt {
++};
++
++
++/* PPEWFQ section*/
++
++enum {
++        TCA_PPEWFQ_UNSPEC,
++        TCA_PPEWFQ_CLASS_PARMS,
++        TCA_PPEWFQ_QDISC_PARMS,
++        __TCA_PPEWFQ_MAX
++};
++
++#define TCA_PPEWFQ_MAX  (__TCA_PPEWFQ_MAX - 1)
++
++struct tc_ppewfq_class_qopt {
++        __u32   quantum;        /* Weight associated to this class */
++};
++
++struct tc_ppewfq_qopt {
++};
++
++/* PPEHTB section */
++
++enum {
++        TCA_PPEHTB_UNSPEC,
++        TCA_PPEHTB_CLASS_PARMS,
++        TCA_PPEHTB_QDISC_PARMS,
++        __TCA_PPEHTB_MAX
++};
++
++#define TCA_PPEHTB_MAX  (__TCA_PPEHTB_MAX - 1)
++
++struct tc_ppehtb_class_qopt {
++	__u32   burst;		/* Allowed burst size */
++	__u32   rate;		/* Allowed bandwidth for this class */
++	__u32   cburst;		/* Maximum burst size */
++	__u32   crate;		/* Maximum bandwidth for this class */
++	__u32   quantum;	/* Quantum allocation for DRR */
++	__u32   priority;	/* Priority value associated with this class */
++	__u32   overhead;	/* Overhead in bytes per packet */
++};
++
++struct tc_ppehtb_qopt {
++	__u32	r2q;		/* Rate to quantum ratio */
++};
++
+ /* FIFO section */
+ 
+ struct tc_fifo_qopt {
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960428-net-macvlan-Add-statistics-update-function-for-macvl.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,108 @@
+From d07039264a75c131e627d5f2f13cf286efb63e42 Mon Sep 17 00:00:00 2001
+From: Suman Ghosh <sumaghos@codeaurora.org>
+Date: Thu, 10 Dec 2020 00:11:41 +0530
+Subject: [PATCH 412/500] net: macvlan: Add statistics update function for
+ macvlan net device.
+
+Signed-off-by: Suman Ghosh <sumaghos@codeaurora.org>
+Change-Id: I9cd995f9d1c0f85c61781a8af845b4dbb86bebd0
+
+net: macvlan: Avoid updating error and drop counters for offloaded statistics.
+
+Signed-off-by: Suman Ghosh <sumaghos@codeaurora.org>
+Change-Id: Ibb7f3f5a0e73cda140adee2c1640af03c698f6e6
+---
+ drivers/net/macvlan.c      | 27 +++++++++++++++++++++++++++
+ include/linux/if_macvlan.h | 24 ++++++++++++++++++++++++
+ 2 files changed, 51 insertions(+)
+
+--- a/drivers/net/macvlan.c
++++ b/drivers/net/macvlan.c
+@@ -960,6 +960,32 @@ static void macvlan_uninit(struct net_de
+ 		macvlan_port_destroy(port->dev);
+ }
+ 
++/* Update macvlan statistics processed by offload engines */
++static void macvlan_dev_update_stats(struct net_device *dev,
++				     struct rtnl_link_stats64 *offl_stats,
++				     bool update_mcast_rx_stats)
++{
++	struct vlan_pcpu_stats *stats;
++	struct macvlan_dev *macvlan;
++
++	/* Is this a macvlan? */
++	if (!netif_is_macvlan(dev))
++		return;
++
++	macvlan = netdev_priv(dev);
++	stats = this_cpu_ptr(macvlan->pcpu_stats);
++	u64_stats_update_begin(&stats->syncp);
++	u64_stats_add(&stats->rx_packets, offl_stats->rx_packets);
++	u64_stats_add(&stats->rx_bytes, offl_stats->rx_bytes);
++	u64_stats_add(&stats->tx_packets, offl_stats->tx_packets);
++	u64_stats_add(&stats->tx_bytes, offl_stats->tx_bytes);
++	/* Update multicast statistics */
++	if (unlikely(update_mcast_rx_stats)) {
++		u64_stats_add(&stats->rx_multicast, offl_stats->rx_packets);
++	}
++	u64_stats_update_end(&stats->syncp);
++}
++
+ static void macvlan_dev_get_stats64(struct net_device *dev,
+ 				    struct rtnl_link_stats64 *stats)
+ {
+@@ -1506,6 +1532,7 @@ int macvlan_common_newlink(struct net *s
+ 	vlan->dev      = dev;
+ 	vlan->port     = port;
+ 	vlan->set_features = MACVLAN_FEATURES;
++	vlan->offload_stats_update = macvlan_dev_update_stats;
+ 
+ 	vlan->mode     = MACVLAN_MODE_VEPA;
+ 	if (data && data[IFLA_MACVLAN_MODE])
+--- a/include/linux/if_macvlan.h
++++ b/include/linux/if_macvlan.h
+@@ -15,6 +15,11 @@ struct macvlan_port;
+ #define MACVLAN_MC_FILTER_BITS	8
+ #define MACVLAN_MC_FILTER_SZ	(1 << MACVLAN_MC_FILTER_BITS)
+ 
++/*
++ * Callback for updating interface statistics for macvlan flows offloaded from host CPU.
++ */
++typedef void (*macvlan_offload_stats_update_cb_t)(struct net_device *dev, struct rtnl_link_stats64 *stats, bool update_mcast_rx_stats);
++
+ struct macvlan_dev {
+ 	struct net_device	*dev;
+ 	struct list_head	list;
+@@ -35,6 +40,7 @@ struct macvlan_dev {
+ #ifdef CONFIG_NET_POLL_CONTROLLER
+ 	struct netpoll		*netpoll;
+ #endif
++	macvlan_offload_stats_update_cb_t	offload_stats_update;
+ };
+ 
+ static inline void macvlan_count_rx(const struct macvlan_dev *vlan,
+@@ -68,6 +74,24 @@ extern void macvlan_dellink(struct net_d
+ extern int macvlan_link_register(struct rtnl_link_ops *ops);
+ 
+ #if IS_ENABLED(CONFIG_MACVLAN)
++static inline void
++macvlan_offload_stats_update(struct net_device *dev,
++			     struct rtnl_link_stats64 *stats,
++			     bool update_mcast_rx_stats)
++{
++	struct macvlan_dev *macvlan = netdev_priv(dev);
++
++	macvlan->offload_stats_update(dev, stats, update_mcast_rx_stats);
++}
++
++static inline enum
++macvlan_mode macvlan_get_mode(struct net_device *dev)
++{
++	struct macvlan_dev *macvlan = netdev_priv(dev);
++
++	return macvlan->mode;
++}
++
+ static inline struct net_device *
+ macvlan_dev_real_dev(const struct net_device *dev)
+ {
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960430-linux-5.4-Fix-RCU-stall-while-updating-OVS-stats.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,63 @@
+From 28c5fd42b289313f8ed02d48c23489c012805af8 Mon Sep 17 00:00:00 2001
+From: Suruchi Suman <quic_surusuma@quicinc.com>
+Date: Mon, 22 May 2023 19:40:11 +0530
+Subject: [PATCH 289/500] [linux-5.4] Fix RCU stall while updating OVS stats
+
+Reason of the stall was two functions taking the same stats lock() but one is called from
+process context while other is called from bottom half context. So, this change will make sure
+that stats are updated in bottom half context by all functions.
+
+Change-Id: If27ea71734f477174dbe7669521d7bec55ba038e
+Signed-off-by: Suruchi Suman <quic_surusuma@quicinc.com>
+---
+ net/openvswitch/datapath.c | 4 ++--
+ net/openvswitch/flow.c     | 6 +++---
+ 2 files changed, 5 insertions(+), 5 deletions(-)
+
+--- a/net/openvswitch/datapath.c
++++ b/net/openvswitch/datapath.c
+@@ -2741,7 +2741,7 @@ int ovs_accel_flow_stats_update(void *dp
+ 
+ 	rcu_read_unlock();
+ 
+-	spin_lock(&stats->lock);
++	spin_lock_bh(&stats->lock);
+ 	stats->used = jiffies;
+ 	stats->packet_count += pkts;
+ 	stats->byte_count += bytes;
+@@ -2764,7 +2764,7 @@ int ovs_accel_flow_stats_update(void *dp
+ 	dp_stats->n_cache_hit += n_cache_hit * pkts;
+ 	u64_stats_update_end(&dp_stats->syncp);
+ 
+-	spin_unlock(&stats->lock);
++	spin_unlock_bh(&stats->lock);
+ 	return 0;
+ }
+ EXPORT_SYMBOL(ovs_accel_flow_stats_update);
+--- a/net/openvswitch/flow.c
++++ b/net/openvswitch/flow.c
+@@ -69,13 +69,13 @@ void ovs_flow_stats_update(struct sw_flo
+ 
+ 	/* Check if already have CPU-specific stats. */
+ 	if (likely(stats)) {
+-		spin_lock(&stats->lock);
++		spin_lock_bh(&stats->lock);
+ 		/* Mark if we write on the pre-allocated stats. */
+ 		if (cpu == 0 && unlikely(flow->stats_last_writer != cpu))
+ 			flow->stats_last_writer = cpu;
+ 	} else {
+ 		stats = rcu_dereference(flow->stats[0]); /* Pre-allocated. */
+-		spin_lock(&stats->lock);
++		spin_lock_bh(&stats->lock);
+ 
+ 		/* If the current CPU is the only writer on the
+ 		 * pre-allocated stats keep using them.
+@@ -121,7 +121,7 @@ void ovs_flow_stats_update(struct sw_flo
+ 	stats->byte_count += len;
+ 	stats->tcp_flags |= tcp_flags;
+ unlock:
+-	spin_unlock(&stats->lock);
++	spin_unlock_bh(&stats->lock);
+ }
+ 
+ /* Must be called with rcu_read_lock or ovs_mutex. */
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960439-net-nat44-Fix-for-Linux-NAPT-limitaion.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,56 @@
+From c681828cca08c7fa5d2a52366ada83cf80f4b39b Mon Sep 17 00:00:00 2001
+From: Apoorv Gupta <apoogupt@codeaurora.org>
+Date: Fri, 18 May 2018 16:18:59 +0530
+Subject: [PATCH 348/500] net: nat44: Fix for Linux NAPT limitaion.
+
+When multiple iptables rules are configured with different port-ranges,
+kernel code doesn't fall through to next rule in the chain, even if all
+ports available in the current rule are exhausted, so the kernel makes
+the flow to share the same snat 5-tuple with other flows.
+
+This fix returns XT_CONTINUE when the tuple returned by get_unique_tuple
+is already used. Hence, it will move to next rule available in the chain.
+
+NF_NAT_TRY_NEXT_RULE in netfilter/Kconfig should be set to 'y' prior to
+using this fix.
+
+Change-Id: I414887198ecf367c1be97f6f9495b4eb8d36b689
+Signed-off-by: Apoorv Gupta <apoogupt@codeaurora.org>
+Signed-off-by: Pavithra R <quic_pavir@quicinc.com>
+---
+ net/netfilter/Kconfig       | 9 +++++++++
+ net/netfilter/nf_nat_core.c | 5 +++++
+ 2 files changed, 14 insertions(+)
+
+--- a/net/netfilter/Kconfig
++++ b/net/netfilter/Kconfig
+@@ -473,6 +473,15 @@ config NF_NAT_TFTP
+ 	depends on NF_CONNTRACK && NF_NAT
+ 	default NF_NAT && NF_CONNTRACK_TFTP
+ 
++config NF_NAT_TRY_NEXT_RULE
++	tristate
++	depends on NF_CONNTRACK && NF_NAT
++	default n
++	help
++	  If this option is enabled, the iptables will move on to the
++	  next rule in the chain if a unique tuple is not found for
++	  translation from the current matched rule.
++
+ config NF_NAT_REDIRECT
+ 	bool
+ 
+--- a/net/netfilter/nf_nat_core.c
++++ b/net/netfilter/nf_nat_core.c
+@@ -800,6 +800,11 @@ nf_nat_setup_info(struct nf_conn *ct,
+ 
+ 	get_unique_tuple(&new_tuple, &curr_tuple, range, ct, maniptype);
+ 
++#if IS_ENABLED(CONFIG_NF_NAT_TRY_NEXT_RULE)
++	if (nf_nat_used_tuple(&new_tuple, ct))
++		return XT_CONTINUE;
++#endif
++
+ 	if (!nf_ct_tuple_equal(&new_tuple, &curr_tuple)) {
+ 		struct nf_conntrack_tuple reply;
+ 
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960441-netfilter-Fix-multicast-flow-is-not-applied-SNAT-cor.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,66 @@
+From 1011ceb695c8ebf989ba92ba62b52390044b2d08 Mon Sep 17 00:00:00 2001
+From: Ken Zhu <guigenz@codeaurora.org>
+Date: Tue, 2 Jan 2018 11:49:41 -0800
+Subject: [PATCH 350/500] netfilter: Fix multicast flow is not applied SNAT
+ correctly
+
+When bridge_nf_call_iptable is enabled, multicast flow
+can reach nf_nat_inet_fn twice for SNAT operation, the
+first time, it floods/snoops all ports of the bridge,
+it won't hit nat rule in the do_chain, so
+no nat operation required and finalized the conntrack,
+and the second time, it reach nf_nat_inet_fn for forwarding
+bridge to an upstream port, no do_chain is performed and
+using the first time's result.
+
+This is not the expected behavior. If the multicast is
+forwarding between ports of a bridge, accept it directly.
+
+Change-Id: I3dd3be2bd718051292a46485a1863cf127af4866
+Signed-off-by: Ken Zhu <guigenz@codeaurora.org>
+Signed-off-by: Pavithra R <quic_pavir@quicinc.com>
+---
+ net/netfilter/nf_nat_core.c | 25 +++++++++++++++++++++++++
+ 1 file changed, 25 insertions(+)
+
+--- a/net/netfilter/nf_nat_core.c
++++ b/net/netfilter/nf_nat_core.c
+@@ -24,6 +24,7 @@
+ #include <net/netfilter/nf_nat.h>
+ #include <net/netfilter/nf_nat_helper.h>
+ #include <uapi/linux/netfilter/nf_nat.h>
++#include <linux/netfilter_bridge.h>
+ 
+ #include "nf_internals.h"
+ 
+@@ -936,6 +937,30 @@ nf_nat_inet_fn(void *priv, struct sk_buf
+ 	case IP_CT_RELATED_REPLY:
+ 		/* Only ICMPs can be IP_CT_IS_REPLY.  Fallthrough */
+ 	case IP_CT_NEW:
++#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
++		/* when skb is forwarding between ports of a bridge,the
++		 * nf_bridge will be set and nf_bridge->physoutdev is not null,
++		 * We can assume that it is not expecting NAT operation.
++		 * when BR_HOOK is enabled, multicast packets will reach
++		 * postrouting twice,the first time is when it is forwarded
++		 * between ports of a bridge, the second time is that it is
++		 * forwarded to upstream port.
++		 *
++		 * It will perform traversing of the NAT table at the first
++		 * time, the next time, it will use the result of first time.
++		 * since forwarding betweeng ports of a bridge, it won't hit
++		 * rules of SNAT, it cause NO NAT operation on this skb when
++		 * forwarding to the upstream port.
++		 * To avoid the scenario above, accept it when it is forwarding
++		 * between ports of a bridge for multicast.
++		 */
++		if (skb->pkt_type == PACKET_MULTICAST) {
++			struct nf_bridge_info *nf_bridge =
++				nf_bridge_info_get(skb);
++			if (nf_bridge && nf_bridge->physoutdev)
++				return NF_ACCEPT;
++		}
++#endif
+ 		/* Seen it before?  This can happen for loopback, retrans,
+ 		 * or local packets.
+ 		 */
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960442-net-ipv4-ipv6-Delete-multicast-rule-during-mcproxy-s.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,73 @@
+From 021ce6b037acdf14790d617ed77a60318ddcff16 Mon Sep 17 00:00:00 2001
+From: Suman Ghosh <sumaghos@codeaurora.org>
+Date: Mon, 30 Apr 2018 19:25:46 +0530
+Subject: [PATCH 447/500] net :ipv4/ipv6 : Delete multicast rule during mcproxy
+ stop
+
+During mcproxy stop, call the delete callback
+
+Change-Id: Ia08a082f770a1a4b8443be187488ab814cf0ca26
+Signed-off-by: Suman Ghosh <sumaghos@codeaurora.org>
+---
+ net/ipv4/ipmr.c  |  5 +++++
+ net/ipv6/ip6mr.c | 11 +++++++++--
+ 2 files changed, 14 insertions(+), 2 deletions(-)
+
+--- a/net/ipv4/ipmr.c
++++ b/net/ipv4/ipmr.c
+@@ -1511,6 +1511,7 @@ static void mroute_clean_tables(struct m
+ 	struct net *net = read_pnet(&mrt->net);
+ 	struct mr_mfc *c, *tmp;
+ 	struct mfc_cache *cache;
++	u32 origin, group;
+ 	LIST_HEAD(list);
+ 	int i;
+ 
+@@ -1535,10 +1536,14 @@ static void mroute_clean_tables(struct m
+ 			rhltable_remove(&mrt->mfc_hash, &c->mnode, ipmr_rht_params);
+ 			list_del_rcu(&c->list);
+ 			cache = (struct mfc_cache *)c;
++			origin = cache->mfc_origin;
++			group = cache->mfc_mcastgrp;
+ 			call_ipmr_mfc_entry_notifiers(net, FIB_EVENT_ENTRY_DEL, cache,
+ 						      mrt->id);
+ 			mroute_netlink_event(mrt, cache, RTM_DELROUTE);
+ 			mr_cache_put(c);
++			/* Inform offload modules of the delete event */
++			ipmr_sync_entry_delete(origin, group);
+ 		}
+ 	}
+ 
+--- a/net/ipv6/ip6mr.c
++++ b/net/ipv6/ip6mr.c
+@@ -1754,7 +1754,9 @@ static int ip6mr_mfc_add(struct net *net
+ 
+ static void mroute_clean_tables(struct mr_table *mrt, int flags)
+ {
++	struct mfc6_cache *cache;
+ 	struct mr_mfc *c, *tmp;
++	struct in6_addr mc_origin, mc_group;
+ 	LIST_HEAD(list);
+ 	int i;
+ 
+@@ -1776,13 +1778,18 @@ static void mroute_clean_tables(struct m
+ 			if (((c->mfc_flags & MFC_STATIC) && !(flags & MRT6_FLUSH_MFC_STATIC)) ||
+ 			    (!(c->mfc_flags & MFC_STATIC) && !(flags & MRT6_FLUSH_MFC)))
+ 				continue;
++			cache = (struct mfc6_cache *)c;
++			memcpy(&mc_origin, &cache->mf6c_origin, sizeof(struct in6_addr));
++			memcpy(&mc_group, &cache->mf6c_mcastgrp, sizeof(struct in6_addr));
+ 			rhltable_remove(&mrt->mfc_hash, &c->mnode, ip6mr_rht_params);
+ 			list_del_rcu(&c->list);
+ 			call_ip6mr_mfc_entry_notifiers(read_pnet(&mrt->net),
+ 						       FIB_EVENT_ENTRY_DEL,
+-						       (struct mfc6_cache *)c, mrt->id);
+-			mr6_netlink_event(mrt, (struct mfc6_cache *)c, RTM_DELROUTE);
++						       cache, mrt->id);
++			mr6_netlink_event(mrt, cache, RTM_DELROUTE);
+ 			mr_cache_put(c);
++			/* Inform offload modules of the delete event */
++			ip6mr_sync_entry_delete(&mc_origin, &mc_group);
+ 		}
+ 	}
+ 
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960443-ipmr-change-the-data-type-of-packet-statistic-to-uns.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,35 @@
+From f0e0cad9ed53292f86f8723b1710c2b87798bffb Mon Sep 17 00:00:00 2001
+From: Tos Xu <txu@codeaurora.org>
+Date: Wed, 20 Jun 2018 16:11:58 -0700
+Subject: [PATCH 448/500] ipmr: change the data type of packet statistic to
+ unsigned long long and fix printing error.
+
+Change-Id: I79857a255d50d7bd5946b379a7c972610cc58a27
+Signed-off-by: Tos Xu <txu@codeaurora.org>
+---
+ net/ipv4/ipmr.c  | 2 +-
+ net/ipv6/ip6mr.c | 2 +-
+ 2 files changed, 2 insertions(+), 2 deletions(-)
+
+--- a/net/ipv4/ipmr.c
++++ b/net/ipv4/ipmr.c
+@@ -3186,7 +3186,7 @@ static int ipmr_vif_seq_show(struct seq_
+ 		vif_dev = vif_dev_read(vif);
+ 		name = vif_dev ? vif_dev->name : "none";
+ 		seq_printf(seq,
+-			   "%2td %-10s %8ld %7ld  %8ld %7ld %05X %08X %08X\n",
++			   "%2td %-10s %8llu %7llu  %8llu %7llu %05X %08X %08X\n",
+ 			   vif - mrt->vif_table,
+ 			   name, vif->bytes_in, vif->pkt_in,
+ 			   vif->bytes_out, vif->pkt_out,
+--- a/net/ipv6/ip6mr.c
++++ b/net/ipv6/ip6mr.c
+@@ -528,7 +528,7 @@ static int ip6mr_vif_seq_show(struct seq
+ 		name = vif_dev ? vif_dev->name : "none";
+ 
+ 		seq_printf(seq,
+-			   "%2td %-10s %8ld %7ld  %8ld %7ld %05X\n",
++			   "%2td %-10s %8llu %7llu  %8llu %7llu %05X\n",
+ 			   vif - mrt->vif_table,
+ 			   name, vif->bytes_in, vif->pkt_in,
+ 			   vif->bytes_out, vif->pkt_out,
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960536-net-Fix-usage-of-uninitialized-object-for-flushing-c.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,55 @@
+From dc9c60327aeff05eaa10eb1b050d98a7e5c0b89a Mon Sep 17 00:00:00 2001
+From: Amitesh Anand <quic_amitesh@quicinc.com>
+Date: Wed, 13 Mar 2024 16:40:18 +0530
+Subject: [PATCH] net: Fix usage of uninitialized object for flushing conntrack
+
+This fixes patch from Openwrt community:
+
+OpenWrt: 600-netfilter_conntrack_flush.patch
+netfilter: add support for flushing conntrack via /proc
+lede-commit 8193bbe59a74d34d6a26d4a8cb857b1952905314
+
+We must initialize nf_ct_iter_data object before calling
+nf_ct_iterate_cleanup_net(); else kernel receives garbage value
+for port_id and report.
+
+We observed crash for 32-bit kernel (where randomly portid=0,
+report=2). Crash is seen in file_ns_capable() because *file is NULL.
+
+[<401231c0>] (file_ns_capable) from [<40716818>] (__netlink_ns_capable+0x3c/0x48)
+[<40716818>] (__netlink_ns_capable) from [<3f7f8cd8>] (nfnetlink_rcv+0x4c/0x184 [nfnetlink])
+[<3f7f8cd8>] (nfnetlink_rcv [nfnetlink]) from [<4071a2bc>] (netlink_unicast+0x170/0x260)
+[<4071a2bc>] (netlink_unicast) from [<4071a3e8>] (nlmsg_notify+0x3c/0xc8)
+[<4071a3e8>] (nlmsg_notify) from [<3fb182d8>] (ctnetlink_conntrack_event+0x318/0x498 [nf_conntrack_netlink])
+[<3fb182d8>] (ctnetlink_conntrack_event [nf_conntrack_netlink]) from [<40139cb8>] (notifier_call_chain+0x40/0x64)
+[<40139cb8>] (notifier_call_chain) from [<40139e0c>] (atomic_notifier_call_chain+0x30/0x44)
+[<40139e0c>] (atomic_notifier_call_chain) from [<3f7b1008>] (nf_ct_delete+0xc0/0x6f0 [nf_conntrack])
+[<3f7b1008>] (nf_ct_delete [nf_conntrack]) from [<3f7b3648>] (gc_worker+0x4fc/0x638 [nf_conntrack])
+[<3f7b3648>] (gc_worker [nf_conntrack]) from [<3f7b4924>] (ct_file_write+0xa8/0x15c [nf_conntrack])
+[<3f7b4924>] (ct_file_write [nf_conntrack]) from [<40300204>] (proc_simple_write+0x68/0x84)
+[<40300204>] (proc_simple_write) from [<402fa11c>] (proc_reg_write+0xb8/0xc8)
+[<402fa11c>] (proc_reg_write) from [<40295bb0>] (vfs_write+0x108/0x370)
+[<40295bb0>] (vfs_write) from [<40295f58>] (ksys_write+0x68/0xd4)
+[<40295f58>] (ksys_write) from [<40100060>] (ret_fast_syscall+0x0/0x4c)
+
+For 64-bit kernel, it shows (random values portid=2149781056,
+report=4294967232). It doesn't crash, as no socket is found
+for incorrect portid.
+
+Change-Id: If49dbbabbe4bbf3a524e700f8377337183798428
+Signed-off-by: Amitesh Anand <quic_amitesh@quicinc.com>
+---
+ net/netfilter/nf_conntrack_standalone.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/net/netfilter/nf_conntrack_standalone.c
++++ b/net/netfilter/nf_conntrack_standalone.c
+@@ -485,7 +485,7 @@ static int kill_matching(struct nf_conn
+ static int ct_file_write(struct file *file, char *buf, size_t count)
+ {
+ 	struct seq_file *seq = file->private_data;
+-	struct nf_ct_iter_data iter_data;
++	struct nf_ct_iter_data iter_data = { };
+ 	struct kill_request kr = { };
+ 
+ 	if (count == 0)
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960568-net-Fix-Ethernet-warning-info-during-kernel-6.6-comp.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,63 @@
+From 4b78f47e3b89b15db319d7c351a316cf556dd8e7 Mon Sep 17 00:00:00 2001
+From: Feng Pei <quic_fpei@quicinc.com>
+Date: Wed, 22 May 2024 23:59:56 -0700
+Subject: [PATCH] net: Fix Ethernet warning info during kernel 6.6 compilation
+
+Change-Id: I7d14f2da5bf9931fb97ad9a084975be40f63e149
+Signed-off-by: Feng Pei <quic_fpei@quicinc.com>
+---
+ net/bridge/br_if.c | 2 ++
+ net/core/dev.c     | 3 ++-
+ net/ipv4/ipmr.c    | 2 +-
+ net/ipv6/ip6mr.c   | 2 +-
+ net/ipv6/route.c   | 2 +-
+ 5 files changed, 7 insertions(+), 4 deletions(-)
+
+--- a/net/bridge/br_if.c
++++ b/net/bridge/br_if.c
+@@ -799,8 +799,10 @@ struct net_device *br_port_dev_get(struc
+ 				   struct sk_buff *skb,
+ 				   unsigned int cookie)
+ {
++#if !IS_ENABLED(CONFIG_BRIDGE_VLAN_FILTERING)
+ 	struct net_bridge_fdb_entry *fdbe;
+ 	struct net_bridge *br;
++#endif
+ 	struct net_device *netdev = NULL;
+ 	u16 __maybe_unused vid;
+ 
+--- a/net/core/dev.c
++++ b/net/core/dev.c
+@@ -7872,8 +7872,9 @@ EXPORT_SYMBOL(netdev_lower_get_first_pri
+ struct net_device *netdev_master_upper_dev_get_rcu(const struct net_device *dev)
+ {
+ 	struct netdev_adjacent *upper;
++	struct net_device *ndev = (struct net_device *)dev;
+ 
+-	upper = list_first_or_null_rcu(&dev->adj_list.upper,
++	upper = list_first_or_null_rcu(&ndev->adj_list.upper,
+ 				       struct netdev_adjacent, list);
+ 	if (upper && likely(upper->master))
+ 		return upper->dev;
+--- a/net/ipv4/ipmr.c
++++ b/net/ipv4/ipmr.c
+@@ -3186,7 +3186,7 @@ static int ipmr_vif_seq_show(struct seq_
+ 		vif_dev = vif_dev_read(vif);
+ 		name = vif_dev ? vif_dev->name : "none";
+ 		seq_printf(seq,
+-			   "%2td %-10s %8llu %7llu  %8llu %7llu %05X %08X %08X\n",
++			   "%2td %-10s %8lu %7lu  %8lu %7lu %05X %08X %08X\n",
+ 			   vif - mrt->vif_table,
+ 			   name, vif->bytes_in, vif->pkt_in,
+ 			   vif->bytes_out, vif->pkt_out,
+--- a/net/ipv6/ip6mr.c
++++ b/net/ipv6/ip6mr.c
+@@ -528,7 +528,7 @@ static int ip6mr_vif_seq_show(struct seq
+ 		name = vif_dev ? vif_dev->name : "none";
+ 
+ 		seq_printf(seq,
+-			   "%2td %-10s %8llu %7llu  %8llu %7llu %05X\n",
++			   "%2td %-10s %8lu %7lu  %8lu %7lu %05X\n",
+ 			   vif - mrt->vif_table,
+ 			   name, vif->bytes_in, vif->pkt_in,
+ 			   vif->bytes_out, vif->pkt_out,
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960571-include-Increase-max-PPE-PRIO-bands.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,22 @@
+From cfafcea00cc463207c6a7332071f57af059ded03 Mon Sep 17 00:00:00 2001
+From: Amruth S <quic_amrus@quicinc.com>
+Date: Wed, 3 Apr 2024 23:59:51 -0700
+Subject: [PATCH] include: Increase max PPE PRIO bands
+
+Change-Id: I3083e18821888a90fc6a9a5f938901e030e8ab7b
+Signed-off-by: Amruth S <quic_amrus@quicinc.com>
+---
+ include/uapi/linux/pkt_sched.h | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/include/uapi/linux/pkt_sched.h
++++ b/include/uapi/linux/pkt_sched.h
+@@ -177,7 +177,7 @@ struct tc_ppetbl_qopt {
+ 
+ /* PPEPRIO section */
+ 
+-#define TCA_PPEPRIO_MAX_BANDS 4
++#define TCA_PPEPRIO_MAX_BANDS 8
+ 
+ enum {
+         TCA_PPEPRIO_UNSPEC,
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960588-nptv6-Linux-changes-to-offload-NPTv6-flows.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,195 @@
+From b775bef7724e43fd28b22bccace71f00e2b91257 Mon Sep 17 00:00:00 2001
+From: Suhas N Bhargav <quic_sbhargav@quicinc.com>
+Date: Wed, 3 Apr 2024 14:07:17 +0530
+Subject: [PATCH] nptv6: Linux changes to offload NPTv6 flows
+
+Change-Id: Ic4c274569ad3ea49eaa7af414ea8a2ba62838d7c
+Signed-off-by: Suhas N Bhargav <quic_sbhargav@quicinc.com>
+---
+ include/net/netfilter/nf_conntrack_extend.h |  3 +++
+ include/uapi/linux/netfilter/nf_nat.h       |  9 +++++++
+ include/uapi/linux/netfilter/nf_tables.h    | 26 +++++++++++++++++++++
+ net/netfilter/Kconfig                       | 17 ++++++++++++++
+ net/netfilter/Makefile                      |  2 ++
+ net/netfilter/nf_conntrack_core.c           |  6 +++++
+ net/netfilter/nf_conntrack_extend.c         |  8 ++++++-
+ 7 files changed, 70 insertions(+), 1 deletion(-)
+
+--- a/include/net/netfilter/nf_conntrack_extend.h
++++ b/include/net/netfilter/nf_conntrack_extend.h
+@@ -34,6 +34,9 @@ enum nf_ct_ext_id {
+ #ifdef CONFIG_NF_CONNTRACK_DSCPREMARK_EXT
+ 	NF_CT_EXT_DSCPREMARK,
+ #endif
++#ifdef CONFIG_NF_CONNTRACK_NPTV6_EXT
++	NF_CT_EXT_NPTV6,
++#endif
+ 	NF_CT_EXT_NUM,
+ };
+ 
+--- a/include/uapi/linux/netfilter/nf_nat.h
++++ b/include/uapi/linux/netfilter/nf_nat.h
+@@ -52,4 +52,13 @@ struct nf_nat_range2 {
+ 	union nf_conntrack_man_proto	base_proto;
+ };
+ 
++struct nf_npt_info {
++	union nf_inet_addr	src_pfx;
++	union nf_inet_addr	dst_pfx;
++	__u8			src_pfx_len;
++	__u8			dst_pfx_len;
++	/* Used internally by the kernel */
++	__sum16			adjustment;
++};
++
+ #endif /* _NETFILTER_NF_NAT_H */
+--- a/include/uapi/linux/netfilter/nf_tables.h
++++ b/include/uapi/linux/netfilter/nf_tables.h
+@@ -1425,10 +1425,14 @@ enum nft_reject_attributes {
+  *
+  * @NFT_NAT_SNAT: source NAT
+  * @NFT_NAT_DNAT: destination NAT
++ * @NFT_NAT_SNPT: source NPT
++ * @NFT_NAT_DNPT: destination NPT
+  */
+ enum nft_nat_types {
+ 	NFT_NAT_SNAT,
+ 	NFT_NAT_DNAT,
++	NFT_NAT_SNPT,
++	NFT_NAT_DNPT
+ };
+ 
+ /**
+@@ -1488,6 +1492,28 @@ enum nft_masq_attributes {
+ #define NFTA_MASQ_MAX		(__NFTA_MASQ_MAX - 1)
+ 
+ /**
++ * enum nft_npt_attributes - nf_tables NPT expression attributes
++ *
++ * @NFTA_NPT_TYPE: NPT type (NLA_U32: nft_nat_types)
++ * @NFTA_NPT_FAMILY: NPT family (NLA_U32)
++ * @NFTA_NPT_REG_SRC_PFX: register of Source Prefix (NLA_U32: nft_registers)
++ * @NFTA_NPT_REG_DST_PFX: register of Destination Prefix (NLA_U32: nft_registers)
++ * @NFTA_NPT_REG_SRC_PFX_LEN: Source prefix length value (NLA_U8)
++ * @NFTA_NPT_REG_DST_PFX_LEN: Destination prefix length value (NLA_U8)
++ */
++enum nft_npt_attributes {
++	NFTA_NPT_UNSPEC,
++	NFTA_NPT_TYPE,
++	NFTA_NPT_FAMILY,
++	NFTA_NPT_REG_SRC_PFX,
++	NFTA_NPT_REG_DST_PFX,
++	NFTA_NPT_REG_SRC_PFX_LEN,
++	NFTA_NPT_REG_DST_PFX_LEN,
++	__NFTA_NPT_MAX
++};
++#define NFTA_NPT_MAX           (__NFTA_NPT_MAX - 1)
++
++/**
+  * enum nft_redir_attributes - nf_tables redirect expression netlink attributes
+  *
+  * @NFTA_REDIR_REG_PROTO_MIN: source register of proto range start (NLA_U32: nft_registers)
+--- a/net/netfilter/Kconfig
++++ b/net/netfilter/Kconfig
+@@ -181,6 +181,13 @@ config NF_CONNTRACK_DSCPREMARK_EXT
+ 	  This option enables support for connection tracking extension
+ 	  for dscp remark.
+ 
++config NF_CONNTRACK_NPTV6_EXT
++	bool  'Connection tracking extension for nptv6 target'
++	depends on NETFILTER_ADVANCED
++	help
++	  This option enables support for connection tracking extension
++	  for nptv6 to carry NPTv6 info within the conntrack.
++
+ config NF_CONNTRACK_CHAIN_EVENTS
+ 	bool "Register multiple callbacks to ct events"
+ 	depends on NF_CONNTRACK_EVENTS
+@@ -594,6 +601,16 @@ config NFT_NAT
+ 	  This option adds the "nat" expression that you can use to perform
+ 	  typical Network Address Translation (NAT) packet transformations.
+ 
++config NFT_NPT
++	depends on NF_CONNTRACK
++	depends on NF_NAT
++	depends on NF_TABLES_IPV6
++	tristate "Netfilter nf_tables NPT support"
++	help
++	  This option adds the "NPT" expression that you can use to perform
++	  Network Prefix Translation (NPT) packet transformations that is
++	  RFC 6296 compliant.
++
+ config NFT_TUNNEL
+ 	tristate "Netfilter nf_tables tunnel module"
+ 	help
+--- a/net/netfilter/Makefile
++++ b/net/netfilter/Makefile
+@@ -21,6 +21,7 @@ else ifeq ($(CONFIG_NF_CONNTRACK),y)
+ nf_conntrack-$(CONFIG_DEBUG_INFO_BTF) += nf_conntrack_bpf.o
+ endif
+ nf_conntrack-$(CONFIG_NF_CONNTRACK_DSCPREMARK_EXT) += nf_conntrack_dscpremark_ext.o
++nf_conntrack-$(CONFIG_NF_CONNTRACK_NPTV6_EXT) += nf_conntrack_nptv6_ext.o
+ 
+ obj-$(CONFIG_NETFILTER) = netfilter.o
+ obj-$(CONFIG_NETFILTER_BPF_LINK) += nf_bpf_link.o
+@@ -115,6 +116,7 @@ obj-$(CONFIG_NFT_CT)		+= nft_ct.o
+ obj-$(CONFIG_NFT_FLOW_OFFLOAD)	+= nft_flow_offload.o
+ obj-$(CONFIG_NFT_LIMIT)		+= nft_limit.o
+ obj-$(CONFIG_NFT_NAT)		+= nft_nat.o
++obj-$(CONFIG_NFT_NPT)		+= nft_npt.o
+ obj-$(CONFIG_NFT_QUEUE)		+= nft_queue.o
+ obj-$(CONFIG_NFT_QUOTA)		+= nft_quota.o
+ obj-$(CONFIG_NFT_REJECT) 	+= nft_reject.o
+--- a/net/netfilter/nf_conntrack_core.c
++++ b/net/netfilter/nf_conntrack_core.c
+@@ -48,6 +48,9 @@
+ #ifdef CONFIG_NF_CONNTRACK_DSCPREMARK_EXT
+ #include <net/netfilter/nf_conntrack_dscpremark_ext.h>
+ #endif
++#ifdef CONFIG_NF_CONNTRACK_NPTV6_EXT
++#include <net/netfilter/nf_conntrack_nptv6_ext.h>
++#endif
+ #include <net/netfilter/nf_conntrack_labels.h>
+ #include <net/netfilter/nf_conntrack_synproxy.h>
+ #include <net/netfilter/nf_nat.h>
+@@ -1746,6 +1749,9 @@ init_conntrack(struct net *net, struct n
+ #ifdef CONFIG_NF_CONNTRACK_DSCPREMARK_EXT
+ 	nf_ct_dscpremark_ext_add(ct, GFP_ATOMIC);
+ #endif
++#ifdef CONFIG_NF_CONNTRACK_NPTV6_EXT
++	nf_ct_nptv6_ext_add(ct, GFP_ATOMIC);
++#endif
+ 
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
+ 	ecache = tmpl ? nf_ct_ecache_find(tmpl) : NULL;
+--- a/net/netfilter/nf_conntrack_extend.c
++++ b/net/netfilter/nf_conntrack_extend.c
+@@ -25,6 +25,7 @@
+ #include <net/netfilter/nf_conntrack_act_ct.h>
+ #include <net/netfilter/nf_nat.h>
+ #include <net/netfilter/nf_conntrack_dscpremark_ext.h>
++#include <net/netfilter/nf_conntrack_nptv6_ext.h>
+ 
+ #define NF_CT_EXT_PREALLOC	128u /* conntrack events are on by default */
+ 
+@@ -58,7 +59,9 @@ static const u8 nf_ct_ext_type_len[NF_CT
+ #ifdef CONFIG_NF_CONNTRACK_DSCPREMARK_EXT
+ 	[NF_CT_EXT_DSCPREMARK] = sizeof(struct nf_ct_dscpremark_ext),
+ #endif
+-
++#ifdef CONFIG_NF_CONNTRACK_NPTV6_EXT
++        [NF_CT_EXT_NPTV6] = sizeof(struct nf_ct_nptv6_ext),
++#endif
+ };
+ 
+ static __always_inline unsigned int total_extension_size(void)
+@@ -94,6 +97,9 @@ static __always_inline unsigned int tota
+ #ifdef CONFIG_NF_CONNTRACK_DSCPREMARK_EXT
+ 		+ sizeof(struct nf_ct_dscpremark_ext)
+ #endif
++#ifdef CONFIG_NF_CONNTRACK_NPTV6_EXT
++		+ sizeof(struct nf_ct_nptv6_ext)
++#endif
+ 	;
+ }
+ 
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960611-net-bridge-OMCI-support-in-Linux-bridge-with-dst-che.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,136 @@
+From 36236b9f073f5f1344db75bd6579f6e5a610a0d4 Mon Sep 17 00:00:00 2001
+From: Amit Gupta <quic_amitgupt@quicinc.com>
+Date: Thu, 7 Mar 2024 19:22:53 +0530
+Subject: [PATCH] [net] [bridge] OMCI support in Linux bridge with dst check
+
+- Enable support for bridge inside bridge, which
+allow flooding only with in sub-bridges.
+- Introduce a notion of upstream port. For upstream
+port, the sub-bridge restriction does not apply.
+
+Change-Id: Idf0f9d7c4409db5c0f8eeb6b07f55a1c5a541c39
+Signed-off-by: Amit Gupta <quic_amitgupt@quicinc.com>
+---
+ include/linux/if_bridge.h |  1 +
+ net/bridge/br_forward.c   |  8 ++++++++
+ net/bridge/br_if.c        | 11 +++++++++++
+ net/bridge/br_input.c     |  8 ++++++++
+ net/bridge/br_private.h   |  2 ++
+ net/bridge/br_sysfs_if.c  | 11 +++++++++++
+ 6 files changed, 41 insertions(+)
+
+--- a/include/linux/if_bridge.h
++++ b/include/linux/if_bridge.h
+@@ -62,6 +62,7 @@ struct br_ip_list {
+ #define BR_PORT_MAB		BIT(22)
+ #define BR_NEIGH_VLAN_SUPPRESS	BIT(23)
+ #define BR_BPDU_FILTER		BIT(24)
++#define BR_UPSTREAM_PORT	BIT(25)
+ 
+ #define BR_DEFAULT_AGEING_TIME	(300 * HZ)
+ 
+--- a/net/bridge/br_forward.c
++++ b/net/bridge/br_forward.c
+@@ -203,6 +203,7 @@ void br_flood(struct net_bridge *br, str
+ 	      u16 vid)
+ {
+ 	const unsigned char *dest = eth_hdr(skb)->h_dest;
++	struct net_bridge_port *srcp = br_port_get_rcu(skb->dev);
+ 	struct net_bridge_port *prev = NULL;
+ 	struct net_bridge_port *p;
+ 
+@@ -239,6 +240,13 @@ void br_flood(struct net_bridge *br, str
+ 		     br_is_neigh_suppress_enabled(p, vid)))
+ 			continue;
+ 
++		/* Do not flood to non-upstream port and to ports in different sub bridge */
++		if (srcp &&
++			!((p->flags & BR_UPSTREAM_PORT) || (srcp->flags & BR_UPSTREAM_PORT))
++			&& (p->sub_br_id != srcp->sub_br_id))
++			continue;
++
++
+ 		prev = maybe_deliver(prev, p, skb, local_orig);
+ 		if (IS_ERR(prev))
+ 			goto out;
+--- a/net/bridge/br_if.c
++++ b/net/bridge/br_if.c
+@@ -886,3 +886,14 @@ bool br_is_hairpin_enabled(struct net_de
+ 	return false;
+ }
+ EXPORT_SYMBOL_GPL(br_is_hairpin_enabled);
++
++/*
++ * Set sub bridge ID on a bridge port
++ */
++int br_port_set_sub_br_id(struct net_bridge_port *p, unsigned long new_sub_br_id)
++{
++	pr_info("Set sub br id old: %d, new: %lu\n", p->sub_br_id, new_sub_br_id);
++
++	p->sub_br_id = new_sub_br_id;
++	return 0;
++}
+--- a/net/bridge/br_input.c
++++ b/net/bridge/br_input.c
+@@ -215,8 +215,16 @@ int br_handle_frame_finish(struct net *n
+ 		if (pdst) {
+ 			if (!skb)
+ 				goto out;
++			/* TODO: Check if sub bridge concept apply to hyfi */
+ 		} else {
+ 			dst = br_fdb_find_rcu(br, eth_hdr(skb)->h_dest, vid);
++
++			/* Restrict forwarding to/from upstream port & within same sub bridge */
++			if (dst && dst->dst &&
++				!((p->flags & BR_UPSTREAM_PORT) || (dst->dst->flags & BR_UPSTREAM_PORT))
++				&& (p->sub_br_id != dst->dst->sub_br_id))
++				dst = NULL;
++
+ 		}
+ 		break;
+ 	default:
+--- a/net/bridge/br_private.h
++++ b/net/bridge/br_private.h
+@@ -391,6 +391,7 @@ struct net_bridge_port {
+ 	u32				backup_nhid;
+ 
+ 	/* STP */
++	u8				sub_br_id;
+ 	u8				priority;
+ 	u8				state;
+ 	u16				port_no;
+@@ -906,6 +907,7 @@ netdev_features_t br_features_recompute(
+ void br_port_flags_change(struct net_bridge_port *port, unsigned long mask);
+ void br_manage_promisc(struct net_bridge *br);
+ int nbp_backup_change(struct net_bridge_port *p, struct net_device *backup_dev);
++int br_port_set_sub_br_id(struct net_bridge_port *p, unsigned long new_sub_br_id);
+ 
+ /* br_input.c */
+ int br_pass_frame_up(struct sk_buff *skb);
+--- a/net/bridge/br_sysfs_if.c
++++ b/net/bridge/br_sysfs_if.c
+@@ -229,6 +229,15 @@ static int store_backup_port(struct net_
+ }
+ static BRPORT_ATTR_RAW(backup_port, 0644, show_backup_port, store_backup_port);
+ 
++static ssize_t show_sub_br_id(struct net_bridge_port *p, char *buf)
++{
++	return snprintf(buf, sizeof(u16), "%d\n", p->sub_br_id);
++}
++
++static BRPORT_ATTR(sub_br_id, 0644,
++		show_sub_br_id, br_port_set_sub_br_id);
++
++BRPORT_ATTR_FLAG(upstream_port, BR_UPSTREAM_PORT);
+ BRPORT_ATTR_FLAG(hairpin_mode, BR_HAIRPIN_MODE);
+ BRPORT_ATTR_FLAG(bpdu_guard, BR_BPDU_GUARD);
+ BRPORT_ATTR_FLAG(root_block, BR_ROOT_BLOCK);
+@@ -295,6 +304,8 @@ static const struct brport_attribute *br
+ 	&brport_attr_isolated,
+ 	&brport_attr_bpdu_filter,
+ 	&brport_attr_backup_port,
++	&brport_attr_sub_br_id,
++	&brport_attr_upstream_port,
+ 	NULL
+ };
+ 
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960612-net-bridge-Per-bridge-port-MAC-learn-limit.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,158 @@
+From cc3c2cae819effe25d290d9306da41618368d304 Mon Sep 17 00:00:00 2001
+From: Amitesh Anand <quic_amitesh@quicinc.com>
+Date: Fri, 23 Feb 2024 17:14:01 +0530
+Subject: [PATCH] [net] [bridge] Per bridge port MAC learn limit
+
+Introduce a per bridge port MAC learn limit and
+count.
+
+Change-Id: I0e51239b36da384064640b3b72442da28232370a
+Signed-off-by: Amit Gupta <quic_amitgupt@quicinc.com>
+Signed-off-by: Amitesh Anand <quic_amitesh@quicinc.com>
+---
+ net/bridge/br_fdb.c      | 25 +++++++++++++++++++++++++
+ net/bridge/br_if.c       | 17 +++++++++++++++++
+ net/bridge/br_private.h  |  3 +++
+ net/bridge/br_sysfs_if.c | 17 +++++++++++++++++
+ 4 files changed, 62 insertions(+)
+
+--- a/net/bridge/br_fdb.c
++++ b/net/bridge/br_fdb.c
+@@ -357,6 +357,10 @@ static void fdb_delete(struct net_bridge
+ {
+ 	trace_fdb_delete(br, f);
+ 
++	if (f->dst && f->dst->mac_lrn_limit) {
++		f->dst->mac_lrn_cnt--;
++	}
++
+ 	if (test_bit(BR_FDB_STATIC, &f->flags))
+ 		fdb_del_hw_addr(br, f->key.addr.addr);
+ 
+@@ -425,6 +429,12 @@ static struct net_bridge_fdb_entry *fdb_
+ 	struct net_bridge_fdb_entry *fdb;
+ 	int err;
+ 
++	/* Do not learn if MAC learn limit is reached for the given source */
++	if (source && source->mac_lrn_limit
++		&& (source->mac_lrn_cnt >= source->mac_lrn_limit)) {
++		return NULL;
++	}
++
+ 	fdb = kmem_cache_alloc(br_fdb_cache, GFP_ATOMIC);
+ 	if (!fdb)
+ 		return NULL;
+@@ -443,6 +453,10 @@ static struct net_bridge_fdb_entry *fdb_
+ 
+ 	hlist_add_head_rcu(&fdb->fdb_node, &br->fdb_list);
+ 
++	if (source && fdb && source->mac_lrn_limit) {
++		source->mac_lrn_cnt++;
++	}
++
+ 	return fdb;
+ }
+ 
+@@ -916,6 +930,7 @@ void br_fdb_update(struct net_bridge *br
+ 		   const unsigned char *addr, u16 vid, unsigned long flags)
+ {
+ 	struct net_bridge_fdb_entry *fdb;
++	struct net_bridge_port *dst_orig;
+ 	struct br_fdb_event fdb_event;
+ 
+ 	/* some users want to always flood. */
+@@ -946,9 +961,19 @@ void br_fdb_update(struct net_bridge *br
+ 				fdb_event.br = br;
+ 				fdb_event.orig_dev = fdb->dst->dev;
+ 				fdb_event.dev = source->dev;
++				dst_orig = fdb->dst;
+ 				WRITE_ONCE(fdb->dst, source);
+ 				fdb_modified = true;
+ 
++				/* Updated the number of learned entries for both new and old source */
++				if (dst_orig && dst_orig->mac_lrn_limit) {
++					dst_orig->mac_lrn_cnt--;
++				}
++
++				if (source && source->mac_lrn_limit) {
++					source->mac_lrn_cnt++;
++				}
++
+ 				/* Take over HW learned entry */
+ 				if (unlikely(test_bit(BR_FDB_ADDED_BY_EXT_LEARN,
+ 						      &fdb->flags)))
+--- a/net/bridge/br_if.c
++++ b/net/bridge/br_if.c
+@@ -897,3 +897,20 @@ int br_port_set_sub_br_id(struct net_bri
+ 	p->sub_br_id = new_sub_br_id;
+ 	return 0;
+ }
++
++/*
++ * Set per bridge port MAC learn limit
++ */
++int br_port_set_mac_lrn_limit(struct net_bridge_port *p, unsigned long new_mac_lrn_limit)
++{
++	pr_info("Set mac learn limit old: %d, new: %lu\n", p->mac_lrn_limit, new_mac_lrn_limit);
++
++	p->mac_lrn_limit = new_mac_lrn_limit;
++
++	/* Reset current mac learn cnt when mac learn limit is disabled */
++	if(!p->mac_lrn_limit) {
++		p->mac_lrn_cnt = 0;
++	}
++
++	return 0;
++}
+--- a/net/bridge/br_private.h
++++ b/net/bridge/br_private.h
+@@ -394,6 +394,8 @@ struct net_bridge_port {
+ 	u8				sub_br_id;
+ 	u8				priority;
+ 	u8				state;
++	u16				mac_lrn_cnt;
++	u16				mac_lrn_limit;
+ 	u16				port_no;
+ 	unsigned char			topology_change_ack;
+ 	unsigned char			config_pending;
+@@ -908,6 +910,7 @@ void br_port_flags_change(struct net_bri
+ void br_manage_promisc(struct net_bridge *br);
+ int nbp_backup_change(struct net_bridge_port *p, struct net_device *backup_dev);
+ int br_port_set_sub_br_id(struct net_bridge_port *p, unsigned long new_sub_br_id);
++int br_port_set_mac_lrn_limit(struct net_bridge_port *p, unsigned long new_mac_lrn_limit);
+ 
+ /* br_input.c */
+ int br_pass_frame_up(struct sk_buff *skb);
+--- a/net/bridge/br_sysfs_if.c
++++ b/net/bridge/br_sysfs_if.c
+@@ -237,6 +237,21 @@ static ssize_t show_sub_br_id(struct net
+ static BRPORT_ATTR(sub_br_id, 0644,
+ 		show_sub_br_id, br_port_set_sub_br_id);
+ 
++static ssize_t show_mac_lrn_limit(struct net_bridge_port *p, char *buf)
++{
++	return snprintf(buf, sizeof(u16), "%d\n", p->mac_lrn_limit);
++}
++
++static BRPORT_ATTR(mac_lrn_limit, 0644,
++			 show_mac_lrn_limit, br_port_set_mac_lrn_limit);
++
++static ssize_t show_mac_lrn_cnt(struct net_bridge_port *p, char *buf)
++{
++	return snprintf(buf, sizeof(u16), "%d\n", p->mac_lrn_cnt);
++}
++
++static BRPORT_ATTR(mac_lrn_cnt, 0444, show_mac_lrn_cnt, NULL);
++
+ BRPORT_ATTR_FLAG(upstream_port, BR_UPSTREAM_PORT);
+ BRPORT_ATTR_FLAG(hairpin_mode, BR_HAIRPIN_MODE);
+ BRPORT_ATTR_FLAG(bpdu_guard, BR_BPDU_GUARD);
+@@ -306,6 +321,8 @@ static const struct brport_attribute *br
+ 	&brport_attr_backup_port,
+ 	&brport_attr_sub_br_id,
+ 	&brport_attr_upstream_port,
++	&brport_attr_mac_lrn_limit,
++	&brport_attr_mac_lrn_cnt,
+ 	NULL
+ };
+ 
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960653-net-bridge-Fix-mac_learn_limit-underflow-for-initial.patch	2024-12-13 18:14:14.980309585 +0800
@@ -0,0 +1,32 @@
+From 35146909f659ead6d803c1d01e63b1f9da15742d Mon Sep 17 00:00:00 2001
+From: Karthik T S <quic_kartikts@quicinc.com>
+Date: Wed, 18 Sep 2024 11:01:19 +0530
+Subject: [PATCH] [net] [bridge] Fix mac_learn_limit underflow for initial
+ bridge fdb flush
+
+Change-Id: I5059ad30741b1feec9b9a9e592f9360f8734609e
+Signed-off-by: Karthik T S <quic_kartikts@quicinc.com>
+---
+ net/bridge/br_fdb.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/net/bridge/br_fdb.c
++++ b/net/bridge/br_fdb.c
+@@ -357,7 +357,7 @@ static void fdb_delete(struct net_bridge
+ {
+ 	trace_fdb_delete(br, f);
+ 
+-	if (f->dst && f->dst->mac_lrn_limit) {
++	if (f->dst && f->dst->mac_lrn_limit && (f->dst->mac_lrn_cnt > 0)) {
+ 		f->dst->mac_lrn_cnt--;
+ 	}
+ 
+@@ -966,7 +966,7 @@ void br_fdb_update(struct net_bridge *br
+ 				fdb_modified = true;
+ 
+ 				/* Updated the number of learned entries for both new and old source */
+-				if (dst_orig && dst_orig->mac_lrn_limit) {
++				if (dst_orig && dst_orig->mac_lrn_limit && (dst_orig->mac_lrn_cnt > 0)) {
+ 					dst_orig->mac_lrn_cnt--;
+ 				}
+ 
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960664-Netfilter-Set-int_pri-value-in-skb.patch	2024-12-13 18:14:14.981309583 +0800
@@ -0,0 +1,48 @@
+From b81037398809b3911a2e9acc550582a68a977dbc Mon Sep 17 00:00:00 2001
+From: Karthik Prasanna N <quic_kartn@quicinc.com>
+Date: Mon, 24 Jun 2024 16:00:03 +0530
+Subject: [PATCH] Netfilter: Set int_pri value in skb
+
+Setting the int_pri field in the sk buffer for the packets.
+
+Change-Id: Ib2e3b00c9fd2d44467bc87a19b25df435320d911
+Signed-off-by: Karthik Prasanna N <quic_kartn@quicinc.com>
+---
+ include/uapi/linux/netfilter/xt_CLASSIFY.h | 7 +++++++
+ net/netfilter/xt_CLASSIFY.c                | 7 ++++++-
+ 2 files changed, 13 insertions(+), 1 deletion(-)
+
+--- a/include/uapi/linux/netfilter/xt_CLASSIFY.h
++++ b/include/uapi/linux/netfilter/xt_CLASSIFY.h
+@@ -4,8 +4,15 @@
+ 
+ #include <linux/types.h>
+ 
++enum {
++	XT_SET_PRIORITY = 1 << 0,
++	XT_SET_INT_PRI = 1 << 1
++};
++
+ struct xt_classify_target_info {
+ 	__u32 priority;
++	__u8 int_pri;
++	__u8 set_flags;
+ };
+ 
+ #endif /*_XT_CLASSIFY_H */
+--- a/net/netfilter/xt_CLASSIFY.c
++++ b/net/netfilter/xt_CLASSIFY.c
+@@ -30,7 +30,12 @@ classify_tg(struct sk_buff *skb, const s
+ {
+ 	const struct xt_classify_target_info *clinfo = par->targinfo;
+ 
+-	skb->priority = clinfo->priority;
++	if (XT_SET_PRIORITY & clinfo->set_flags)
++		skb->priority = clinfo->priority;
++
++	if (XT_SET_INT_PRI & clinfo->set_flags)
++		skb->int_pri = clinfo->int_pri;
++
+ 	return XT_CONTINUE;
+ }
+ 
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960672-vxlan-null-check-for-vxlan-listening-socket.patch	2024-12-13 18:14:14.981309583 +0800
@@ -0,0 +1,33 @@
+From 4523fdb0215309bd8324384c3f480946af8caeb6 Mon Sep 17 00:00:00 2001
+From: Pritam Jha <quic_pritamku@quicinc.com>
+Date: Mon, 7 Oct 2024 12:00:11 +0530
+Subject: [PATCH] vxlan: null check for vxlan listening socket
+
+Change-Id: I14bd79958ba1595b30af6b966fe240c9053c5f0c
+Signed-off-by: Pritam Jha <quic_pritamku@quicinc.com>
+---
+ drivers/net/vxlan/vxlan_core.c | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+--- a/drivers/net/vxlan/vxlan_core.c
++++ b/drivers/net/vxlan/vxlan_core.c
+@@ -2597,6 +2597,9 @@ void vxlan_xmit_one(struct sk_buff *skb,
+ 		struct rtable *rt;
+ 		__be16 df = 0;
+ 
++		if (unlikely(!sock4))
++			goto tx_error;
++
+ 		if (!ifindex)
+ 			ifindex = sock4->sock->sk->sk_bound_dev_if;
+ 
+@@ -2673,6 +2676,9 @@ void vxlan_xmit_one(struct sk_buff *skb,
+ 	} else {
+ 		struct vxlan_sock *sock6 = rcu_dereference(vxlan->vn6_sock);
+ 
++		if (unlikely(!sock6))
++			goto tx_error;
++
+ 		if (!ifindex)
+ 			ifindex = sock6->sock->sk->sk_bound_dev_if;
+ 
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960674-net-bridge-Add-no-hairpin-flood-attribute.patch	2024-12-13 18:14:14.981309583 +0800
@@ -0,0 +1,45 @@
+From 2c8b541fe19d51a4b08766ef545da4057e6a4333 Mon Sep 17 00:00:00 2001
+From: Ken Zhu <quic_guigenz@quicinc.com>
+Date: Mon, 6 May 2024 19:21:26 -0700
+Subject: [PATCH] [net][bridge] Add no hairpin flood attribute
+
+Add no hairpin flood attribute to the bridge port,
+when it is true, don't flood mcast/bcast to the
+originated port even hairpin is enabled.
+
+Change-Id: I6a6ad4aa487d9ab01a61749481fc361179431d72
+Signed-off-by: Ken Zhu <quic_guigenz@quicinc.com>
+---
+ include/linux/if_bridge.h |  1 +
+ net/bridge/br_forward.c   | 33 +++++++++++----------------------
+ net/bridge/br_sysfs_if.c  |  2 ++
+ 3 files changed, 14 insertions(+), 22 deletions(-)
+
+--- a/include/linux/if_bridge.h
++++ b/include/linux/if_bridge.h
+@@ -63,6 +63,7 @@ struct br_ip_list {
+ #define BR_NEIGH_VLAN_SUPPRESS	BIT(23)
+ #define BR_BPDU_FILTER		BIT(24)
+ #define BR_UPSTREAM_PORT	BIT(25)
++#define BR_NO_HAIRPIN_FLOOD	BIT(26)
+ 
+ #define BR_DEFAULT_AGEING_TIME	(300 * HZ)
+ 
+--- a/net/bridge/br_sysfs_if.c
++++ b/net/bridge/br_sysfs_if.c
+@@ -265,6 +265,7 @@ BRPORT_ATTR_FLAG(broadcast_flood, BR_BCA
+ BRPORT_ATTR_FLAG(neigh_suppress, BR_NEIGH_SUPPRESS);
+ BRPORT_ATTR_FLAG(isolated, BR_ISOLATED);
+ BRPORT_ATTR_FLAG(bpdu_filter, BR_BPDU_FILTER);
++BRPORT_ATTR_FLAG(no_hairpin_flood, BR_NO_HAIRPIN_FLOOD);
+ 
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ static ssize_t show_multicast_router(struct net_bridge_port *p, char *buf)
+@@ -323,6 +324,7 @@ static const struct brport_attribute *br
+ 	&brport_attr_upstream_port,
+ 	&brport_attr_mac_lrn_limit,
+ 	&brport_attr_mac_lrn_cnt,
++	&brport_attr_no_hairpin_flood,
+ 	NULL
+ };
+ 
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960733-Fix-patch-differences-w.r.t-6.6.47-linux-version.patch	2024-12-13 18:14:14.981309583 +0800
@@ -0,0 +1,94 @@
+From 96cf6de694a997eefc19276ff72dd54e39f5a81e Mon Sep 17 00:00:00 2001
+From: Aravind Mosam <amosam@qti.qualcomm.com>
+Date: Wed, 20 Nov 2024 00:52:42 +0530
+Subject: [PATCH] Fix patch differences w.r.t 6.6.47 linux version
+
+Change-Id: I6418d22dfe763351c8a9b000509e716482b66dd6
+Signed-off-by: Aravind Mosam <amosam@qti.qualcomm.com>
+---
+ net/bridge/br_input.c |  9 +++------
+ net/ethernet/eth.c    | 20 +++++++++++++++-----
+ 2 files changed, 18 insertions(+), 11 deletions(-)
+
+diff --git a/net/bridge/br_input.c b/net/bridge/br_input.c
+index 9a4225ca7cb5..3ad65c2a2947 100644
+--- a/net/bridge/br_input.c
++++ b/net/bridge/br_input.c
+@@ -73,8 +73,6 @@ int br_pass_frame_up(struct sk_buff *skb)
+ 	br_multicast_count(br, NULL, skb, br_multicast_igmp_type(skb),
+ 			   BR_MCAST_DIR_TX);
+ 
+-	BR_INPUT_SKB_CB(skb)->promisc = promisc;
+-
+ 	return BR_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN,
+ 		       dev_net(indev), NULL, skb, indev, NULL,
+ 		       br_netif_receive_skb);
+@@ -151,8 +149,7 @@ int br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb
+ 	if (p->flags & BR_LEARNING)
+ 		br_fdb_update(br, p, eth_hdr(skb)->h_source, vid, 0);
+ 
+-	promisc = !!(br->dev->flags & IFF_PROMISC);
+-	local_rcv = promisc;
++	local_rcv = !!(br->dev->flags & IFF_PROMISC);
+ 
+ 	if (is_multicast_ether_addr(eth_hdr(skb)->h_dest)) {
+ 		/* by definition the broadcast is also a multicast address */
+@@ -234,7 +231,7 @@ int br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb
+ 		unsigned long now = jiffies;
+ 
+ 		if (test_bit(BR_FDB_LOCAL, &dst->flags))
+-			return br_pass_frame_up(skb, false);
++			return br_pass_frame_up(skb);
+ 
+ 		if (now != dst->used)
+ 			dst->used = now;
+@@ -253,7 +250,7 @@ int br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb
+ 
+ out1:
+ 	if (local_rcv)
+-		return br_pass_frame_up(skb, promisc);
++		return br_pass_frame_up(skb);
+ 
+ out:
+ 	return 0;
+diff --git a/net/ethernet/eth.c b/net/ethernet/eth.c
+index 3a1c3bd31701..70558d830f77 100644
+--- a/net/ethernet/eth.c
++++ b/net/ethernet/eth.c
+@@ -182,7 +182,21 @@ __be16 eth_type_trans(struct sk_buff *skb, struct net_device *dev)
+ 	eth = (struct ethhdr *)skb->data;
+ 	skb_pull_inline(skb, ETH_HLEN);
+ 
+-	eth_skb_pkt_type(skb, dev);
++	if (unlikely(!ether_addr_equal_64bits(eth->h_dest,
++					      dev->dev_addr))) {
++		if (unlikely(is_multicast_ether_addr_64bits(eth->h_dest))) {
++			if (ether_addr_equal_64bits(eth->h_dest, dev->broadcast))
++				skb->pkt_type = PACKET_BROADCAST;
++			else
++				skb->pkt_type = PACKET_MULTICAST;
++		} else {
++			skb->pkt_type = PACKET_OTHERHOST;
++		}
++
++		if (eth_check_local_mask(eth->h_dest, dev->dev_addr,
++					 dev->local_addr_mask))
++			skb->gro_skip = 1;
++	}
+ 
+ 	/*
+ 	 * Some variants of DSA tagging don't have an ethertype field
+@@ -437,10 +451,6 @@ struct sk_buff *eth_gro_receive(struct list_head *head, struct sk_buff *skb)
+ 			NAPI_GRO_CB(p)->same_flow = 0;
+ 			continue;
+ 		}
+-
+-		if (eth_check_local_mask(eth->h_dest, dev->dev_addr,
+-					 dev->local_addr_mask))
+-			skb->gro_skip = 1;
+ 	}
+ 
+ 	type = eh->h_proto;
+-- 
+2.34.1
+
--- /dev/null	2024-12-20 19:34:43.352999992 +0800
+++ b/target/linux/generic/hack-6.6/960750-add-skbuff-recycler-skb-flags.patch	2024-12-24 15:08:50.402297263 +0800
@@ -0,0 +1,11 @@
+--- a/net/core/skbuff_recycle.c	2024-12-14 18:48:21.212577520 +0800
++++ b/net/core/skbuff_recycle.c	2024-12-14 19:44:10.163353554 +0800
+@@ -76,6 +76,8 @@ void skb_recycler_clear_flags(struct sk_
+ 	skb->is_from_recycler = 0;
+ 	skb->fast_recycled = 0;
+ 	skb->recycled_for_ds = 0;
++	skb->fast_qdisc = 0;
++	skb->int_pri = 0;
+ }
+ 
+ inline struct sk_buff *skb_recycler_alloc(struct net_device *dev,
